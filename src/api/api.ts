// tslint:disable
/**
 * Webitel engine API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2019.0.0
 * Contact: support@webitel.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as globalImportUrl from 'url'
import { Configuration } from './configuration'
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from './base'

/**
 *
 * @export
 * @interface AgentInQueueStatisticsAgentInQueueStatisticsItem
 */
export interface AgentInQueueStatisticsAgentInQueueStatisticsItem {
  /**
   *
   * @type {EngineLookup}
   * @memberof AgentInQueueStatisticsAgentInQueueStatisticsItem
   */
  bucket?: EngineLookup
  /**
   *
   * @type {number}
   * @memberof AgentInQueueStatisticsAgentInQueueStatisticsItem
   */
  member_waiting?: number
  /**
   *
   * @type {EngineLookup}
   * @memberof AgentInQueueStatisticsAgentInQueueStatisticsItem
   */
  skill?: EngineLookup
}
/**
 *
 * @export
 * @interface CreateCallRequestCallSettings
 */
export interface CreateCallRequestCallSettings {
  /**
   *
   * @type {boolean}
   * @memberof CreateCallRequestCallSettings
   */
  audio?: boolean
  /**
   *
   * @type {boolean}
   * @memberof CreateCallRequestCallSettings
   */
  record?: boolean
  /**
   *
   * @type {boolean}
   * @memberof CreateCallRequestCallSettings
   */
  screen?: boolean
  /**
   *
   * @type {number}
   * @memberof CreateCallRequestCallSettings
   */
  timeout?: number
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof CreateCallRequestCallSettings
   */
  variables?: { [key: string]: string }
  /**
   *
   * @type {boolean}
   * @memberof CreateCallRequestCallSettings
   */
  video?: boolean
}
/**
 *
 * @export
 * @interface CreateCallRequestEndpointRequest
 */
export interface CreateCallRequestEndpointRequest {
  /**
   *
   * @type {string}
   * @memberof CreateCallRequestEndpointRequest
   */
  app_id?: string
  /**
   *
   * @type {string}
   * @memberof CreateCallRequestEndpointRequest
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof CreateCallRequestEndpointRequest
   */
  type?: string
}
/**
 *
 * @export
 * @interface EngineAcceptOfDay
 */
export interface EngineAcceptOfDay {
  /**
   *
   * @type {number}
   * @memberof EngineAcceptOfDay
   */
  day?: number
  /**
   *
   * @type {boolean}
   * @memberof EngineAcceptOfDay
   */
  disabled?: boolean
  /**
   *
   * @type {number}
   * @memberof EngineAcceptOfDay
   */
  end_time_of_day?: number
  /**
   *
   * @type {number}
   * @memberof EngineAcceptOfDay
   */
  start_time_of_day?: number
}
/**
 *
 * @export
 * @interface EngineActiveCall
 */
export interface EngineActiveCall {
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineActiveCall
   */
  agent?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineActiveCall
   */
  answered_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineActiveCall
   */
  app_id?: string
  /**
   *
   * @type {number}
   * @memberof EngineActiveCall
   */
  bill_sec?: number
  /**
   *
   * @type {string}
   * @memberof EngineActiveCall
   */
  bridged_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineActiveCall
   */
  created_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineActiveCall
   */
  destination?: string
  /**
   *
   * @type {string}
   * @memberof EngineActiveCall
   */
  direction?: string
  /**
   *
   * @type {string}
   * @memberof EngineActiveCall
   */
  display?: string
  /**
   *
   * @type {number}
   * @memberof EngineActiveCall
   */
  duration?: number
  /**
   *
   * @type {string}
   * @memberof EngineActiveCall
   */
  extension?: string
  /**
   *
   * @type {EngineEndpoint}
   * @memberof EngineActiveCall
   */
  from?: EngineEndpoint
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineActiveCall
   */
  gateway?: EngineLookup
  /**
   *
   * @type {number}
   * @memberof EngineActiveCall
   */
  hold_sec?: number
  /**
   *
   * @type {string}
   * @memberof EngineActiveCall
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineActiveCall
   */
  joined_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineActiveCall
   */
  leaving_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineActiveCall
   */
  member?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineActiveCall
   */
  parent_id?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineActiveCall
   */
  queue?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineActiveCall
   */
  queue_bridged_at?: string
  /**
   *
   * @type {number}
   * @memberof EngineActiveCall
   */
  queue_duration_sec?: number
  /**
   *
   * @type {number}
   * @memberof EngineActiveCall
   */
  queue_wait_sec?: number
  /**
   *
   * @type {string}
   * @memberof EngineActiveCall
   */
  reporting_at?: string
  /**
   *
   * @type {number}
   * @memberof EngineActiveCall
   */
  reporting_sec?: number
  /**
   *
   * @type {string}
   * @memberof EngineActiveCall
   */
  state?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineActiveCall
   */
  team?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineActiveCall
   */
  timestamp?: string
  /**
   *
   * @type {EngineEndpoint}
   * @memberof EngineActiveCall
   */
  to?: EngineEndpoint
  /**
   *
   * @type {string}
   * @memberof EngineActiveCall
   */
  type?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineActiveCall
   */
  user?: EngineLookup
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof EngineActiveCall
   */
  variables?: { [key: string]: string }
  /**
   *
   * @type {number}
   * @memberof EngineActiveCall
   */
  wait_sec?: number
}
/**
 *
 * @export
 * @interface EngineAgent
 */
export interface EngineAgent {
  /**
   *
   * @type {Array<EngineAgentChannel>}
   * @memberof EngineAgent
   */
  channels?: Array<EngineAgentChannel>
  /**
   *
   * @type {string}
   * @memberof EngineAgent
   */
  description?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineAgent
   */
  greeting_media?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineAgent
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineAgent
   */
  last_status_change?: string
  /**
   *
   * @type {string}
   * @memberof EngineAgent
   */
  name?: string
  /**
   *
   * @type {number}
   * @memberof EngineAgent
   */
  progressive_count?: number
  /**
   *
   * @type {string}
   * @memberof EngineAgent
   */
  status?: string
  /**
   *
   * @type {string}
   * @memberof EngineAgent
   */
  status_duration?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineAgent
   */
  user?: EngineLookup
}
/**
 *
 * @export
 * @interface EngineAgentCallStatistics
 */
export interface EngineAgentCallStatistics {
  /**
   *
   * @type {number}
   * @memberof EngineAgentCallStatistics
   */
  abandoned?: number
  /**
   *
   * @type {number}
   * @memberof EngineAgentCallStatistics
   */
  avg_hold_sec?: number
  /**
   *
   * @type {number}
   * @memberof EngineAgentCallStatistics
   */
  avg_talk_sec?: number
  /**
   *
   * @type {number}
   * @memberof EngineAgentCallStatistics
   */
  count?: number
  /**
   *
   * @type {number}
   * @memberof EngineAgentCallStatistics
   */
  handles?: number
  /**
   *
   * @type {number}
   * @memberof EngineAgentCallStatistics
   */
  max_hold_sec?: number
  /**
   *
   * @type {number}
   * @memberof EngineAgentCallStatistics
   */
  max_talk_sec?: number
  /**
   *
   * @type {number}
   * @memberof EngineAgentCallStatistics
   */
  min_hold_sec?: number
  /**
   *
   * @type {number}
   * @memberof EngineAgentCallStatistics
   */
  min_talk_sec?: number
  /**
   *
   * @type {string}
   * @memberof EngineAgentCallStatistics
   */
  name?: string
  /**
   *
   * @type {number}
   * @memberof EngineAgentCallStatistics
   */
  sum_hold_sec?: number
  /**
   *
   * @type {number}
   * @memberof EngineAgentCallStatistics
   */
  sum_talk_sec?: number
}
/**
 *
 * @export
 * @interface EngineAgentCallStatisticsList
 */
export interface EngineAgentCallStatisticsList {
  /**
   *
   * @type {Array<EngineAgentCallStatistics>}
   * @memberof EngineAgentCallStatisticsList
   */
  items?: Array<EngineAgentCallStatistics>
  /**
   *
   * @type {boolean}
   * @memberof EngineAgentCallStatisticsList
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineAgentChannel
 */
export interface EngineAgentChannel {
  /**
   *
   * @type {string}
   * @memberof EngineAgentChannel
   */
  channel?: string
  /**
   *
   * @type {string}
   * @memberof EngineAgentChannel
   */
  joined_at?: string
  /**
   *
   * @type {boolean}
   * @memberof EngineAgentChannel
   */
  online?: boolean
  /**
   *
   * @type {string}
   * @memberof EngineAgentChannel
   */
  state?: string
}
/**
 *
 * @export
 * @interface EngineAgentInQueue
 */
export interface EngineAgentInQueue {
  /**
   *
   * @type {number}
   * @memberof EngineAgentInQueue
   */
  active_member?: number
  /**
   *
   * @type {number}
   * @memberof EngineAgentInQueue
   */
  count_member?: number
  /**
   *
   * @type {boolean}
   * @memberof EngineAgentInQueue
   */
  enabled?: boolean
  /**
   *
   * @type {number}
   * @memberof EngineAgentInQueue
   */
  priority?: number
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineAgentInQueue
   */
  queue?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineAgentInQueue
   */
  strategy?: string
  /**
   *
   * @type {number}
   * @memberof EngineAgentInQueue
   */
  type?: number
  /**
   *
   * @type {number}
   * @memberof EngineAgentInQueue
   */
  waiting_member?: number
}
/**
 *
 * @export
 * @interface EngineAgentInQueueStatistics
 */
export interface EngineAgentInQueueStatistics {
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineAgentInQueueStatistics
   */
  queue?: EngineLookup
  /**
   *
   * @type {Array<AgentInQueueStatisticsAgentInQueueStatisticsItem>}
   * @memberof EngineAgentInQueueStatistics
   */
  statistics?: Array<AgentInQueueStatisticsAgentInQueueStatisticsItem>
}
/**
 *
 * @export
 * @interface EngineAgentInQueueStatisticsList
 */
export interface EngineAgentInQueueStatisticsList {
  /**
   *
   * @type {Array<EngineAgentInQueueStatistics>}
   * @memberof EngineAgentInQueueStatisticsList
   */
  items?: Array<EngineAgentInQueueStatistics>
}
/**
 *
 * @export
 * @interface EngineAgentInTeam
 */
export interface EngineAgentInTeam {
  /**
   *
   * @type {string}
   * @memberof EngineAgentInTeam
   */
  strategy?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineAgentInTeam
   */
  team?: EngineLookup
}
/**
 *
 * @export
 * @interface EngineAgentSkill
 */
export interface EngineAgentSkill {
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineAgentSkill
   */
  agent?: EngineLookup
  /**
   *
   * @type {number}
   * @memberof EngineAgentSkill
   */
  capacity?: number
  /**
   *
   * @type {string}
   * @memberof EngineAgentSkill
   */
  created_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineAgentSkill
   */
  created_by?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineAgentSkill
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineAgentSkill
   */
  id?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineAgentSkill
   */
  skill?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineAgentSkill
   */
  updated_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineAgentSkill
   */
  updated_by?: EngineLookup
}
/**
 *
 * @export
 * @interface EngineAgentSkillItem
 */
export interface EngineAgentSkillItem {
  /**
   *
   * @type {number}
   * @memberof EngineAgentSkillItem
   */
  capacity?: number
  /**
   *
   * @type {string}
   * @memberof EngineAgentSkillItem
   */
  id?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineAgentSkillItem
   */
  skill?: EngineLookup
}
/**
 *
 * @export
 * @interface EngineAgentState
 */
export interface EngineAgentState {
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineAgentState
   */
  agent?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineAgentState
   */
  channel?: string
  /**
   *
   * @type {string}
   * @memberof EngineAgentState
   */
  duration?: string
  /**
   *
   * @type {string}
   * @memberof EngineAgentState
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineAgentState
   */
  joined_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineAgentState
   */
  payload?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineAgentState
   */
  queue?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineAgentState
   */
  state?: string
}
/**
 *
 * @export
 * @interface EngineAgentStatsStatistic
 */
export interface EngineAgentStatsStatistic {
  /**
   *
   * @type {string}
   * @memberof EngineAgentStatsStatistic
   */
  active_call_id?: string
  /**
   *
   * @type {number}
   * @memberof EngineAgentStatsStatistic
   */
  agent_id?: number
  /**
   *
   * @type {string}
   * @memberof EngineAgentStatsStatistic
   */
  call_time?: string
  /**
   *
   * @type {string}
   * @memberof EngineAgentStatsStatistic
   */
  extension?: string
  /**
   *
   * @type {number}
   * @memberof EngineAgentStatsStatistic
   */
  handles?: number
  /**
   *
   * @type {string}
   * @memberof EngineAgentStatsStatistic
   */
  max_bridged_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineAgentStatsStatistic
   */
  max_offering_at?: string
  /**
   *
   * @type {number}
   * @memberof EngineAgentStatsStatistic
   */
  missed?: number
  /**
   *
   * @type {string}
   * @memberof EngineAgentStatsStatistic
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof EngineAgentStatsStatistic
   */
  offline?: string
  /**
   *
   * @type {string}
   * @memberof EngineAgentStatsStatistic
   */
  online?: string
  /**
   *
   * @type {string}
   * @memberof EngineAgentStatsStatistic
   */
  pause?: string
  /**
   *
   * @type {Array<EngineLookup>}
   * @memberof EngineAgentStatsStatistic
   */
  queues?: Array<EngineLookup>
  /**
   *
   * @type {string}
   * @memberof EngineAgentStatsStatistic
   */
  status?: string
  /**
   *
   * @type {string}
   * @memberof EngineAgentStatsStatistic
   */
  status_duration?: string
  /**
   *
   * @type {Array<EngineLookup>}
   * @memberof EngineAgentStatsStatistic
   */
  teams?: Array<EngineLookup>
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineAgentStatsStatistic
   */
  user?: EngineLookup
  /**
   *
   * @type {number}
   * @memberof EngineAgentStatsStatistic
   */
  utilization?: number
}
/**
 *
 * @export
 * @interface EngineAgentStatusRequest
 */
export interface EngineAgentStatusRequest {
  /**
   *
   * @type {Array<string>}
   * @memberof EngineAgentStatusRequest
   */
  channels?: Array<string>
  /**
   *
   * @type {string}
   * @memberof EngineAgentStatusRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineAgentStatusRequest
   */
  id?: string
  /**
   *
   * @type {boolean}
   * @memberof EngineAgentStatusRequest
   */
  on_demand?: boolean
  /**
   *
   * @type {string}
   * @memberof EngineAgentStatusRequest
   */
  payload?: string
  /**
   *
   * @type {string}
   * @memberof EngineAgentStatusRequest
   */
  status?: string
}
/**
 *
 * @export
 * @interface EngineAgentTeam
 */
export interface EngineAgentTeam {
  /**
   *
   * @type {number}
   * @memberof EngineAgentTeam
   */
  call_timeout?: number
  /**
   *
   * @type {string}
   * @memberof EngineAgentTeam
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineAgentTeam
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineAgentTeam
   */
  id?: string
  /**
   *
   * @type {number}
   * @memberof EngineAgentTeam
   */
  max_no_answer?: number
  /**
   *
   * @type {string}
   * @memberof EngineAgentTeam
   */
  name?: string
  /**
   *
   * @type {number}
   * @memberof EngineAgentTeam
   */
  no_answer_delay_time?: number
  /**
   *
   * @type {boolean}
   * @memberof EngineAgentTeam
   */
  post_processing?: boolean
  /**
   *
   * @type {string}
   * @memberof EngineAgentTeam
   */
  strategy?: string
  /**
   *
   * @type {string}
   * @memberof EngineAgentTeam
   */
  updated_at?: string
  /**
   *
   * @type {number}
   * @memberof EngineAgentTeam
   */
  wrap_up_time?: number
}
/**
 *
 * @export
 * @interface EngineAgentUser
 */
export interface EngineAgentUser {
  /**
   *
   * @type {string}
   * @memberof EngineAgentUser
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineAgentUser
   */
  name?: string
}
/**
 *
 * @export
 * @interface EngineAttempt
 */
export interface EngineAttempt {
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineAttempt
   */
  agent?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineAttempt
   */
  agent_call_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineAttempt
   */
  bridged_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineAttempt
   */
  bucket?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineAttempt
   */
  channel?: string
  /**
   *
   * @type {EngineMemberCommunication}
   * @memberof EngineAttempt
   */
  destination?: EngineMemberCommunication
  /**
   *
   * @type {string}
   * @memberof EngineAttempt
   */
  display?: string
  /**
   *
   * @type {string}
   * @memberof EngineAttempt
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineAttempt
   */
  joined_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineAttempt
   */
  last_state_change?: string
  /**
   *
   * @type {string}
   * @memberof EngineAttempt
   */
  leaving_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineAttempt
   */
  list?: EngineLookup
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineAttempt
   */
  member?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineAttempt
   */
  member_call_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineAttempt
   */
  offering_at?: string
  /**
   *
   * @type {number}
   * @memberof EngineAttempt
   */
  position?: number
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineAttempt
   */
  queue?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineAttempt
   */
  reporting_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineAttempt
   */
  resource?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineAttempt
   */
  result?: string
  /**
   *
   * @type {string}
   * @memberof EngineAttempt
   */
  state?: string
  /**
   *
   * @type {string}
   * @memberof EngineAttempt
   */
  timeout?: string
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof EngineAttempt
   */
  variables?: { [key: string]: string }
}
/**
 *
 * @export
 * @interface EngineAttemptCallbackRequest
 */
export interface EngineAttemptCallbackRequest {
  /**
   *
   * @type {string}
   * @memberof EngineAttemptCallbackRequest
   */
  attempt_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineAttemptCallbackRequest
   */
  description?: string
  /**
   *
   * @type {boolean}
   * @memberof EngineAttemptCallbackRequest
   */
  display?: boolean
  /**
   *
   * @type {string}
   * @memberof EngineAttemptCallbackRequest
   */
  expire_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineAttemptCallbackRequest
   */
  min_offering_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineAttemptCallbackRequest
   */
  status?: string
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof EngineAttemptCallbackRequest
   */
  variables?: { [key: string]: string }
}
/**
 *
 * @export
 * @interface EngineAttemptHistory
 */
export interface EngineAttemptHistory {
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineAttemptHistory
   */
  agent?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineAttemptHistory
   */
  agent_call_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineAttemptHistory
   */
  bridged_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineAttemptHistory
   */
  bucket?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineAttemptHistory
   */
  channel?: string
  /**
   *
   * @type {EngineMemberCommunication}
   * @memberof EngineAttemptHistory
   */
  destination?: EngineMemberCommunication
  /**
   *
   * @type {string}
   * @memberof EngineAttemptHistory
   */
  display?: string
  /**
   *
   * @type {string}
   * @memberof EngineAttemptHistory
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineAttemptHistory
   */
  joined_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineAttemptHistory
   */
  leaving_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineAttemptHistory
   */
  list?: EngineLookup
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineAttemptHistory
   */
  member?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineAttemptHistory
   */
  member_call_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineAttemptHistory
   */
  offering_at?: string
  /**
   *
   * @type {number}
   * @memberof EngineAttemptHistory
   */
  position?: number
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineAttemptHistory
   */
  queue?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineAttemptHistory
   */
  reporting_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineAttemptHistory
   */
  resource?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineAttemptHistory
   */
  result?: string
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof EngineAttemptHistory
   */
  variables?: { [key: string]: string }
}
/**
 *
 * @export
 * @interface EngineAttemptResultRequest
 */
export interface EngineAttemptResultRequest {
  /**
   *
   * @type {string}
   * @memberof EngineAttemptResultRequest
   */
  attempt_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineAttemptResultRequest
   */
  description?: string
  /**
   *
   * @type {boolean}
   * @memberof EngineAttemptResultRequest
   */
  display?: boolean
  /**
   *
   * @type {string}
   * @memberof EngineAttemptResultRequest
   */
  expire_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineAttemptResultRequest
   */
  member_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineAttemptResultRequest
   */
  min_offering_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineAttemptResultRequest
   */
  next_member_id?: string
  /**
   *
   * @type {number}
   * @memberof EngineAttemptResultRequest
   */
  queue_id?: number
  /**
   *
   * @type {string}
   * @memberof EngineAttemptResultRequest
   */
  status?: string
  /**
   *
   * @type {string}
   * @memberof EngineAttemptResultRequest
   */
  transfer_queue_id?: string
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof EngineAttemptResultRequest
   */
  variables?: { [key: string]: string }
}
/**
 *
 * @export
 * @interface EngineAttemptResultResponse
 */
export interface EngineAttemptResultResponse {
  /**
   *
   * @type {string}
   * @memberof EngineAttemptResultResponse
   */
  status?: string
}
/**
 *
 * @export
 * @interface EngineBlindTransferCallRequest
 */
export interface EngineBlindTransferCallRequest {
  /**
   *
   * @type {string}
   * @memberof EngineBlindTransferCallRequest
   */
  app_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineBlindTransferCallRequest
   */
  destination?: string
  /**
   *
   * @type {string}
   * @memberof EngineBlindTransferCallRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineBlindTransferCallRequest
   */
  id?: string
}
/**
 *
 * @export
 * @interface EngineBucket
 */
export interface EngineBucket {
  /**
   *
   * @type {string}
   * @memberof EngineBucket
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineBucket
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineBucket
   */
  name?: string
}
/**
 *
 * @export
 * @interface EngineCalendar
 */
export interface EngineCalendar {
  /**
   *
   * @type {Array<EngineAcceptOfDay>}
   * @memberof EngineCalendar
   */
  accepts?: Array<EngineAcceptOfDay>
  /**
   *
   * @type {string}
   * @memberof EngineCalendar
   */
  created_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineCalendar
   */
  created_by?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineCalendar
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineCalendar
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineCalendar
   */
  end_at?: string
  /**
   *
   * @type {Array<EngineExceptDate>}
   * @memberof EngineCalendar
   */
  excepts?: Array<EngineExceptDate>
  /**
   *
   * @type {string}
   * @memberof EngineCalendar
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineCalendar
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof EngineCalendar
   */
  start_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineCalendar
   */
  timezone?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineCalendar
   */
  updated_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineCalendar
   */
  updated_by?: EngineLookup
}
/**
 *
 * @export
 * @interface EngineCallFile
 */
export interface EngineCallFile {
  /**
   *
   * @type {string}
   * @memberof EngineCallFile
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineCallFile
   */
  mime_type?: string
  /**
   *
   * @type {string}
   * @memberof EngineCallFile
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof EngineCallFile
   */
  size?: string
}
/**
 *
 * @export
 * @interface EngineCommunicationType
 */
export interface EngineCommunicationType {
  /**
   *
   * @type {string}
   * @memberof EngineCommunicationType
   */
  code?: string
  /**
   *
   * @type {string}
   * @memberof EngineCommunicationType
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineCommunicationType
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineCommunicationType
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineCommunicationType
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof EngineCommunicationType
   */
  type?: string
}
/**
 *
 * @export
 * @interface EngineCommunicationTypeRequest
 */
export interface EngineCommunicationTypeRequest {
  /**
   *
   * @type {string}
   * @memberof EngineCommunicationTypeRequest
   */
  code?: string
  /**
   *
   * @type {string}
   * @memberof EngineCommunicationTypeRequest
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineCommunicationTypeRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineCommunicationTypeRequest
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof EngineCommunicationTypeRequest
   */
  type?: string
}
/**
 *
 * @export
 * @interface EngineCreateAgentRequest
 */
export interface EngineCreateAgentRequest {
  /**
   *
   * @type {string}
   * @memberof EngineCreateAgentRequest
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateAgentRequest
   */
  domain_id?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineCreateAgentRequest
   */
  greeting_media?: EngineLookup
  /**
   *
   * @type {number}
   * @memberof EngineCreateAgentRequest
   */
  progressive_count?: number
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineCreateAgentRequest
   */
  user?: EngineLookup
}
/**
 *
 * @export
 * @interface EngineCreateAgentSkillRequest
 */
export interface EngineCreateAgentSkillRequest {
  /**
   *
   * @type {string}
   * @memberof EngineCreateAgentSkillRequest
   */
  agent_id?: string
  /**
   *
   * @type {number}
   * @memberof EngineCreateAgentSkillRequest
   */
  capacity?: number
  /**
   *
   * @type {string}
   * @memberof EngineCreateAgentSkillRequest
   */
  domain_id?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineCreateAgentSkillRequest
   */
  skill?: EngineLookup
}
/**
 *
 * @export
 * @interface EngineCreateAgentTeamRequest
 */
export interface EngineCreateAgentTeamRequest {
  /**
   *
   * @type {number}
   * @memberof EngineCreateAgentTeamRequest
   */
  call_timeout?: number
  /**
   *
   * @type {string}
   * @memberof EngineCreateAgentTeamRequest
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateAgentTeamRequest
   */
  domain_id?: string
  /**
   *
   * @type {number}
   * @memberof EngineCreateAgentTeamRequest
   */
  max_no_answer?: number
  /**
   *
   * @type {string}
   * @memberof EngineCreateAgentTeamRequest
   */
  name?: string
  /**
   *
   * @type {number}
   * @memberof EngineCreateAgentTeamRequest
   */
  no_answer_delay_time?: number
  /**
   *
   * @type {boolean}
   * @memberof EngineCreateAgentTeamRequest
   */
  post_processing?: boolean
  /**
   *
   * @type {string}
   * @memberof EngineCreateAgentTeamRequest
   */
  strategy?: string
  /**
   *
   * @type {number}
   * @memberof EngineCreateAgentTeamRequest
   */
  wrap_up_time?: number
}
/**
 *
 * @export
 * @interface EngineCreateAttemptRequest
 */
export interface EngineCreateAttemptRequest {
  /**
   *
   * @type {string}
   * @memberof EngineCreateAttemptRequest
   */
  agent_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateAttemptRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateAttemptRequest
   */
  member_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateAttemptRequest
   */
  queue_id?: string
}
/**
 *
 * @export
 * @interface EngineCreateAttemptResponse
 */
export interface EngineCreateAttemptResponse {
  /**
   *
   * @type {string}
   * @memberof EngineCreateAttemptResponse
   */
  attempt_id?: string
}
/**
 *
 * @export
 * @interface EngineCreateBucketRequest
 */
export interface EngineCreateBucketRequest {
  /**
   *
   * @type {string}
   * @memberof EngineCreateBucketRequest
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateBucketRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateBucketRequest
   */
  name?: string
}
/**
 *
 * @export
 * @interface EngineCreateCalendarRequest
 */
export interface EngineCreateCalendarRequest {
  /**
   *
   * @type {Array<EngineAcceptOfDay>}
   * @memberof EngineCreateCalendarRequest
   */
  accepts?: Array<EngineAcceptOfDay>
  /**
   *
   * @type {string}
   * @memberof EngineCreateCalendarRequest
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateCalendarRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateCalendarRequest
   */
  end_at?: string
  /**
   *
   * @type {Array<EngineExceptDate>}
   * @memberof EngineCreateCalendarRequest
   */
  excepts?: Array<EngineExceptDate>
  /**
   *
   * @type {string}
   * @memberof EngineCreateCalendarRequest
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateCalendarRequest
   */
  start_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineCreateCalendarRequest
   */
  timezone?: EngineLookup
}
/**
 *
 * @export
 * @interface EngineCreateCallRequest
 */
export interface EngineCreateCallRequest {
  /**
   *
   * @type {string}
   * @memberof EngineCreateCallRequest
   */
  destination?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateCallRequest
   */
  domain_id?: string
  /**
   *
   * @type {CreateCallRequestEndpointRequest}
   * @memberof EngineCreateCallRequest
   */
  from?: CreateCallRequestEndpointRequest
  /**
   *
   * @type {CreateCallRequestCallSettings}
   * @memberof EngineCreateCallRequest
   */
  params?: CreateCallRequestCallSettings
  /**
   *
   * @type {CreateCallRequestEndpointRequest}
   * @memberof EngineCreateCallRequest
   */
  to?: CreateCallRequestEndpointRequest
}
/**
 *
 * @export
 * @interface EngineCreateCallResponse
 */
export interface EngineCreateCallResponse {
  /**
   *
   * @type {string}
   * @memberof EngineCreateCallResponse
   */
  id?: string
}
/**
 *
 * @export
 * @interface EngineCreateEmailProfileRequest
 */
export interface EngineCreateEmailProfileRequest {
  /**
   *
   * @type {string}
   * @memberof EngineCreateEmailProfileRequest
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateEmailProfileRequest
   */
  domain_id?: string
  /**
   *
   * @type {boolean}
   * @memberof EngineCreateEmailProfileRequest
   */
  enabled?: boolean
  /**
   *
   * @type {string}
   * @memberof EngineCreateEmailProfileRequest
   */
  host?: string
  /**
   *
   * @type {number}
   * @memberof EngineCreateEmailProfileRequest
   */
  imap_port?: number
  /**
   *
   * @type {string}
   * @memberof EngineCreateEmailProfileRequest
   */
  login?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateEmailProfileRequest
   */
  mailbox?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateEmailProfileRequest
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateEmailProfileRequest
   */
  password?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineCreateEmailProfileRequest
   */
  schema?: EngineLookup
  /**
   *
   * @type {number}
   * @memberof EngineCreateEmailProfileRequest
   */
  smtp_port?: number
}
/**
 *
 * @export
 * @interface EngineCreateListCommunicationRequest
 */
export interface EngineCreateListCommunicationRequest {
  /**
   *
   * @type {string}
   * @memberof EngineCreateListCommunicationRequest
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateListCommunicationRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateListCommunicationRequest
   */
  list_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateListCommunicationRequest
   */
  number?: string
}
/**
 *
 * @export
 * @interface EngineCreateListRequest
 */
export interface EngineCreateListRequest {
  /**
   *
   * @type {string}
   * @memberof EngineCreateListRequest
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateListRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateListRequest
   */
  name?: string
}
/**
 *
 * @export
 * @interface EngineCreateMemberBulkItem
 */
export interface EngineCreateMemberBulkItem {
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineCreateMemberBulkItem
   */
  bucket?: EngineLookup
  /**
   *
   * @type {Array<EngineMemberCommunicationCreateRequest>}
   * @memberof EngineCreateMemberBulkItem
   */
  communications?: Array<EngineMemberCommunicationCreateRequest>
  /**
   *
   * @type {string}
   * @memberof EngineCreateMemberBulkItem
   */
  expire_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateMemberBulkItem
   */
  min_offering_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateMemberBulkItem
   */
  name?: string
  /**
   *
   * @type {number}
   * @memberof EngineCreateMemberBulkItem
   */
  priority?: number
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineCreateMemberBulkItem
   */
  skill?: EngineLookup
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineCreateMemberBulkItem
   */
  timezone?: EngineLookup
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof EngineCreateMemberBulkItem
   */
  variables?: { [key: string]: string }
}
/**
 *
 * @export
 * @interface EngineCreateMemberBulkRequest
 */
export interface EngineCreateMemberBulkRequest {
  /**
   *
   * @type {string}
   * @memberof EngineCreateMemberBulkRequest
   */
  domain_id?: string
  /**
   *
   * @type {Array<EngineCreateMemberBulkItem>}
   * @memberof EngineCreateMemberBulkRequest
   */
  items?: Array<EngineCreateMemberBulkItem>
  /**
   *
   * @type {string}
   * @memberof EngineCreateMemberBulkRequest
   */
  queue_id?: string
}
/**
 *
 * @export
 * @interface EngineCreateMemberRequest
 */
export interface EngineCreateMemberRequest {
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineCreateMemberRequest
   */
  bucket?: EngineLookup
  /**
   *
   * @type {Array<EngineMemberCommunicationCreateRequest>}
   * @memberof EngineCreateMemberRequest
   */
  communications?: Array<EngineMemberCommunicationCreateRequest>
  /**
   *
   * @type {string}
   * @memberof EngineCreateMemberRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateMemberRequest
   */
  expire_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateMemberRequest
   */
  min_offering_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateMemberRequest
   */
  name?: string
  /**
   *
   * @type {number}
   * @memberof EngineCreateMemberRequest
   */
  priority?: number
  /**
   *
   * @type {string}
   * @memberof EngineCreateMemberRequest
   */
  queue_id?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineCreateMemberRequest
   */
  skill?: EngineLookup
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineCreateMemberRequest
   */
  timezone?: EngineLookup
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof EngineCreateMemberRequest
   */
  variables?: { [key: string]: string }
}
/**
 *
 * @export
 * @interface EngineCreateOutboundResourceDisplayRequest
 */
export interface EngineCreateOutboundResourceDisplayRequest {
  /**
   *
   * @type {string}
   * @memberof EngineCreateOutboundResourceDisplayRequest
   */
  display?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateOutboundResourceDisplayRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateOutboundResourceDisplayRequest
   */
  resource_id?: string
}
/**
 *
 * @export
 * @interface EngineCreateOutboundResourceGroupRequest
 */
export interface EngineCreateOutboundResourceGroupRequest {
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineCreateOutboundResourceGroupRequest
   */
  communication?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineCreateOutboundResourceGroupRequest
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateOutboundResourceGroupRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateOutboundResourceGroupRequest
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateOutboundResourceGroupRequest
   */
  strategy?: string
  /**
   *
   * @type {Array<EngineOutboundResourceTimeRange>}
   * @memberof EngineCreateOutboundResourceGroupRequest
   */
  time?: Array<EngineOutboundResourceTimeRange>
}
/**
 *
 * @export
 * @interface EngineCreateOutboundResourceInGroupRequest
 */
export interface EngineCreateOutboundResourceInGroupRequest {
  /**
   *
   * @type {string}
   * @memberof EngineCreateOutboundResourceInGroupRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateOutboundResourceInGroupRequest
   */
  group_id?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineCreateOutboundResourceInGroupRequest
   */
  resource?: EngineLookup
}
/**
 *
 * @export
 * @interface EngineCreateOutboundResourceRequest
 */
export interface EngineCreateOutboundResourceRequest {
  /**
   *
   * @type {string}
   * @memberof EngineCreateOutboundResourceRequest
   */
  domain_id?: string
  /**
   *
   * @type {boolean}
   * @memberof EngineCreateOutboundResourceRequest
   */
  enabled?: boolean
  /**
   *
   * @type {Array<string>}
   * @memberof EngineCreateOutboundResourceRequest
   */
  error_ids?: Array<string>
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineCreateOutboundResourceRequest
   */
  gateway?: EngineLookup
  /**
   *
   * @type {number}
   * @memberof EngineCreateOutboundResourceRequest
   */
  limit?: number
  /**
   *
   * @type {number}
   * @memberof EngineCreateOutboundResourceRequest
   */
  max_successively_errors?: number
  /**
   *
   * @type {string}
   * @memberof EngineCreateOutboundResourceRequest
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateOutboundResourceRequest
   */
  number?: string
  /**
   *
   * @type {boolean}
   * @memberof EngineCreateOutboundResourceRequest
   */
  reserve?: boolean
  /**
   *
   * @type {number}
   * @memberof EngineCreateOutboundResourceRequest
   */
  rps?: number
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof EngineCreateOutboundResourceRequest
   */
  variables?: { [key: string]: string }
}
/**
 *
 * @export
 * @interface EngineCreateQueueBucketRequest
 */
export interface EngineCreateQueueBucketRequest {
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineCreateQueueBucketRequest
   */
  bucket?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineCreateQueueBucketRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateQueueBucketRequest
   */
  queue_id?: string
  /**
   *
   * @type {number}
   * @memberof EngineCreateQueueBucketRequest
   */
  ratio?: number
}
/**
 *
 * @export
 * @interface EngineCreateQueueRequest
 */
export interface EngineCreateQueueRequest {
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineCreateQueueRequest
   */
  calendar?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineCreateQueueRequest
   */
  description?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineCreateQueueRequest
   */
  dnc_list?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineCreateQueueRequest
   */
  domain_id?: string
  /**
   *
   * @type {boolean}
   * @memberof EngineCreateQueueRequest
   */
  enabled?: boolean
  /**
   *
   * @type {string}
   * @memberof EngineCreateQueueRequest
   */
  name?: string
  /**
   *
   * @type {object}
   * @memberof EngineCreateQueueRequest
   */
  payload?: object
  /**
   *
   * @type {number}
   * @memberof EngineCreateQueueRequest
   */
  priority?: number
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineCreateQueueRequest
   */
  ringtone?: EngineLookup
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineCreateQueueRequest
   */
  schema?: EngineLookup
  /**
   *
   * @type {number}
   * @memberof EngineCreateQueueRequest
   */
  sec_locate_agent?: number
  /**
   *
   * @type {string}
   * @memberof EngineCreateQueueRequest
   */
  strategy?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineCreateQueueRequest
   */
  team?: EngineLookup
  /**
   *
   * @type {number}
   * @memberof EngineCreateQueueRequest
   */
  timeout?: number
  /**
   *
   * @type {number}
   * @memberof EngineCreateQueueRequest
   */
  type?: number
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof EngineCreateQueueRequest
   */
  variables?: { [key: string]: string }
}
/**
 *
 * @export
 * @interface EngineCreateQueueResourceGroupRequest
 */
export interface EngineCreateQueueResourceGroupRequest {
  /**
   *
   * @type {string}
   * @memberof EngineCreateQueueResourceGroupRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateQueueResourceGroupRequest
   */
  queue_id?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineCreateQueueResourceGroupRequest
   */
  resource_group?: EngineLookup
}
/**
 *
 * @export
 * @interface EngineCreateQueueRoutingRequest
 */
export interface EngineCreateQueueRoutingRequest {
  /**
   *
   * @type {boolean}
   * @memberof EngineCreateQueueRoutingRequest
   */
  disabled?: boolean
  /**
   *
   * @type {string}
   * @memberof EngineCreateQueueRoutingRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateQueueRoutingRequest
   */
  pattern?: string
  /**
   *
   * @type {number}
   * @memberof EngineCreateQueueRoutingRequest
   */
  priority?: number
  /**
   *
   * @type {string}
   * @memberof EngineCreateQueueRoutingRequest
   */
  queue_id?: string
}
/**
 *
 * @export
 * @interface EngineCreateResourceTeamAgentRequest
 */
export interface EngineCreateResourceTeamAgentRequest {
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineCreateResourceTeamAgentRequest
   */
  agent?: EngineLookup
  /**
   *
   * @type {Array<EngineLookup>}
   * @memberof EngineCreateResourceTeamAgentRequest
   */
  buckets?: Array<EngineLookup>
  /**
   *
   * @type {string}
   * @memberof EngineCreateResourceTeamAgentRequest
   */
  domain_id?: string
  /**
   *
   * @type {number}
   * @memberof EngineCreateResourceTeamAgentRequest
   */
  lvl?: number
  /**
   *
   * @type {string}
   * @memberof EngineCreateResourceTeamAgentRequest
   */
  team_id?: string
}
/**
 *
 * @export
 * @interface EngineCreateResourceTeamSkillRequest
 */
export interface EngineCreateResourceTeamSkillRequest {
  /**
   *
   * @type {Array<EngineLookup>}
   * @memberof EngineCreateResourceTeamSkillRequest
   */
  buckets?: Array<EngineLookup>
  /**
   *
   * @type {string}
   * @memberof EngineCreateResourceTeamSkillRequest
   */
  domain_id?: string
  /**
   *
   * @type {number}
   * @memberof EngineCreateResourceTeamSkillRequest
   */
  lvl?: number
  /**
   *
   * @type {number}
   * @memberof EngineCreateResourceTeamSkillRequest
   */
  max_capacity?: number
  /**
   *
   * @type {number}
   * @memberof EngineCreateResourceTeamSkillRequest
   */
  min_capacity?: number
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineCreateResourceTeamSkillRequest
   */
  skill?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineCreateResourceTeamSkillRequest
   */
  team_id?: string
}
/**
 *
 * @export
 * @interface EngineCreateRoutingOutboundCallRequest
 */
export interface EngineCreateRoutingOutboundCallRequest {
  /**
   *
   * @type {string}
   * @memberof EngineCreateRoutingOutboundCallRequest
   */
  description?: string
  /**
   *
   * @type {boolean}
   * @memberof EngineCreateRoutingOutboundCallRequest
   */
  disabled?: boolean
  /**
   *
   * @type {string}
   * @memberof EngineCreateRoutingOutboundCallRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateRoutingOutboundCallRequest
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateRoutingOutboundCallRequest
   */
  pattern?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineCreateRoutingOutboundCallRequest
   */
  schema?: EngineLookup
}
/**
 *
 * @export
 * @interface EngineCreateRoutingSchemaRequest
 */
export interface EngineCreateRoutingSchemaRequest {
  /**
   *
   * @type {boolean}
   * @memberof EngineCreateRoutingSchemaRequest
   */
  debug?: boolean
  /**
   *
   * @type {string}
   * @memberof EngineCreateRoutingSchemaRequest
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateRoutingSchemaRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateRoutingSchemaRequest
   */
  name?: string
  /**
   *
   * @type {object}
   * @memberof EngineCreateRoutingSchemaRequest
   */
  payload?: object
  /**
   *
   * @type {object}
   * @memberof EngineCreateRoutingSchemaRequest
   */
  schema?: object
  /**
   *
   * @type {number}
   * @memberof EngineCreateRoutingSchemaRequest
   */
  type?: number
}
/**
 *
 * @export
 * @interface EngineCreateRoutingVariableRequest
 */
export interface EngineCreateRoutingVariableRequest {
  /**
   *
   * @type {string}
   * @memberof EngineCreateRoutingVariableRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateRoutingVariableRequest
   */
  key?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateRoutingVariableRequest
   */
  value?: string
}
/**
 *
 * @export
 * @interface EngineCreateSkillRequest
 */
export interface EngineCreateSkillRequest {
  /**
   *
   * @type {string}
   * @memberof EngineCreateSkillRequest
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateSkillRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateSkillRequest
   */
  name?: string
}
/**
 *
 * @export
 * @interface EngineCreateSupervisorInTeamRequest
 */
export interface EngineCreateSupervisorInTeamRequest {
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineCreateSupervisorInTeamRequest
   */
  agent?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineCreateSupervisorInTeamRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineCreateSupervisorInTeamRequest
   */
  team_id?: string
}
/**
 *
 * @export
 * @interface EngineDeleteMembersRequest
 */
export interface EngineDeleteMembersRequest {
  /**
   *
   * @type {string}
   * @memberof EngineDeleteMembersRequest
   */
  domain_id?: string
  /**
   *
   * @type {Array<string>}
   * @memberof EngineDeleteMembersRequest
   */
  ids?: Array<string>
  /**
   *
   * @type {string}
   * @memberof EngineDeleteMembersRequest
   */
  queue_id?: string
}
/**
 *
 * @export
 * @interface EngineDtmfCallRequest
 */
export interface EngineDtmfCallRequest {
  /**
   *
   * @type {string}
   * @memberof EngineDtmfCallRequest
   */
  app_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineDtmfCallRequest
   */
  digit?: string
  /**
   *
   * @type {string}
   * @memberof EngineDtmfCallRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineDtmfCallRequest
   */
  id?: string
}
/**
 *
 * @export
 * @interface EngineEavesdropCallRequest
 */
export interface EngineEavesdropCallRequest {
  /**
   *
   * @type {string}
   * @memberof EngineEavesdropCallRequest
   */
  app_id?: string
  /**
   *
   * @type {boolean}
   * @memberof EngineEavesdropCallRequest
   */
  control?: boolean
  /**
   *
   * @type {string}
   * @memberof EngineEavesdropCallRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineEavesdropCallRequest
   */
  id?: string
  /**
   *
   * @type {boolean}
   * @memberof EngineEavesdropCallRequest
   */
  listen_a?: boolean
  /**
   *
   * @type {boolean}
   * @memberof EngineEavesdropCallRequest
   */
  listen_b?: boolean
  /**
   *
   * @type {boolean}
   * @memberof EngineEavesdropCallRequest
   */
  whisper_a?: boolean
  /**
   *
   * @type {boolean}
   * @memberof EngineEavesdropCallRequest
   */
  whisper_b?: boolean
}
/**
 *
 * @export
 * @interface EngineEmailProfile
 */
export interface EngineEmailProfile {
  /**
   *
   * @type {string}
   * @memberof EngineEmailProfile
   */
  created_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineEmailProfile
   */
  created_by?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineEmailProfile
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineEmailProfile
   */
  domain_id?: string
  /**
   *
   * @type {boolean}
   * @memberof EngineEmailProfile
   */
  enabled?: boolean
  /**
   *
   * @type {string}
   * @memberof EngineEmailProfile
   */
  host?: string
  /**
   *
   * @type {string}
   * @memberof EngineEmailProfile
   */
  id?: string
  /**
   *
   * @type {number}
   * @memberof EngineEmailProfile
   */
  imap_port?: number
  /**
   *
   * @type {string}
   * @memberof EngineEmailProfile
   */
  login?: string
  /**
   *
   * @type {string}
   * @memberof EngineEmailProfile
   */
  mailbox?: string
  /**
   *
   * @type {string}
   * @memberof EngineEmailProfile
   */
  name?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineEmailProfile
   */
  schema?: EngineLookup
  /**
   *
   * @type {number}
   * @memberof EngineEmailProfile
   */
  smtp_port?: number
  /**
   *
   * @type {string}
   * @memberof EngineEmailProfile
   */
  updated_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineEmailProfile
   */
  updated_by?: EngineLookup
}
/**
 *
 * @export
 * @interface EngineEndpoint
 */
export interface EngineEndpoint {
  /**
   *
   * @type {string}
   * @memberof EngineEndpoint
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineEndpoint
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof EngineEndpoint
   */
  number?: string
  /**
   *
   * @type {string}
   * @memberof EngineEndpoint
   */
  type?: string
}
/**
 *
 * @export
 * @interface EngineExceptDate
 */
export interface EngineExceptDate {
  /**
   *
   * @type {string}
   * @memberof EngineExceptDate
   */
  date?: string
  /**
   *
   * @type {boolean}
   * @memberof EngineExceptDate
   */
  disabled?: boolean
  /**
   *
   * @type {string}
   * @memberof EngineExceptDate
   */
  name?: string
  /**
   *
   * @type {boolean}
   * @memberof EngineExceptDate
   */
  repeat?: boolean
}
/**
 *
 * @export
 * @interface EngineFilterBetween
 */
export interface EngineFilterBetween {
  /**
   *
   * @type {string}
   * @memberof EngineFilterBetween
   */
  from?: string
  /**
   *
   * @type {string}
   * @memberof EngineFilterBetween
   */
  to?: string
}
/**
 *
 * @export
 * @interface EngineHangupCallRequest
 */
export interface EngineHangupCallRequest {
  /**
   *
   * @type {string}
   * @memberof EngineHangupCallRequest
   */
  app_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineHangupCallRequest
   */
  cause?: string
  /**
   *
   * @type {string}
   * @memberof EngineHangupCallRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineHangupCallRequest
   */
  id?: string
}
/**
 *
 * @export
 * @interface EngineHistoryCall
 */
export interface EngineHistoryCall {
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineHistoryCall
   */
  agent?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineHistoryCall
   */
  answered_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineHistoryCall
   */
  app_id?: string
  /**
   *
   * @type {number}
   * @memberof EngineHistoryCall
   */
  bill_sec?: number
  /**
   *
   * @type {string}
   * @memberof EngineHistoryCall
   */
  bridged_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineHistoryCall
   */
  cause?: string
  /**
   *
   * @type {string}
   * @memberof EngineHistoryCall
   */
  created_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineHistoryCall
   */
  destination?: string
  /**
   *
   * @type {string}
   * @memberof EngineHistoryCall
   */
  direction?: string
  /**
   *
   * @type {string}
   * @memberof EngineHistoryCall
   */
  display?: string
  /**
   *
   * @type {number}
   * @memberof EngineHistoryCall
   */
  duration?: number
  /**
   *
   * @type {string}
   * @memberof EngineHistoryCall
   */
  extension?: string
  /**
   *
   * @type {Array<EngineCallFile>}
   * @memberof EngineHistoryCall
   */
  files?: Array<EngineCallFile>
  /**
   *
   * @type {EngineEndpoint}
   * @memberof EngineHistoryCall
   */
  from?: EngineEndpoint
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineHistoryCall
   */
  gateway?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineHistoryCall
   */
  hangup_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineHistoryCall
   */
  hangup_by?: string
  /**
   *
   * @type {boolean}
   * @memberof EngineHistoryCall
   */
  has_children?: boolean
  /**
   *
   * @type {number}
   * @memberof EngineHistoryCall
   */
  hold_sec?: number
  /**
   *
   * @type {string}
   * @memberof EngineHistoryCall
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineHistoryCall
   */
  joined_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineHistoryCall
   */
  leaving_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineHistoryCall
   */
  member?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineHistoryCall
   */
  parent_id?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineHistoryCall
   */
  queue?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineHistoryCall
   */
  queue_bridged_at?: string
  /**
   *
   * @type {number}
   * @memberof EngineHistoryCall
   */
  queue_duration_sec?: number
  /**
   *
   * @type {number}
   * @memberof EngineHistoryCall
   */
  queue_wait_sec?: number
  /**
   *
   * @type {string}
   * @memberof EngineHistoryCall
   */
  reporting_at?: string
  /**
   *
   * @type {number}
   * @memberof EngineHistoryCall
   */
  reporting_sec?: number
  /**
   *
   * @type {string}
   * @memberof EngineHistoryCall
   */
  result?: string
  /**
   *
   * @type {number}
   * @memberof EngineHistoryCall
   */
  sip_code?: number
  /**
   *
   * @type {string}
   * @memberof EngineHistoryCall
   */
  stored_at?: string
  /**
   *
   * @type {Array<string>}
   * @memberof EngineHistoryCall
   */
  tags?: Array<string>
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineHistoryCall
   */
  team?: EngineLookup
  /**
   *
   * @type {EngineEndpoint}
   * @memberof EngineHistoryCall
   */
  to?: EngineEndpoint
  /**
   *
   * @type {string}
   * @memberof EngineHistoryCall
   */
  transfer_from?: string
  /**
   *
   * @type {string}
   * @memberof EngineHistoryCall
   */
  transfer_to?: string
  /**
   *
   * @type {string}
   * @memberof EngineHistoryCall
   */
  type?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineHistoryCall
   */
  user?: EngineLookup
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof EngineHistoryCall
   */
  variables?: { [key: string]: string }
  /**
   *
   * @type {number}
   * @memberof EngineHistoryCall
   */
  wait_sec?: number
}
/**
 *
 * @export
 * @interface EngineHoldCallResponse
 */
export interface EngineHoldCallResponse {
  /**
   *
   * @type {string}
   * @memberof EngineHoldCallResponse
   */
  state?: string
}
/**
 *
 * @export
 * @interface EngineList
 */
export interface EngineList {
  /**
   *
   * @type {string}
   * @memberof EngineList
   */
  count?: string
  /**
   *
   * @type {string}
   * @memberof EngineList
   */
  created_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineList
   */
  created_by?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineList
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineList
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineList
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineList
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof EngineList
   */
  updated_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineList
   */
  updated_by?: EngineLookup
}
/**
 *
 * @export
 * @interface EngineListAgent
 */
export interface EngineListAgent {
  /**
   *
   * @type {Array<EngineAgent>}
   * @memberof EngineListAgent
   */
  items?: Array<EngineAgent>
  /**
   *
   * @type {boolean}
   * @memberof EngineListAgent
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListAgentInQueue
 */
export interface EngineListAgentInQueue {
  /**
   *
   * @type {Array<EngineAgentInQueue>}
   * @memberof EngineListAgentInQueue
   */
  items?: Array<EngineAgentInQueue>
  /**
   *
   * @type {boolean}
   * @memberof EngineListAgentInQueue
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListAgentInTeam
 */
export interface EngineListAgentInTeam {
  /**
   *
   * @type {Array<EngineAgentInTeam>}
   * @memberof EngineListAgentInTeam
   */
  items?: Array<EngineAgentInTeam>
  /**
   *
   * @type {boolean}
   * @memberof EngineListAgentInTeam
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListAgentSkill
 */
export interface EngineListAgentSkill {
  /**
   *
   * @type {Array<EngineAgentSkillItem>}
   * @memberof EngineListAgentSkill
   */
  items?: Array<EngineAgentSkillItem>
  /**
   *
   * @type {boolean}
   * @memberof EngineListAgentSkill
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListAgentStateHistory
 */
export interface EngineListAgentStateHistory {
  /**
   *
   * @type {Array<EngineAgentState>}
   * @memberof EngineListAgentStateHistory
   */
  items?: Array<EngineAgentState>
  /**
   *
   * @type {boolean}
   * @memberof EngineListAgentStateHistory
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListAgentStatsStatistic
 */
export interface EngineListAgentStatsStatistic {
  /**
   *
   * @type {Array<EngineAgentStatsStatistic>}
   * @memberof EngineListAgentStatsStatistic
   */
  items?: Array<EngineAgentStatsStatistic>
  /**
   *
   * @type {boolean}
   * @memberof EngineListAgentStatsStatistic
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListAgentTeam
 */
export interface EngineListAgentTeam {
  /**
   *
   * @type {Array<EngineAgentTeam>}
   * @memberof EngineListAgentTeam
   */
  items?: Array<EngineAgentTeam>
  /**
   *
   * @type {boolean}
   * @memberof EngineListAgentTeam
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListAgentUser
 */
export interface EngineListAgentUser {
  /**
   *
   * @type {Array<EngineAgentUser>}
   * @memberof EngineListAgentUser
   */
  items?: Array<EngineAgentUser>
  /**
   *
   * @type {boolean}
   * @memberof EngineListAgentUser
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListAttempt
 */
export interface EngineListAttempt {
  /**
   *
   * @type {Array<EngineAttempt>}
   * @memberof EngineListAttempt
   */
  items?: Array<EngineAttempt>
  /**
   *
   * @type {boolean}
   * @memberof EngineListAttempt
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListBucket
 */
export interface EngineListBucket {
  /**
   *
   * @type {Array<EngineBucket>}
   * @memberof EngineListBucket
   */
  items?: Array<EngineBucket>
  /**
   *
   * @type {boolean}
   * @memberof EngineListBucket
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListCalendar
 */
export interface EngineListCalendar {
  /**
   *
   * @type {Array<EngineCalendar>}
   * @memberof EngineListCalendar
   */
  items?: Array<EngineCalendar>
  /**
   *
   * @type {boolean}
   * @memberof EngineListCalendar
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListCall
 */
export interface EngineListCall {
  /**
   *
   * @type {Array<EngineActiveCall>}
   * @memberof EngineListCall
   */
  items?: Array<EngineActiveCall>
  /**
   *
   * @type {boolean}
   * @memberof EngineListCall
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListCommunication
 */
export interface EngineListCommunication {
  /**
   *
   * @type {string}
   * @memberof EngineListCommunication
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineListCommunication
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineListCommunication
   */
  list_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineListCommunication
   */
  number?: string
}
/**
 *
 * @export
 * @interface EngineListCommunicationType
 */
export interface EngineListCommunicationType {
  /**
   *
   * @type {Array<EngineCommunicationType>}
   * @memberof EngineListCommunicationType
   */
  items?: Array<EngineCommunicationType>
  /**
   *
   * @type {boolean}
   * @memberof EngineListCommunicationType
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListEmailProfile
 */
export interface EngineListEmailProfile {
  /**
   *
   * @type {Array<EngineEmailProfile>}
   * @memberof EngineListEmailProfile
   */
  items?: Array<EngineEmailProfile>
  /**
   *
   * @type {boolean}
   * @memberof EngineListEmailProfile
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListHistoryAttempt
 */
export interface EngineListHistoryAttempt {
  /**
   *
   * @type {Array<EngineAttemptHistory>}
   * @memberof EngineListHistoryAttempt
   */
  items?: Array<EngineAttemptHistory>
  /**
   *
   * @type {boolean}
   * @memberof EngineListHistoryAttempt
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListHistoryCall
 */
export interface EngineListHistoryCall {
  /**
   *
   * @type {Array<EngineHistoryCall>}
   * @memberof EngineListHistoryCall
   */
  items?: Array<EngineHistoryCall>
  /**
   *
   * @type {boolean}
   * @memberof EngineListHistoryCall
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListMember
 */
export interface EngineListMember {
  /**
   *
   * @type {Array<EngineMemberInQueue>}
   * @memberof EngineListMember
   */
  items?: Array<EngineMemberInQueue>
  /**
   *
   * @type {boolean}
   * @memberof EngineListMember
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListMemberAttempt
 */
export interface EngineListMemberAttempt {
  /**
   *
   * @type {Array<EngineMemberAttempt>}
   * @memberof EngineListMemberAttempt
   */
  items?: Array<EngineMemberAttempt>
  /**
   *
   * @type {boolean}
   * @memberof EngineListMemberAttempt
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListOfList
 */
export interface EngineListOfList {
  /**
   *
   * @type {Array<EngineList>}
   * @memberof EngineListOfList
   */
  items?: Array<EngineList>
  /**
   *
   * @type {boolean}
   * @memberof EngineListOfList
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListOfListCommunication
 */
export interface EngineListOfListCommunication {
  /**
   *
   * @type {Array<EngineListCommunication>}
   * @memberof EngineListOfListCommunication
   */
  items?: Array<EngineListCommunication>
  /**
   *
   * @type {boolean}
   * @memberof EngineListOfListCommunication
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListOutboundResource
 */
export interface EngineListOutboundResource {
  /**
   *
   * @type {Array<EngineOutboundResource>}
   * @memberof EngineListOutboundResource
   */
  items?: Array<EngineOutboundResource>
  /**
   *
   * @type {boolean}
   * @memberof EngineListOutboundResource
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListOutboundResourceDisplay
 */
export interface EngineListOutboundResourceDisplay {
  /**
   *
   * @type {Array<EngineResourceDisplay>}
   * @memberof EngineListOutboundResourceDisplay
   */
  items?: Array<EngineResourceDisplay>
  /**
   *
   * @type {boolean}
   * @memberof EngineListOutboundResourceDisplay
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListOutboundResourceGroup
 */
export interface EngineListOutboundResourceGroup {
  /**
   *
   * @type {Array<EngineOutboundResourceViewGroup>}
   * @memberof EngineListOutboundResourceGroup
   */
  items?: Array<EngineOutboundResourceViewGroup>
  /**
   *
   * @type {boolean}
   * @memberof EngineListOutboundResourceGroup
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListOutboundResourceInGroup
 */
export interface EngineListOutboundResourceInGroup {
  /**
   *
   * @type {Array<EngineOutboundResourceInGroup>}
   * @memberof EngineListOutboundResourceInGroup
   */
  items?: Array<EngineOutboundResourceInGroup>
  /**
   *
   * @type {boolean}
   * @memberof EngineListOutboundResourceInGroup
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListQueue
 */
export interface EngineListQueue {
  /**
   *
   * @type {Array<EngineQueue>}
   * @memberof EngineListQueue
   */
  items?: Array<EngineQueue>
  /**
   *
   * @type {boolean}
   * @memberof EngineListQueue
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListQueueBucket
 */
export interface EngineListQueueBucket {
  /**
   *
   * @type {Array<EngineQueueBucket>}
   * @memberof EngineListQueueBucket
   */
  items?: Array<EngineQueueBucket>
  /**
   *
   * @type {boolean}
   * @memberof EngineListQueueBucket
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListQueueResourceGroup
 */
export interface EngineListQueueResourceGroup {
  /**
   *
   * @type {Array<EngineQueueResourceGroup>}
   * @memberof EngineListQueueResourceGroup
   */
  items?: Array<EngineQueueResourceGroup>
  /**
   *
   * @type {boolean}
   * @memberof EngineListQueueResourceGroup
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListQueueRouting
 */
export interface EngineListQueueRouting {
  /**
   *
   * @type {Array<EngineQueueRouting>}
   * @memberof EngineListQueueRouting
   */
  items?: Array<EngineQueueRouting>
}
/**
 *
 * @export
 * @interface EngineListReportGeneral
 */
export interface EngineListReportGeneral {
  /**
   *
   * @type {Array<EngineQueueReportGeneral>}
   * @memberof EngineListReportGeneral
   */
  items?: Array<EngineQueueReportGeneral>
  /**
   *
   * @type {boolean}
   * @memberof EngineListReportGeneral
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListResourceTeamAgent
 */
export interface EngineListResourceTeamAgent {
  /**
   *
   * @type {Array<EngineResourceTeamAgent>}
   * @memberof EngineListResourceTeamAgent
   */
  items?: Array<EngineResourceTeamAgent>
  /**
   *
   * @type {boolean}
   * @memberof EngineListResourceTeamAgent
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListResourceTeamSkill
 */
export interface EngineListResourceTeamSkill {
  /**
   *
   * @type {Array<EngineResourceTeamSkill>}
   * @memberof EngineListResourceTeamSkill
   */
  items?: Array<EngineResourceTeamSkill>
  /**
   *
   * @type {boolean}
   * @memberof EngineListResourceTeamSkill
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListRoutingOutboundCall
 */
export interface EngineListRoutingOutboundCall {
  /**
   *
   * @type {Array<EngineRoutingOutboundCallCompact>}
   * @memberof EngineListRoutingOutboundCall
   */
  items?: Array<EngineRoutingOutboundCallCompact>
  /**
   *
   * @type {boolean}
   * @memberof EngineListRoutingOutboundCall
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListRoutingSchema
 */
export interface EngineListRoutingSchema {
  /**
   *
   * @type {Array<EngineRoutingSchema>}
   * @memberof EngineListRoutingSchema
   */
  items?: Array<EngineRoutingSchema>
  /**
   *
   * @type {boolean}
   * @memberof EngineListRoutingSchema
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListRoutingVariable
 */
export interface EngineListRoutingVariable {
  /**
   *
   * @type {Array<EngineRoutingVariable>}
   * @memberof EngineListRoutingVariable
   */
  items?: Array<EngineRoutingVariable>
}
/**
 *
 * @export
 * @interface EngineListSkill
 */
export interface EngineListSkill {
  /**
   *
   * @type {Array<EngineSkill>}
   * @memberof EngineListSkill
   */
  items?: Array<EngineSkill>
  /**
   *
   * @type {boolean}
   * @memberof EngineListSkill
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListSupervisorInTeam
 */
export interface EngineListSupervisorInTeam {
  /**
   *
   * @type {Array<EngineSupervisorInTeam>}
   * @memberof EngineListSupervisorInTeam
   */
  items?: Array<EngineSupervisorInTeam>
  /**
   *
   * @type {boolean}
   * @memberof EngineListSupervisorInTeam
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineListTimezoneResponse
 */
export interface EngineListTimezoneResponse {
  /**
   *
   * @type {Array<EngineTimezone>}
   * @memberof EngineListTimezoneResponse
   */
  items?: Array<EngineTimezone>
  /**
   *
   * @type {boolean}
   * @memberof EngineListTimezoneResponse
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface EngineLookup
 */
export interface EngineLookup {
  /**
   *
   * @type {string}
   * @memberof EngineLookup
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineLookup
   */
  name?: string
}
/**
 *
 * @export
 * @interface EngineMemberAttempt
 */
export interface EngineMemberAttempt {
  /**
   *
   * @type {boolean}
   * @memberof EngineMemberAttempt
   */
  active?: boolean
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineMemberAttempt
   */
  agent?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineMemberAttempt
   */
  answered_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineMemberAttempt
   */
  bridged_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineMemberAttempt
   */
  bucket?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineMemberAttempt
   */
  created_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineMemberAttempt
   */
  destination?: string
  /**
   *
   * @type {string}
   * @memberof EngineMemberAttempt
   */
  hangup_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineMemberAttempt
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineMemberAttempt
   */
  leg_a_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineMemberAttempt
   */
  leg_b_id?: string
  /**
   *
   * @type {object}
   * @memberof EngineMemberAttempt
   */
  logs?: object
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineMemberAttempt
   */
  member?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineMemberAttempt
   */
  node?: string
  /**
   *
   * @type {string}
   * @memberof EngineMemberAttempt
   */
  originate_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineMemberAttempt
   */
  resource?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineMemberAttempt
   */
  result?: string
  /**
   *
   * @type {number}
   * @memberof EngineMemberAttempt
   */
  weight?: number
}
/**
 *
 * @export
 * @interface EngineMemberBulkResponse
 */
export interface EngineMemberBulkResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof EngineMemberBulkResponse
   */
  ids?: Array<string>
}
/**
 *
 * @export
 * @interface EngineMemberCommunication
 */
export interface EngineMemberCommunication {
  /**
   *
   * @type {number}
   * @memberof EngineMemberCommunication
   */
  attempts?: number
  /**
   *
   * @type {string}
   * @memberof EngineMemberCommunication
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineMemberCommunication
   */
  destination?: string
  /**
   *
   * @type {string}
   * @memberof EngineMemberCommunication
   */
  display?: string
  /**
   *
   * @type {string}
   * @memberof EngineMemberCommunication
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineMemberCommunication
   */
  last_activity_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineMemberCommunication
   */
  last_cause?: string
  /**
   *
   * @type {number}
   * @memberof EngineMemberCommunication
   */
  priority?: number
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineMemberCommunication
   */
  resource?: EngineLookup
  /**
   *
   * @type {number}
   * @memberof EngineMemberCommunication
   */
  state?: number
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineMemberCommunication
   */
  type?: EngineLookup
}
/**
 *
 * @export
 * @interface EngineMemberCommunicationCreateRequest
 */
export interface EngineMemberCommunicationCreateRequest {
  /**
   *
   * @type {string}
   * @memberof EngineMemberCommunicationCreateRequest
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineMemberCommunicationCreateRequest
   */
  destination?: string
  /**
   *
   * @type {string}
   * @memberof EngineMemberCommunicationCreateRequest
   */
  display?: string
  /**
   *
   * @type {number}
   * @memberof EngineMemberCommunicationCreateRequest
   */
  priority?: number
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineMemberCommunicationCreateRequest
   */
  resource?: EngineLookup
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineMemberCommunicationCreateRequest
   */
  type?: EngineLookup
}
/**
 *
 * @export
 * @interface EngineMemberInQueue
 */
export interface EngineMemberInQueue {
  /**
   *
   * @type {number}
   * @memberof EngineMemberInQueue
   */
  attempts?: number
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineMemberInQueue
   */
  bucket?: EngineLookup
  /**
   *
   * @type {Array<EngineMemberCommunication>}
   * @memberof EngineMemberInQueue
   */
  communications?: Array<EngineMemberCommunication>
  /**
   *
   * @type {string}
   * @memberof EngineMemberInQueue
   */
  created_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineMemberInQueue
   */
  expire_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineMemberInQueue
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineMemberInQueue
   */
  last_activity_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineMemberInQueue
   */
  min_offering_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineMemberInQueue
   */
  name?: string
  /**
   *
   * @type {number}
   * @memberof EngineMemberInQueue
   */
  priority?: number
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineMemberInQueue
   */
  queue?: EngineLookup
  /**
   *
   * @type {boolean}
   * @memberof EngineMemberInQueue
   */
  reserved?: boolean
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineMemberInQueue
   */
  skill?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineMemberInQueue
   */
  stop_cause?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineMemberInQueue
   */
  timezone?: EngineLookup
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof EngineMemberInQueue
   */
  variables?: { [key: string]: string }
}
/**
 *
 * @export
 * @interface EngineMovePositionRoutingOutboundCallRequest
 */
export interface EngineMovePositionRoutingOutboundCallRequest {
  /**
   *
   * @type {string}
   * @memberof EngineMovePositionRoutingOutboundCallRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineMovePositionRoutingOutboundCallRequest
   */
  from_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineMovePositionRoutingOutboundCallRequest
   */
  to_id?: string
}
/**
 *
 * @export
 * @interface EngineMovePositionRoutingOutboundCallResponse
 */
export interface EngineMovePositionRoutingOutboundCallResponse {
  /**
   *
   * @type {boolean}
   * @memberof EngineMovePositionRoutingOutboundCallResponse
   */
  success?: boolean
}
/**
 *
 * @export
 * @interface EngineOutboundResource
 */
export interface EngineOutboundResource {
  /**
   *
   * @type {string}
   * @memberof EngineOutboundResource
   */
  created_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineOutboundResource
   */
  created_by?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineOutboundResource
   */
  domain_id?: string
  /**
   *
   * @type {boolean}
   * @memberof EngineOutboundResource
   */
  enabled?: boolean
  /**
   *
   * @type {Array<string>}
   * @memberof EngineOutboundResource
   */
  error_ids?: Array<string>
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineOutboundResource
   */
  gateway?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineOutboundResource
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineOutboundResource
   */
  last_error_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineOutboundResource
   */
  last_error_id?: string
  /**
   *
   * @type {number}
   * @memberof EngineOutboundResource
   */
  limit?: number
  /**
   *
   * @type {number}
   * @memberof EngineOutboundResource
   */
  max_successively_errors?: number
  /**
   *
   * @type {string}
   * @memberof EngineOutboundResource
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof EngineOutboundResource
   */
  number?: string
  /**
   *
   * @type {boolean}
   * @memberof EngineOutboundResource
   */
  reserve?: boolean
  /**
   *
   * @type {number}
   * @memberof EngineOutboundResource
   */
  rps?: number
  /**
   *
   * @type {number}
   * @memberof EngineOutboundResource
   */
  successively_errors?: number
  /**
   *
   * @type {string}
   * @memberof EngineOutboundResource
   */
  updated_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineOutboundResource
   */
  updated_by?: EngineLookup
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof EngineOutboundResource
   */
  variables?: { [key: string]: string }
}
/**
 *
 * @export
 * @interface EngineOutboundResourceGroup
 */
export interface EngineOutboundResourceGroup {
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineOutboundResourceGroup
   */
  communication?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineOutboundResourceGroup
   */
  created_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineOutboundResourceGroup
   */
  created_by?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineOutboundResourceGroup
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineOutboundResourceGroup
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineOutboundResourceGroup
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineOutboundResourceGroup
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof EngineOutboundResourceGroup
   */
  strategy?: string
  /**
   *
   * @type {Array<EngineOutboundResourceTimeRange>}
   * @memberof EngineOutboundResourceGroup
   */
  time?: Array<EngineOutboundResourceTimeRange>
  /**
   *
   * @type {string}
   * @memberof EngineOutboundResourceGroup
   */
  updated_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineOutboundResourceGroup
   */
  updated_by?: EngineLookup
}
/**
 *
 * @export
 * @interface EngineOutboundResourceInGroup
 */
export interface EngineOutboundResourceInGroup {
  /**
   *
   * @type {string}
   * @memberof EngineOutboundResourceInGroup
   */
  group_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineOutboundResourceInGroup
   */
  id?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineOutboundResourceInGroup
   */
  resource?: EngineLookup
}
/**
 *
 * @export
 * @interface EngineOutboundResourceTimeRange
 */
export interface EngineOutboundResourceTimeRange {
  /**
   *
   * @type {number}
   * @memberof EngineOutboundResourceTimeRange
   */
  end_time_of_day?: number
  /**
   *
   * @type {number}
   * @memberof EngineOutboundResourceTimeRange
   */
  start_time_of_day?: number
}
/**
 *
 * @export
 * @interface EngineOutboundResourceViewGroup
 */
export interface EngineOutboundResourceViewGroup {
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineOutboundResourceViewGroup
   */
  communication?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineOutboundResourceViewGroup
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineOutboundResourceViewGroup
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineOutboundResourceViewGroup
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof EngineOutboundResourceViewGroup
   */
  strategy?: string
}
/**
 *
 * @export
 * @interface EnginePatchMemberRequest
 */
export interface EnginePatchMemberRequest {
  /**
   *
   * @type {EngineLookup}
   * @memberof EnginePatchMemberRequest
   */
  bucket?: EngineLookup
  /**
   *
   * @type {Array<EngineMemberCommunicationCreateRequest>}
   * @memberof EnginePatchMemberRequest
   */
  communications?: Array<EngineMemberCommunicationCreateRequest>
  /**
   *
   * @type {string}
   * @memberof EnginePatchMemberRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EnginePatchMemberRequest
   */
  expire_at?: string
  /**
   *
   * @type {Array<string>}
   * @memberof EnginePatchMemberRequest
   */
  fields?: Array<string>
  /**
   *
   * @type {string}
   * @memberof EnginePatchMemberRequest
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EnginePatchMemberRequest
   */
  min_offering_at?: string
  /**
   *
   * @type {string}
   * @memberof EnginePatchMemberRequest
   */
  name?: string
  /**
   *
   * @type {number}
   * @memberof EnginePatchMemberRequest
   */
  priority?: number
  /**
   *
   * @type {string}
   * @memberof EnginePatchMemberRequest
   */
  queue_id?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EnginePatchMemberRequest
   */
  skill?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EnginePatchMemberRequest
   */
  stop_cause?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EnginePatchMemberRequest
   */
  timezone?: EngineLookup
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof EnginePatchMemberRequest
   */
  variables?: { [key: string]: string }
}
/**
 *
 * @export
 * @interface EnginePatchOutboundResourceRequest
 */
export interface EnginePatchOutboundResourceRequest {
  /**
   *
   * @type {string}
   * @memberof EnginePatchOutboundResourceRequest
   */
  domain_id?: string
  /**
   *
   * @type {boolean}
   * @memberof EnginePatchOutboundResourceRequest
   */
  enabled?: boolean
  /**
   *
   * @type {Array<string>}
   * @memberof EnginePatchOutboundResourceRequest
   */
  error_ids?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof EnginePatchOutboundResourceRequest
   */
  fields?: Array<string>
  /**
   *
   * @type {EngineLookup}
   * @memberof EnginePatchOutboundResourceRequest
   */
  gateway?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EnginePatchOutboundResourceRequest
   */
  id?: string
  /**
   *
   * @type {number}
   * @memberof EnginePatchOutboundResourceRequest
   */
  limit?: number
  /**
   *
   * @type {number}
   * @memberof EnginePatchOutboundResourceRequest
   */
  max_successively_errors?: number
  /**
   *
   * @type {string}
   * @memberof EnginePatchOutboundResourceRequest
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof EnginePatchOutboundResourceRequest
   */
  number?: string
  /**
   *
   * @type {boolean}
   * @memberof EnginePatchOutboundResourceRequest
   */
  reserve?: boolean
  /**
   *
   * @type {number}
   * @memberof EnginePatchOutboundResourceRequest
   */
  rps?: number
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof EnginePatchOutboundResourceRequest
   */
  variables?: { [key: string]: string }
}
/**
 *
 * @export
 * @interface EnginePatchQueueRequest
 */
export interface EnginePatchQueueRequest {
  /**
   *
   * @type {EngineLookup}
   * @memberof EnginePatchQueueRequest
   */
  calendar?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EnginePatchQueueRequest
   */
  description?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EnginePatchQueueRequest
   */
  dnc_list?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EnginePatchQueueRequest
   */
  domain_id?: string
  /**
   *
   * @type {boolean}
   * @memberof EnginePatchQueueRequest
   */
  enabled?: boolean
  /**
   *
   * @type {Array<string>}
   * @memberof EnginePatchQueueRequest
   */
  fields?: Array<string>
  /**
   *
   * @type {string}
   * @memberof EnginePatchQueueRequest
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EnginePatchQueueRequest
   */
  name?: string
  /**
   *
   * @type {object}
   * @memberof EnginePatchQueueRequest
   */
  payload?: object
  /**
   *
   * @type {number}
   * @memberof EnginePatchQueueRequest
   */
  priority?: number
  /**
   *
   * @type {EngineLookup}
   * @memberof EnginePatchQueueRequest
   */
  ringtone?: EngineLookup
  /**
   *
   * @type {EngineLookup}
   * @memberof EnginePatchQueueRequest
   */
  schema?: EngineLookup
  /**
   *
   * @type {number}
   * @memberof EnginePatchQueueRequest
   */
  sec_locate_agent?: number
  /**
   *
   * @type {string}
   * @memberof EnginePatchQueueRequest
   */
  strategy?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EnginePatchQueueRequest
   */
  team?: EngineLookup
  /**
   *
   * @type {number}
   * @memberof EnginePatchQueueRequest
   */
  timeout?: number
  /**
   *
   * @type {number}
   * @memberof EnginePatchQueueRequest
   */
  type?: number
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof EnginePatchQueueRequest
   */
  variables?: { [key: string]: string }
}
/**
 *
 * @export
 * @interface EnginePatchResourceTeamAgentRequest
 */
export interface EnginePatchResourceTeamAgentRequest {
  /**
   *
   * @type {EngineLookup}
   * @memberof EnginePatchResourceTeamAgentRequest
   */
  agent?: EngineLookup
  /**
   *
   * @type {Array<EngineLookup>}
   * @memberof EnginePatchResourceTeamAgentRequest
   */
  buckets?: Array<EngineLookup>
  /**
   *
   * @type {string}
   * @memberof EnginePatchResourceTeamAgentRequest
   */
  domain_id?: string
  /**
   *
   * @type {Array<string>}
   * @memberof EnginePatchResourceTeamAgentRequest
   */
  fields?: Array<string>
  /**
   *
   * @type {string}
   * @memberof EnginePatchResourceTeamAgentRequest
   */
  id?: string
  /**
   *
   * @type {number}
   * @memberof EnginePatchResourceTeamAgentRequest
   */
  lvl?: number
  /**
   *
   * @type {string}
   * @memberof EnginePatchResourceTeamAgentRequest
   */
  team_id?: string
}
/**
 *
 * @export
 * @interface EnginePatchResourceTeamSkillRequest
 */
export interface EnginePatchResourceTeamSkillRequest {
  /**
   *
   * @type {Array<EngineLookup>}
   * @memberof EnginePatchResourceTeamSkillRequest
   */
  buckets?: Array<EngineLookup>
  /**
   *
   * @type {string}
   * @memberof EnginePatchResourceTeamSkillRequest
   */
  domain_id?: string
  /**
   *
   * @type {Array<string>}
   * @memberof EnginePatchResourceTeamSkillRequest
   */
  fields?: Array<string>
  /**
   *
   * @type {string}
   * @memberof EnginePatchResourceTeamSkillRequest
   */
  id?: string
  /**
   *
   * @type {number}
   * @memberof EnginePatchResourceTeamSkillRequest
   */
  lvl?: number
  /**
   *
   * @type {number}
   * @memberof EnginePatchResourceTeamSkillRequest
   */
  max_capacity?: number
  /**
   *
   * @type {number}
   * @memberof EnginePatchResourceTeamSkillRequest
   */
  min_capacity?: number
  /**
   *
   * @type {EngineLookup}
   * @memberof EnginePatchResourceTeamSkillRequest
   */
  skill?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EnginePatchResourceTeamSkillRequest
   */
  team_id?: string
}
/**
 *
 * @export
 * @interface EnginePatchRoutingOutboundCallRequest
 */
export interface EnginePatchRoutingOutboundCallRequest {
  /**
   *
   * @type {string}
   * @memberof EnginePatchRoutingOutboundCallRequest
   */
  description?: string
  /**
   *
   * @type {boolean}
   * @memberof EnginePatchRoutingOutboundCallRequest
   */
  disabled?: boolean
  /**
   *
   * @type {string}
   * @memberof EnginePatchRoutingOutboundCallRequest
   */
  domain_id?: string
  /**
   *
   * @type {Array<string>}
   * @memberof EnginePatchRoutingOutboundCallRequest
   */
  fields?: Array<string>
  /**
   *
   * @type {string}
   * @memberof EnginePatchRoutingOutboundCallRequest
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EnginePatchRoutingOutboundCallRequest
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof EnginePatchRoutingOutboundCallRequest
   */
  pattern?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EnginePatchRoutingOutboundCallRequest
   */
  schema?: EngineLookup
}
/**
 *
 * @export
 * @interface EnginePatchRoutingSchemaRequest
 */
export interface EnginePatchRoutingSchemaRequest {
  /**
   *
   * @type {boolean}
   * @memberof EnginePatchRoutingSchemaRequest
   */
  debug?: boolean
  /**
   *
   * @type {string}
   * @memberof EnginePatchRoutingSchemaRequest
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EnginePatchRoutingSchemaRequest
   */
  domain_id?: string
  /**
   *
   * @type {Array<string>}
   * @memberof EnginePatchRoutingSchemaRequest
   */
  fields?: Array<string>
  /**
   *
   * @type {string}
   * @memberof EnginePatchRoutingSchemaRequest
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EnginePatchRoutingSchemaRequest
   */
  name?: string
  /**
   *
   * @type {object}
   * @memberof EnginePatchRoutingSchemaRequest
   */
  payload?: object
  /**
   *
   * @type {object}
   * @memberof EnginePatchRoutingSchemaRequest
   */
  schema?: object
  /**
   *
   * @type {number}
   * @memberof EnginePatchRoutingSchemaRequest
   */
  type?: number
}
/**
 *
 * @export
 * @interface EngineQueue
 */
export interface EngineQueue {
  /**
   *
   * @type {number}
   * @memberof EngineQueue
   */
  active?: number
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineQueue
   */
  calendar?: EngineLookup
  /**
   *
   * @type {number}
   * @memberof EngineQueue
   */
  count?: number
  /**
   *
   * @type {string}
   * @memberof EngineQueue
   */
  created_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineQueue
   */
  created_by?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineQueue
   */
  description?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineQueue
   */
  dnc_list?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineQueue
   */
  domain_id?: string
  /**
   *
   * @type {boolean}
   * @memberof EngineQueue
   */
  enabled?: boolean
  /**
   *
   * @type {string}
   * @memberof EngineQueue
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineQueue
   */
  name?: string
  /**
   *
   * @type {object}
   * @memberof EngineQueue
   */
  payload?: object
  /**
   *
   * @type {number}
   * @memberof EngineQueue
   */
  priority?: number
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineQueue
   */
  ringtone?: EngineLookup
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineQueue
   */
  schema?: EngineLookup
  /**
   *
   * @type {number}
   * @memberof EngineQueue
   */
  sec_locate_agent?: number
  /**
   *
   * @type {string}
   * @memberof EngineQueue
   */
  strategy?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineQueue
   */
  team?: EngineLookup
  /**
   *
   * @type {number}
   * @memberof EngineQueue
   */
  timeout?: number
  /**
   *
   * @type {number}
   * @memberof EngineQueue
   */
  type?: number
  /**
   *
   * @type {string}
   * @memberof EngineQueue
   */
  updated_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineQueue
   */
  updated_by?: EngineLookup
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof EngineQueue
   */
  variables?: { [key: string]: string }
  /**
   *
   * @type {number}
   * @memberof EngineQueue
   */
  waiting?: number
}
/**
 *
 * @export
 * @interface EngineQueueBucket
 */
export interface EngineQueueBucket {
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineQueueBucket
   */
  bucket?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineQueueBucket
   */
  id?: string
  /**
   *
   * @type {number}
   * @memberof EngineQueueBucket
   */
  ratio?: number
}
/**
 *
 * @export
 * @interface EngineQueueReportGeneral
 */
export interface EngineQueueReportGeneral {
  /**
   *
   * @type {number}
   * @memberof EngineQueueReportGeneral
   */
  abandoned?: number
  /**
   *
   * @type {number}
   * @memberof EngineQueueReportGeneral
   */
  avg_aht_sec?: number
  /**
   *
   * @type {number}
   * @memberof EngineQueueReportGeneral
   */
  avg_asa_sec?: number
  /**
   *
   * @type {number}
   * @memberof EngineQueueReportGeneral
   */
  avg_awt_sec?: number
  /**
   *
   * @type {number}
   * @memberof EngineQueueReportGeneral
   */
  avg_wrap_sec?: number
  /**
   *
   * @type {number}
   * @memberof EngineQueueReportGeneral
   */
  bridged?: number
  /**
   *
   * @type {string}
   * @memberof EngineQueueReportGeneral
   */
  count?: string
  /**
   *
   * @type {number}
   * @memberof EngineQueueReportGeneral
   */
  max_awt_sec?: number
  /**
   *
   * @type {number}
   * @memberof EngineQueueReportGeneral
   */
  online?: number
  /**
   *
   * @type {number}
   * @memberof EngineQueueReportGeneral
   */
  pause?: number
  /**
   *
   * @type {string}
   * @memberof EngineQueueReportGeneral
   */
  processed?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineQueueReportGeneral
   */
  queue?: EngineLookup
  /**
   *
   * @type {number}
   * @memberof EngineQueueReportGeneral
   */
  sum_bill_sec?: number
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineQueueReportGeneral
   */
  team?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineQueueReportGeneral
   */
  waiting?: string
}
/**
 *
 * @export
 * @interface EngineQueueResourceGroup
 */
export interface EngineQueueResourceGroup {
  /**
   *
   * @type {string}
   * @memberof EngineQueueResourceGroup
   */
  id?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineQueueResourceGroup
   */
  resource_group?: EngineLookup
}
/**
 *
 * @export
 * @interface EngineQueueRouting
 */
export interface EngineQueueRouting {
  /**
   *
   * @type {boolean}
   * @memberof EngineQueueRouting
   */
  disabled?: boolean
  /**
   *
   * @type {string}
   * @memberof EngineQueueRouting
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineQueueRouting
   */
  pattern?: string
  /**
   *
   * @type {number}
   * @memberof EngineQueueRouting
   */
  priority?: number
  /**
   *
   * @type {string}
   * @memberof EngineQueueRouting
   */
  queue_id?: string
}
/**
 *
 * @export
 * @interface EngineResourceDisplay
 */
export interface EngineResourceDisplay {
  /**
   *
   * @type {string}
   * @memberof EngineResourceDisplay
   */
  display?: string
  /**
   *
   * @type {string}
   * @memberof EngineResourceDisplay
   */
  id?: string
}
/**
 *
 * @export
 * @interface EngineResourceTeamAgent
 */
export interface EngineResourceTeamAgent {
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineResourceTeamAgent
   */
  agent?: EngineLookup
  /**
   *
   * @type {Array<EngineLookup>}
   * @memberof EngineResourceTeamAgent
   */
  buckets?: Array<EngineLookup>
  /**
   *
   * @type {string}
   * @memberof EngineResourceTeamAgent
   */
  id?: string
  /**
   *
   * @type {number}
   * @memberof EngineResourceTeamAgent
   */
  lvl?: number
  /**
   *
   * @type {string}
   * @memberof EngineResourceTeamAgent
   */
  team_id?: string
}
/**
 *
 * @export
 * @interface EngineResourceTeamSkill
 */
export interface EngineResourceTeamSkill {
  /**
   *
   * @type {Array<EngineLookup>}
   * @memberof EngineResourceTeamSkill
   */
  buckets?: Array<EngineLookup>
  /**
   *
   * @type {string}
   * @memberof EngineResourceTeamSkill
   */
  id?: string
  /**
   *
   * @type {number}
   * @memberof EngineResourceTeamSkill
   */
  lvl?: number
  /**
   *
   * @type {number}
   * @memberof EngineResourceTeamSkill
   */
  max_capacity?: number
  /**
   *
   * @type {number}
   * @memberof EngineResourceTeamSkill
   */
  min_capacity?: number
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineResourceTeamSkill
   */
  skill?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineResourceTeamSkill
   */
  team_id?: string
}
/**
 *
 * @export
 * @interface EngineResponse
 */
export interface EngineResponse {
  /**
   *
   * @type {string}
   * @memberof EngineResponse
   */
  status?: string
}
/**
 *
 * @export
 * @interface EngineRoutingOutboundCall
 */
export interface EngineRoutingOutboundCall {
  /**
   *
   * @type {string}
   * @memberof EngineRoutingOutboundCall
   */
  created_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineRoutingOutboundCall
   */
  created_by?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineRoutingOutboundCall
   */
  description?: string
  /**
   *
   * @type {boolean}
   * @memberof EngineRoutingOutboundCall
   */
  disabled?: boolean
  /**
   *
   * @type {string}
   * @memberof EngineRoutingOutboundCall
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineRoutingOutboundCall
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineRoutingOutboundCall
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof EngineRoutingOutboundCall
   */
  pattern?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineRoutingOutboundCall
   */
  schema?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineRoutingOutboundCall
   */
  updated_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineRoutingOutboundCall
   */
  updated_by?: EngineLookup
}
/**
 *
 * @export
 * @interface EngineRoutingOutboundCallCompact
 */
export interface EngineRoutingOutboundCallCompact {
  /**
   *
   * @type {string}
   * @memberof EngineRoutingOutboundCallCompact
   */
  description?: string
  /**
   *
   * @type {boolean}
   * @memberof EngineRoutingOutboundCallCompact
   */
  disabled?: boolean
  /**
   *
   * @type {string}
   * @memberof EngineRoutingOutboundCallCompact
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineRoutingOutboundCallCompact
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineRoutingOutboundCallCompact
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof EngineRoutingOutboundCallCompact
   */
  pattern?: string
  /**
   *
   * @type {number}
   * @memberof EngineRoutingOutboundCallCompact
   */
  position?: number
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineRoutingOutboundCallCompact
   */
  schema?: EngineLookup
}
/**
 *
 * @export
 * @interface EngineRoutingSchema
 */
export interface EngineRoutingSchema {
  /**
   *
   * @type {string}
   * @memberof EngineRoutingSchema
   */
  created_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineRoutingSchema
   */
  created_by?: EngineLookup
  /**
   *
   * @type {boolean}
   * @memberof EngineRoutingSchema
   */
  debug?: boolean
  /**
   *
   * @type {string}
   * @memberof EngineRoutingSchema
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineRoutingSchema
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineRoutingSchema
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineRoutingSchema
   */
  name?: string
  /**
   *
   * @type {object}
   * @memberof EngineRoutingSchema
   */
  payload?: object
  /**
   *
   * @type {object}
   * @memberof EngineRoutingSchema
   */
  schema?: object
  /**
   *
   * @type {number}
   * @memberof EngineRoutingSchema
   */
  type?: number
  /**
   *
   * @type {string}
   * @memberof EngineRoutingSchema
   */
  updated_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineRoutingSchema
   */
  updated_by?: EngineLookup
}
/**
 *
 * @export
 * @interface EngineRoutingVariable
 */
export interface EngineRoutingVariable {
  /**
   *
   * @type {string}
   * @memberof EngineRoutingVariable
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineRoutingVariable
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineRoutingVariable
   */
  key?: string
  /**
   *
   * @type {string}
   * @memberof EngineRoutingVariable
   */
  value?: string
}
/**
 *
 * @export
 * @interface EngineSkill
 */
export interface EngineSkill {
  /**
   *
   * @type {string}
   * @memberof EngineSkill
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineSkill
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineSkill
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineSkill
   */
  name?: string
}
/**
 *
 * @export
 * @interface EngineSupervisorInTeam
 */
export interface EngineSupervisorInTeam {
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineSupervisorInTeam
   */
  agent?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineSupervisorInTeam
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineSupervisorInTeam
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineSupervisorInTeam
   */
  team_id?: string
}
/**
 *
 * @export
 * @interface EngineTimezone
 */
export interface EngineTimezone {
  /**
   *
   * @type {string}
   * @memberof EngineTimezone
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineTimezone
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof EngineTimezone
   */
  offset?: string
}
/**
 *
 * @export
 * @interface EngineUpdateAgentRequest
 */
export interface EngineUpdateAgentRequest {
  /**
   *
   * @type {string}
   * @memberof EngineUpdateAgentRequest
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateAgentRequest
   */
  domain_id?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineUpdateAgentRequest
   */
  greeting_media?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineUpdateAgentRequest
   */
  id?: string
  /**
   *
   * @type {number}
   * @memberof EngineUpdateAgentRequest
   */
  progressive_count?: number
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineUpdateAgentRequest
   */
  user?: EngineLookup
}
/**
 *
 * @export
 * @interface EngineUpdateAgentSkillRequest
 */
export interface EngineUpdateAgentSkillRequest {
  /**
   *
   * @type {string}
   * @memberof EngineUpdateAgentSkillRequest
   */
  agent_id?: string
  /**
   *
   * @type {number}
   * @memberof EngineUpdateAgentSkillRequest
   */
  capacity?: number
  /**
   *
   * @type {string}
   * @memberof EngineUpdateAgentSkillRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateAgentSkillRequest
   */
  id?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineUpdateAgentSkillRequest
   */
  skill?: EngineLookup
}
/**
 *
 * @export
 * @interface EngineUpdateAgentTeamRequest
 */
export interface EngineUpdateAgentTeamRequest {
  /**
   *
   * @type {number}
   * @memberof EngineUpdateAgentTeamRequest
   */
  call_timeout?: number
  /**
   *
   * @type {string}
   * @memberof EngineUpdateAgentTeamRequest
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateAgentTeamRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateAgentTeamRequest
   */
  id?: string
  /**
   *
   * @type {number}
   * @memberof EngineUpdateAgentTeamRequest
   */
  max_no_answer?: number
  /**
   *
   * @type {string}
   * @memberof EngineUpdateAgentTeamRequest
   */
  name?: string
  /**
   *
   * @type {number}
   * @memberof EngineUpdateAgentTeamRequest
   */
  no_answer_delay_time?: number
  /**
   *
   * @type {boolean}
   * @memberof EngineUpdateAgentTeamRequest
   */
  post_processing?: boolean
  /**
   *
   * @type {string}
   * @memberof EngineUpdateAgentTeamRequest
   */
  strategy?: string
  /**
   *
   * @type {number}
   * @memberof EngineUpdateAgentTeamRequest
   */
  wrap_up_time?: number
}
/**
 *
 * @export
 * @interface EngineUpdateBucketRequest
 */
export interface EngineUpdateBucketRequest {
  /**
   *
   * @type {string}
   * @memberof EngineUpdateBucketRequest
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateBucketRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateBucketRequest
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateBucketRequest
   */
  name?: string
}
/**
 *
 * @export
 * @interface EngineUpdateCalendarRequest
 */
export interface EngineUpdateCalendarRequest {
  /**
   *
   * @type {Array<EngineAcceptOfDay>}
   * @memberof EngineUpdateCalendarRequest
   */
  accepts?: Array<EngineAcceptOfDay>
  /**
   *
   * @type {string}
   * @memberof EngineUpdateCalendarRequest
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateCalendarRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateCalendarRequest
   */
  end_at?: string
  /**
   *
   * @type {Array<EngineExceptDate>}
   * @memberof EngineUpdateCalendarRequest
   */
  excepts?: Array<EngineExceptDate>
  /**
   *
   * @type {string}
   * @memberof EngineUpdateCalendarRequest
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateCalendarRequest
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateCalendarRequest
   */
  start_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineUpdateCalendarRequest
   */
  timezone?: EngineLookup
}
/**
 *
 * @export
 * @interface EngineUpdateCommunicationTypeRequest
 */
export interface EngineUpdateCommunicationTypeRequest {
  /**
   *
   * @type {string}
   * @memberof EngineUpdateCommunicationTypeRequest
   */
  code?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateCommunicationTypeRequest
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateCommunicationTypeRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateCommunicationTypeRequest
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateCommunicationTypeRequest
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateCommunicationTypeRequest
   */
  type?: string
}
/**
 *
 * @export
 * @interface EngineUpdateEmailProfileRequest
 */
export interface EngineUpdateEmailProfileRequest {
  /**
   *
   * @type {string}
   * @memberof EngineUpdateEmailProfileRequest
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateEmailProfileRequest
   */
  domain_id?: string
  /**
   *
   * @type {boolean}
   * @memberof EngineUpdateEmailProfileRequest
   */
  enabled?: boolean
  /**
   *
   * @type {string}
   * @memberof EngineUpdateEmailProfileRequest
   */
  host?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateEmailProfileRequest
   */
  id?: string
  /**
   *
   * @type {number}
   * @memberof EngineUpdateEmailProfileRequest
   */
  imap_port?: number
  /**
   *
   * @type {string}
   * @memberof EngineUpdateEmailProfileRequest
   */
  login?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateEmailProfileRequest
   */
  mailbox?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateEmailProfileRequest
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateEmailProfileRequest
   */
  password?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineUpdateEmailProfileRequest
   */
  schema?: EngineLookup
  /**
   *
   * @type {number}
   * @memberof EngineUpdateEmailProfileRequest
   */
  smtp_port?: number
}
/**
 *
 * @export
 * @interface EngineUpdateListCommunicationRequest
 */
export interface EngineUpdateListCommunicationRequest {
  /**
   *
   * @type {string}
   * @memberof EngineUpdateListCommunicationRequest
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateListCommunicationRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateListCommunicationRequest
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateListCommunicationRequest
   */
  list_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateListCommunicationRequest
   */
  number?: string
}
/**
 *
 * @export
 * @interface EngineUpdateListRequest
 */
export interface EngineUpdateListRequest {
  /**
   *
   * @type {string}
   * @memberof EngineUpdateListRequest
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateListRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateListRequest
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateListRequest
   */
  name?: string
}
/**
 *
 * @export
 * @interface EngineUpdateMemberRequest
 */
export interface EngineUpdateMemberRequest {
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineUpdateMemberRequest
   */
  bucket?: EngineLookup
  /**
   *
   * @type {Array<EngineMemberCommunicationCreateRequest>}
   * @memberof EngineUpdateMemberRequest
   */
  communications?: Array<EngineMemberCommunicationCreateRequest>
  /**
   *
   * @type {string}
   * @memberof EngineUpdateMemberRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateMemberRequest
   */
  expire_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateMemberRequest
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateMemberRequest
   */
  min_offering_at?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateMemberRequest
   */
  name?: string
  /**
   *
   * @type {number}
   * @memberof EngineUpdateMemberRequest
   */
  priority?: number
  /**
   *
   * @type {string}
   * @memberof EngineUpdateMemberRequest
   */
  queue_id?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineUpdateMemberRequest
   */
  skill?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineUpdateMemberRequest
   */
  stop_cause?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineUpdateMemberRequest
   */
  timezone?: EngineLookup
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof EngineUpdateMemberRequest
   */
  variables?: { [key: string]: string }
}
/**
 *
 * @export
 * @interface EngineUpdateOutboundResourceDisplayRequest
 */
export interface EngineUpdateOutboundResourceDisplayRequest {
  /**
   *
   * @type {string}
   * @memberof EngineUpdateOutboundResourceDisplayRequest
   */
  display?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateOutboundResourceDisplayRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateOutboundResourceDisplayRequest
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateOutboundResourceDisplayRequest
   */
  resource_id?: string
}
/**
 *
 * @export
 * @interface EngineUpdateOutboundResourceGroupRequest
 */
export interface EngineUpdateOutboundResourceGroupRequest {
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineUpdateOutboundResourceGroupRequest
   */
  communication?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineUpdateOutboundResourceGroupRequest
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateOutboundResourceGroupRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateOutboundResourceGroupRequest
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateOutboundResourceGroupRequest
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateOutboundResourceGroupRequest
   */
  strategy?: string
  /**
   *
   * @type {Array<EngineOutboundResourceTimeRange>}
   * @memberof EngineUpdateOutboundResourceGroupRequest
   */
  time?: Array<EngineOutboundResourceTimeRange>
}
/**
 *
 * @export
 * @interface EngineUpdateOutboundResourceInGroupRequest
 */
export interface EngineUpdateOutboundResourceInGroupRequest {
  /**
   *
   * @type {string}
   * @memberof EngineUpdateOutboundResourceInGroupRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateOutboundResourceInGroupRequest
   */
  group_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateOutboundResourceInGroupRequest
   */
  id?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineUpdateOutboundResourceInGroupRequest
   */
  resource?: EngineLookup
}
/**
 *
 * @export
 * @interface EngineUpdateOutboundResourceRequest
 */
export interface EngineUpdateOutboundResourceRequest {
  /**
   *
   * @type {string}
   * @memberof EngineUpdateOutboundResourceRequest
   */
  domain_id?: string
  /**
   *
   * @type {boolean}
   * @memberof EngineUpdateOutboundResourceRequest
   */
  enabled?: boolean
  /**
   *
   * @type {Array<string>}
   * @memberof EngineUpdateOutboundResourceRequest
   */
  error_ids?: Array<string>
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineUpdateOutboundResourceRequest
   */
  gateway?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineUpdateOutboundResourceRequest
   */
  id?: string
  /**
   *
   * @type {number}
   * @memberof EngineUpdateOutboundResourceRequest
   */
  limit?: number
  /**
   *
   * @type {number}
   * @memberof EngineUpdateOutboundResourceRequest
   */
  max_successively_errors?: number
  /**
   *
   * @type {string}
   * @memberof EngineUpdateOutboundResourceRequest
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateOutboundResourceRequest
   */
  number?: string
  /**
   *
   * @type {boolean}
   * @memberof EngineUpdateOutboundResourceRequest
   */
  reserve?: boolean
  /**
   *
   * @type {number}
   * @memberof EngineUpdateOutboundResourceRequest
   */
  rps?: number
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof EngineUpdateOutboundResourceRequest
   */
  variables?: { [key: string]: string }
}
/**
 *
 * @export
 * @interface EngineUpdateQueueBucketRequest
 */
export interface EngineUpdateQueueBucketRequest {
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineUpdateQueueBucketRequest
   */
  bucket?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineUpdateQueueBucketRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateQueueBucketRequest
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateQueueBucketRequest
   */
  queue_id?: string
  /**
   *
   * @type {number}
   * @memberof EngineUpdateQueueBucketRequest
   */
  ratio?: number
}
/**
 *
 * @export
 * @interface EngineUpdateQueueRequest
 */
export interface EngineUpdateQueueRequest {
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineUpdateQueueRequest
   */
  calendar?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineUpdateQueueRequest
   */
  description?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineUpdateQueueRequest
   */
  dnc_list?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineUpdateQueueRequest
   */
  domain_id?: string
  /**
   *
   * @type {boolean}
   * @memberof EngineUpdateQueueRequest
   */
  enabled?: boolean
  /**
   *
   * @type {string}
   * @memberof EngineUpdateQueueRequest
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateQueueRequest
   */
  name?: string
  /**
   *
   * @type {object}
   * @memberof EngineUpdateQueueRequest
   */
  payload?: object
  /**
   *
   * @type {number}
   * @memberof EngineUpdateQueueRequest
   */
  priority?: number
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineUpdateQueueRequest
   */
  ringtone?: EngineLookup
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineUpdateQueueRequest
   */
  schema?: EngineLookup
  /**
   *
   * @type {number}
   * @memberof EngineUpdateQueueRequest
   */
  sec_locate_agent?: number
  /**
   *
   * @type {string}
   * @memberof EngineUpdateQueueRequest
   */
  strategy?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineUpdateQueueRequest
   */
  team?: EngineLookup
  /**
   *
   * @type {number}
   * @memberof EngineUpdateQueueRequest
   */
  timeout?: number
  /**
   *
   * @type {number}
   * @memberof EngineUpdateQueueRequest
   */
  type?: number
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof EngineUpdateQueueRequest
   */
  variables?: { [key: string]: string }
}
/**
 *
 * @export
 * @interface EngineUpdateQueueResourceGroupRequest
 */
export interface EngineUpdateQueueResourceGroupRequest {
  /**
   *
   * @type {string}
   * @memberof EngineUpdateQueueResourceGroupRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateQueueResourceGroupRequest
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateQueueResourceGroupRequest
   */
  queue_id?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineUpdateQueueResourceGroupRequest
   */
  resource_group?: EngineLookup
}
/**
 *
 * @export
 * @interface EngineUpdateQueueRoutingRequest
 */
export interface EngineUpdateQueueRoutingRequest {
  /**
   *
   * @type {boolean}
   * @memberof EngineUpdateQueueRoutingRequest
   */
  disabled?: boolean
  /**
   *
   * @type {string}
   * @memberof EngineUpdateQueueRoutingRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateQueueRoutingRequest
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateQueueRoutingRequest
   */
  pattern?: string
  /**
   *
   * @type {number}
   * @memberof EngineUpdateQueueRoutingRequest
   */
  priority?: number
  /**
   *
   * @type {string}
   * @memberof EngineUpdateQueueRoutingRequest
   */
  queue_id?: string
}
/**
 *
 * @export
 * @interface EngineUpdateResourceTeamAgentRequest
 */
export interface EngineUpdateResourceTeamAgentRequest {
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineUpdateResourceTeamAgentRequest
   */
  agent?: EngineLookup
  /**
   *
   * @type {Array<EngineLookup>}
   * @memberof EngineUpdateResourceTeamAgentRequest
   */
  buckets?: Array<EngineLookup>
  /**
   *
   * @type {string}
   * @memberof EngineUpdateResourceTeamAgentRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateResourceTeamAgentRequest
   */
  id?: string
  /**
   *
   * @type {number}
   * @memberof EngineUpdateResourceTeamAgentRequest
   */
  lvl?: number
  /**
   *
   * @type {string}
   * @memberof EngineUpdateResourceTeamAgentRequest
   */
  team_id?: string
}
/**
 *
 * @export
 * @interface EngineUpdateResourceTeamSkillRequest
 */
export interface EngineUpdateResourceTeamSkillRequest {
  /**
   *
   * @type {Array<EngineLookup>}
   * @memberof EngineUpdateResourceTeamSkillRequest
   */
  buckets?: Array<EngineLookup>
  /**
   *
   * @type {string}
   * @memberof EngineUpdateResourceTeamSkillRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateResourceTeamSkillRequest
   */
  id?: string
  /**
   *
   * @type {number}
   * @memberof EngineUpdateResourceTeamSkillRequest
   */
  lvl?: number
  /**
   *
   * @type {number}
   * @memberof EngineUpdateResourceTeamSkillRequest
   */
  max_capacity?: number
  /**
   *
   * @type {number}
   * @memberof EngineUpdateResourceTeamSkillRequest
   */
  min_capacity?: number
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineUpdateResourceTeamSkillRequest
   */
  skill?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineUpdateResourceTeamSkillRequest
   */
  team_id?: string
}
/**
 *
 * @export
 * @interface EngineUpdateRoutingOutboundCallRequest
 */
export interface EngineUpdateRoutingOutboundCallRequest {
  /**
   *
   * @type {string}
   * @memberof EngineUpdateRoutingOutboundCallRequest
   */
  description?: string
  /**
   *
   * @type {boolean}
   * @memberof EngineUpdateRoutingOutboundCallRequest
   */
  disabled?: boolean
  /**
   *
   * @type {string}
   * @memberof EngineUpdateRoutingOutboundCallRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateRoutingOutboundCallRequest
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateRoutingOutboundCallRequest
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateRoutingOutboundCallRequest
   */
  pattern?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineUpdateRoutingOutboundCallRequest
   */
  schema?: EngineLookup
}
/**
 *
 * @export
 * @interface EngineUpdateRoutingSchemaRequest
 */
export interface EngineUpdateRoutingSchemaRequest {
  /**
   *
   * @type {boolean}
   * @memberof EngineUpdateRoutingSchemaRequest
   */
  debug?: boolean
  /**
   *
   * @type {string}
   * @memberof EngineUpdateRoutingSchemaRequest
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateRoutingSchemaRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateRoutingSchemaRequest
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateRoutingSchemaRequest
   */
  name?: string
  /**
   *
   * @type {object}
   * @memberof EngineUpdateRoutingSchemaRequest
   */
  payload?: object
  /**
   *
   * @type {object}
   * @memberof EngineUpdateRoutingSchemaRequest
   */
  schema?: object
  /**
   *
   * @type {number}
   * @memberof EngineUpdateRoutingSchemaRequest
   */
  type?: number
}
/**
 *
 * @export
 * @interface EngineUpdateRoutingVariableRequest
 */
export interface EngineUpdateRoutingVariableRequest {
  /**
   *
   * @type {string}
   * @memberof EngineUpdateRoutingVariableRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateRoutingVariableRequest
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateRoutingVariableRequest
   */
  key?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateRoutingVariableRequest
   */
  value?: string
}
/**
 *
 * @export
 * @interface EngineUpdateSkillRequest
 */
export interface EngineUpdateSkillRequest {
  /**
   *
   * @type {string}
   * @memberof EngineUpdateSkillRequest
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateSkillRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateSkillRequest
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateSkillRequest
   */
  name?: string
}
/**
 *
 * @export
 * @interface EngineUpdateSupervisorInTeamRequest
 */
export interface EngineUpdateSupervisorInTeamRequest {
  /**
   *
   * @type {EngineLookup}
   * @memberof EngineUpdateSupervisorInTeamRequest
   */
  agent?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof EngineUpdateSupervisorInTeamRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateSupervisorInTeamRequest
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUpdateSupervisorInTeamRequest
   */
  team_id?: string
}
/**
 *
 * @export
 * @interface EngineUserCallRequest
 */
export interface EngineUserCallRequest {
  /**
   *
   * @type {string}
   * @memberof EngineUserCallRequest
   */
  app_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUserCallRequest
   */
  domain_id?: string
  /**
   *
   * @type {string}
   * @memberof EngineUserCallRequest
   */
  id?: string
}
/**
 * `NullValue` is a singleton enumeration to represent the null value for the `Value` type union.   The JSON representation for `NullValue` is JSON `null`.   - NULL_VALUE: Null value.
 * @export
 * @enum {string}
 */
export enum ProtobufNullValue {
  NULLVALUE = 'NULL_VALUE',
}

/**
 *
 * @export
 * @interface StorageBackendProfile
 */
export interface StorageBackendProfile {
  /**
   *
   * @type {string}
   * @memberof StorageBackendProfile
   */
  created_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof StorageBackendProfile
   */
  created_by?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof StorageBackendProfile
   */
  data_count?: string
  /**
   *
   * @type {string}
   * @memberof StorageBackendProfile
   */
  data_size?: string
  /**
   *
   * @type {string}
   * @memberof StorageBackendProfile
   */
  description?: string
  /**
   *
   * @type {boolean}
   * @memberof StorageBackendProfile
   */
  disabled?: boolean
  /**
   *
   * @type {number}
   * @memberof StorageBackendProfile
   */
  expire_days?: number
  /**
   *
   * @type {string}
   * @memberof StorageBackendProfile
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof StorageBackendProfile
   */
  max_size?: string
  /**
   *
   * @type {string}
   * @memberof StorageBackendProfile
   */
  name?: string
  /**
   *
   * @type {number}
   * @memberof StorageBackendProfile
   */
  priority?: number
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof StorageBackendProfile
   */
  properties?: { [key: string]: string }
  /**
   *
   * @type {string}
   * @memberof StorageBackendProfile
   */
  type?: string
  /**
   *
   * @type {string}
   * @memberof StorageBackendProfile
   */
  updated_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof StorageBackendProfile
   */
  updated_by?: EngineLookup
}
/**
 *
 * @export
 * @interface StorageCreateBackendProfileRequest
 */
export interface StorageCreateBackendProfileRequest {
  /**
   *
   * @type {string}
   * @memberof StorageCreateBackendProfileRequest
   */
  description?: string
  /**
   *
   * @type {boolean}
   * @memberof StorageCreateBackendProfileRequest
   */
  disabled?: boolean
  /**
   *
   * @type {string}
   * @memberof StorageCreateBackendProfileRequest
   */
  domain_id?: string
  /**
   *
   * @type {number}
   * @memberof StorageCreateBackendProfileRequest
   */
  expire_days?: number
  /**
   *
   * @type {string}
   * @memberof StorageCreateBackendProfileRequest
   */
  max_size?: string
  /**
   *
   * @type {string}
   * @memberof StorageCreateBackendProfileRequest
   */
  name?: string
  /**
   *
   * @type {number}
   * @memberof StorageCreateBackendProfileRequest
   */
  priority?: number
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof StorageCreateBackendProfileRequest
   */
  properties?: { [key: string]: string }
  /**
   *
   * @type {string}
   * @memberof StorageCreateBackendProfileRequest
   */
  type?: string
}
/**
 *
 * @export
 * @interface StorageListBackendProfile
 */
export interface StorageListBackendProfile {
  /**
   *
   * @type {Array<StorageBackendProfile>}
   * @memberof StorageListBackendProfile
   */
  items?: Array<StorageBackendProfile>
  /**
   *
   * @type {boolean}
   * @memberof StorageListBackendProfile
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface StorageListMedia
 */
export interface StorageListMedia {
  /**
   *
   * @type {Array<StorageMediaFile>}
   * @memberof StorageListMedia
   */
  items?: Array<StorageMediaFile>
  /**
   *
   * @type {boolean}
   * @memberof StorageListMedia
   */
  next?: boolean
}
/**
 *
 * @export
 * @interface StorageMediaFile
 */
export interface StorageMediaFile {
  /**
   *
   * @type {string}
   * @memberof StorageMediaFile
   */
  created_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof StorageMediaFile
   */
  created_by?: EngineLookup
  /**
   *
   * @type {string}
   * @memberof StorageMediaFile
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof StorageMediaFile
   */
  mime_type?: string
  /**
   *
   * @type {string}
   * @memberof StorageMediaFile
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof StorageMediaFile
   */
  size?: string
  /**
   *
   * @type {string}
   * @memberof StorageMediaFile
   */
  updated_at?: string
  /**
   *
   * @type {EngineLookup}
   * @memberof StorageMediaFile
   */
  updated_by?: EngineLookup
}
/**
 *
 * @export
 * @interface StoragePatchBackendProfileRequest
 */
export interface StoragePatchBackendProfileRequest {
  /**
   *
   * @type {string}
   * @memberof StoragePatchBackendProfileRequest
   */
  description?: string
  /**
   *
   * @type {boolean}
   * @memberof StoragePatchBackendProfileRequest
   */
  disabled?: boolean
  /**
   *
   * @type {string}
   * @memberof StoragePatchBackendProfileRequest
   */
  domain_id?: string
  /**
   *
   * @type {number}
   * @memberof StoragePatchBackendProfileRequest
   */
  expire_days?: number
  /**
   *
   * @type {Array<string>}
   * @memberof StoragePatchBackendProfileRequest
   */
  fields?: Array<string>
  /**
   *
   * @type {string}
   * @memberof StoragePatchBackendProfileRequest
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof StoragePatchBackendProfileRequest
   */
  max_size?: string
  /**
   *
   * @type {string}
   * @memberof StoragePatchBackendProfileRequest
   */
  name?: string
  /**
   *
   * @type {number}
   * @memberof StoragePatchBackendProfileRequest
   */
  priority?: number
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof StoragePatchBackendProfileRequest
   */
  properties?: { [key: string]: string }
}
/**
 *
 * @export
 * @interface StorageUpdateBackendProfileRequest
 */
export interface StorageUpdateBackendProfileRequest {
  /**
   *
   * @type {string}
   * @memberof StorageUpdateBackendProfileRequest
   */
  description?: string
  /**
   *
   * @type {boolean}
   * @memberof StorageUpdateBackendProfileRequest
   */
  disabled?: boolean
  /**
   *
   * @type {string}
   * @memberof StorageUpdateBackendProfileRequest
   */
  domain_id?: string
  /**
   *
   * @type {number}
   * @memberof StorageUpdateBackendProfileRequest
   */
  expire_days?: number
  /**
   *
   * @type {string}
   * @memberof StorageUpdateBackendProfileRequest
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof StorageUpdateBackendProfileRequest
   */
  max_size?: string
  /**
   *
   * @type {string}
   * @memberof StorageUpdateBackendProfileRequest
   */
  name?: string
  /**
   *
   * @type {number}
   * @memberof StorageUpdateBackendProfileRequest
   */
  priority?: number
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof StorageUpdateBackendProfileRequest
   */
  properties?: { [key: string]: string }
}

/**
 * AgentServiceApi - axios parameter creator
 * @export
 */
export const AgentServiceApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {string} agentId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [timeFrom]
     * @param {string} [timeTo]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentStateHistory: async (
      agentId: string,
      page?: number,
      size?: number,
      timeFrom?: string,
      timeTo?: string,
      q?: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'agentId' is not null or undefined
      if (agentId === null || agentId === undefined) {
        throw new RequiredError(
          'agentId',
          'Required parameter agentId was null or undefined when calling agentStateHistory.'
        )
      }
      const localVarPath = `/call_center/agents/{agent_id}/states/history`.replace(
        `{${'agent_id'}}`,
        encodeURIComponent(String(agentId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (timeFrom !== undefined) {
        localVarQueryParameter['time_from'] = timeFrom
      }

      if (timeTo !== undefined) {
        localVarQueryParameter['time_to'] = timeTo
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create Agent
     * @param {EngineCreateAgentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAgent: async (
      body: EngineCreateAgentRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createAgent.'
        )
      }
      const localVarPath = `/call_center/agents`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Remove Agent
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAgent: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteAgent.'
        )
      }
      const localVarPath = `/call_center/agents/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Agent item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readAgent: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readAgent.'
        )
      }
      const localVarPath = `/call_center/agents/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List of Agent
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {Array<string>} [id]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAgent: async (
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      fields?: Array<string>,
      sort?: string,
      id?: Array<string>,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/call_center/agents`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (id) {
        localVarQueryParameter['id'] = id
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [timeFrom]
     * @param {string} [timeTo]
     * @param {Array<number>} [agentId]
     * @param {string} [domainId]
     * @param {string} [q]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAgentCallStatistics: async (
      page?: number,
      size?: number,
      timeFrom?: string,
      timeTo?: string,
      agentId?: Array<number>,
      domainId?: string,
      q?: string,
      fields?: Array<string>,
      sort?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/call_center/agents/reports/call`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (timeFrom !== undefined) {
        localVarQueryParameter['time.from'] = timeFrom
      }

      if (timeTo !== undefined) {
        localVarQueryParameter['time.to'] = timeTo
      }

      if (agentId) {
        localVarQueryParameter['agent_id'] = agentId
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAgentInQueue: async (
      id: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling searchAgentInQueue.'
        )
      }
      const localVarPath = `/call_center/agents/{id}/queues`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} agentId
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAgentInQueueStatistics: async (
      agentId: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'agentId' is not null or undefined
      if (agentId === null || agentId === undefined) {
        throw new RequiredError(
          'agentId',
          'Required parameter agentId was null or undefined when calling searchAgentInQueueStatistics.'
        )
      }
      const localVarPath = `/call_center/agents/{agent_id}/statistics/queues`.replace(
        `{${'agent_id'}}`,
        encodeURIComponent(String(agentId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAgentInTeam: async (
      id: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling searchAgentInTeam.'
        )
      }
      const localVarPath = `/call_center/agents/{id}/teams`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [joinedAtFrom]
     * @param {string} [joinedAtTo]
     * @param {Array<string>} [agentId]
     * @param {string} [sort]
     * @param {string} [domainId]
     * @param {string} [fromId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAgentStateHistory: async (
      page?: number,
      size?: number,
      joinedAtFrom?: string,
      joinedAtTo?: string,
      agentId?: Array<string>,
      sort?: string,
      domainId?: string,
      fromId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/call_center/agents/states/history`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (joinedAtFrom !== undefined) {
        localVarQueryParameter['joined_at.from'] = joinedAtFrom
      }

      if (joinedAtTo !== undefined) {
        localVarQueryParameter['joined_at.to'] = joinedAtTo
      }

      if (agentId) {
        localVarQueryParameter['agent_id'] = agentId
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      if (fromId !== undefined) {
        localVarQueryParameter['from_id'] = fromId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [timeFrom]
     * @param {string} [timeTo]
     * @param {string} [q]
     * @param {Array<string>} [agentId]
     * @param {Array<string>} [status]
     * @param {Array<number>} [queueId]
     * @param {Array<number>} [teamId]
     * @param {string} [utilizationFrom]
     * @param {string} [utilizationTo]
     * @param {boolean} [hasCall]
     * @param {string} [sort]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAgentStatusStatistic: async (
      page?: number,
      size?: number,
      timeFrom?: string,
      timeTo?: string,
      q?: string,
      agentId?: Array<string>,
      status?: Array<string>,
      queueId?: Array<number>,
      teamId?: Array<number>,
      utilizationFrom?: string,
      utilizationTo?: string,
      hasCall?: boolean,
      sort?: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/call_center/agents/reports/status`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (timeFrom !== undefined) {
        localVarQueryParameter['time.from'] = timeFrom
      }

      if (timeTo !== undefined) {
        localVarQueryParameter['time.to'] = timeTo
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (agentId) {
        localVarQueryParameter['agent_id'] = agentId
      }

      if (status) {
        localVarQueryParameter['status'] = status
      }

      if (queueId) {
        localVarQueryParameter['queue_id'] = queueId
      }

      if (teamId) {
        localVarQueryParameter['team_id'] = teamId
      }

      if (utilizationFrom !== undefined) {
        localVarQueryParameter['utilization.from'] = utilizationFrom
      }

      if (utilizationTo !== undefined) {
        localVarQueryParameter['utilization.to'] = utilizationTo
      }

      if (hasCall !== undefined) {
        localVarQueryParameter['has_call'] = hasCall
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary SearchLookupAgentNotExistsUser
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchLookupUsersAgentNotExists: async (
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/call_center/lookups/agents/users`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update Agent
     * @param {string} id
     * @param {EngineUpdateAgentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAgent: async (
      id: string,
      body: EngineUpdateAgentRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateAgent.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateAgent.'
        )
      }
      const localVarPath = `/call_center/agents/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Change agent status
     * @param {string} id
     * @param {EngineAgentStatusRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAgentStatus: async (
      id: string,
      body: EngineAgentStatusRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateAgentStatus.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateAgentStatus.'
        )
      }
      const localVarPath = `/call_center/agents/{id}/status`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AgentServiceApi - functional programming interface
 * @export
 */
export const AgentServiceApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} agentId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [timeFrom]
     * @param {string} [timeTo]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async agentStateHistory(
      agentId: string,
      page?: number,
      size?: number,
      timeFrom?: string,
      timeTo?: string,
      q?: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListAgentStateHistory>
    > {
      const localVarAxiosArgs = await AgentServiceApiAxiosParamCreator(
        configuration
      ).agentStateHistory(
        agentId,
        page,
        size,
        timeFrom,
        timeTo,
        q,
        domainId,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create Agent
     * @param {EngineCreateAgentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createAgent(
      body: EngineCreateAgentRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineAgent>
    > {
      const localVarAxiosArgs = await AgentServiceApiAxiosParamCreator(
        configuration
      ).createAgent(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Remove Agent
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAgent(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineAgent>
    > {
      const localVarAxiosArgs = await AgentServiceApiAxiosParamCreator(
        configuration
      ).deleteAgent(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Agent item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readAgent(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineAgent>
    > {
      const localVarAxiosArgs = await AgentServiceApiAxiosParamCreator(
        configuration
      ).readAgent(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List of Agent
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {Array<string>} [id]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchAgent(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      fields?: Array<string>,
      sort?: string,
      id?: Array<string>,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListAgent>
    > {
      const localVarAxiosArgs = await AgentServiceApiAxiosParamCreator(
        configuration
      ).searchAgent(page, size, q, domainId, fields, sort, id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [timeFrom]
     * @param {string} [timeTo]
     * @param {Array<number>} [agentId]
     * @param {string} [domainId]
     * @param {string} [q]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchAgentCallStatistics(
      page?: number,
      size?: number,
      timeFrom?: string,
      timeTo?: string,
      agentId?: Array<number>,
      domainId?: string,
      q?: string,
      fields?: Array<string>,
      sort?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineAgentCallStatisticsList>
    > {
      const localVarAxiosArgs = await AgentServiceApiAxiosParamCreator(
        configuration
      ).searchAgentCallStatistics(
        page,
        size,
        timeFrom,
        timeTo,
        agentId,
        domainId,
        q,
        fields,
        sort,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} id
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchAgentInQueue(
      id: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListAgentInQueue>
    > {
      const localVarAxiosArgs = await AgentServiceApiAxiosParamCreator(
        configuration
      ).searchAgentInQueue(id, page, size, q, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} agentId
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchAgentInQueueStatistics(
      agentId: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineAgentInQueueStatisticsList>
    > {
      const localVarAxiosArgs = await AgentServiceApiAxiosParamCreator(
        configuration
      ).searchAgentInQueueStatistics(agentId, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} id
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchAgentInTeam(
      id: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListAgentInTeam>
    > {
      const localVarAxiosArgs = await AgentServiceApiAxiosParamCreator(
        configuration
      ).searchAgentInTeam(id, page, size, q, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [joinedAtFrom]
     * @param {string} [joinedAtTo]
     * @param {Array<string>} [agentId]
     * @param {string} [sort]
     * @param {string} [domainId]
     * @param {string} [fromId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchAgentStateHistory(
      page?: number,
      size?: number,
      joinedAtFrom?: string,
      joinedAtTo?: string,
      agentId?: Array<string>,
      sort?: string,
      domainId?: string,
      fromId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListAgentStateHistory>
    > {
      const localVarAxiosArgs = await AgentServiceApiAxiosParamCreator(
        configuration
      ).searchAgentStateHistory(
        page,
        size,
        joinedAtFrom,
        joinedAtTo,
        agentId,
        sort,
        domainId,
        fromId,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [timeFrom]
     * @param {string} [timeTo]
     * @param {string} [q]
     * @param {Array<string>} [agentId]
     * @param {Array<string>} [status]
     * @param {Array<number>} [queueId]
     * @param {Array<number>} [teamId]
     * @param {string} [utilizationFrom]
     * @param {string} [utilizationTo]
     * @param {boolean} [hasCall]
     * @param {string} [sort]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchAgentStatusStatistic(
      page?: number,
      size?: number,
      timeFrom?: string,
      timeTo?: string,
      q?: string,
      agentId?: Array<string>,
      status?: Array<string>,
      queueId?: Array<number>,
      teamId?: Array<number>,
      utilizationFrom?: string,
      utilizationTo?: string,
      hasCall?: boolean,
      sort?: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListAgentStatsStatistic>
    > {
      const localVarAxiosArgs = await AgentServiceApiAxiosParamCreator(
        configuration
      ).searchAgentStatusStatistic(
        page,
        size,
        timeFrom,
        timeTo,
        q,
        agentId,
        status,
        queueId,
        teamId,
        utilizationFrom,
        utilizationTo,
        hasCall,
        sort,
        domainId,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary SearchLookupAgentNotExistsUser
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchLookupUsersAgentNotExists(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListAgentUser>
    > {
      const localVarAxiosArgs = await AgentServiceApiAxiosParamCreator(
        configuration
      ).searchLookupUsersAgentNotExists(page, size, q, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update Agent
     * @param {string} id
     * @param {EngineUpdateAgentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateAgent(
      id: string,
      body: EngineUpdateAgentRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineAgent>
    > {
      const localVarAxiosArgs = await AgentServiceApiAxiosParamCreator(
        configuration
      ).updateAgent(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Change agent status
     * @param {string} id
     * @param {EngineAgentStatusRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateAgentStatus(
      id: string,
      body: EngineAgentStatusRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineResponse>
    > {
      const localVarAxiosArgs = await AgentServiceApiAxiosParamCreator(
        configuration
      ).updateAgentStatus(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * AgentServiceApi - factory interface
 * @export
 */
export const AgentServiceApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @param {string} agentId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [timeFrom]
     * @param {string} [timeTo]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentStateHistory(
      agentId: string,
      page?: number,
      size?: number,
      timeFrom?: string,
      timeTo?: string,
      q?: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListAgentStateHistory> {
      return AgentServiceApiFp(configuration)
        .agentStateHistory(
          agentId,
          page,
          size,
          timeFrom,
          timeTo,
          q,
          domainId,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create Agent
     * @param {EngineCreateAgentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAgent(
      body: EngineCreateAgentRequest,
      options?: any
    ): AxiosPromise<EngineAgent> {
      return AgentServiceApiFp(configuration)
        .createAgent(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Remove Agent
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAgent(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineAgent> {
      return AgentServiceApiFp(configuration)
        .deleteAgent(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Agent item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readAgent(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineAgent> {
      return AgentServiceApiFp(configuration)
        .readAgent(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List of Agent
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {Array<string>} [id]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAgent(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      fields?: Array<string>,
      sort?: string,
      id?: Array<string>,
      options?: any
    ): AxiosPromise<EngineListAgent> {
      return AgentServiceApiFp(configuration)
        .searchAgent(page, size, q, domainId, fields, sort, id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [timeFrom]
     * @param {string} [timeTo]
     * @param {Array<number>} [agentId]
     * @param {string} [domainId]
     * @param {string} [q]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAgentCallStatistics(
      page?: number,
      size?: number,
      timeFrom?: string,
      timeTo?: string,
      agentId?: Array<number>,
      domainId?: string,
      q?: string,
      fields?: Array<string>,
      sort?: string,
      options?: any
    ): AxiosPromise<EngineAgentCallStatisticsList> {
      return AgentServiceApiFp(configuration)
        .searchAgentCallStatistics(
          page,
          size,
          timeFrom,
          timeTo,
          agentId,
          domainId,
          q,
          fields,
          sort,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} id
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAgentInQueue(
      id: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListAgentInQueue> {
      return AgentServiceApiFp(configuration)
        .searchAgentInQueue(id, page, size, q, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} agentId
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAgentInQueueStatistics(
      agentId: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineAgentInQueueStatisticsList> {
      return AgentServiceApiFp(configuration)
        .searchAgentInQueueStatistics(agentId, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} id
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAgentInTeam(
      id: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListAgentInTeam> {
      return AgentServiceApiFp(configuration)
        .searchAgentInTeam(id, page, size, q, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [joinedAtFrom]
     * @param {string} [joinedAtTo]
     * @param {Array<string>} [agentId]
     * @param {string} [sort]
     * @param {string} [domainId]
     * @param {string} [fromId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAgentStateHistory(
      page?: number,
      size?: number,
      joinedAtFrom?: string,
      joinedAtTo?: string,
      agentId?: Array<string>,
      sort?: string,
      domainId?: string,
      fromId?: string,
      options?: any
    ): AxiosPromise<EngineListAgentStateHistory> {
      return AgentServiceApiFp(configuration)
        .searchAgentStateHistory(
          page,
          size,
          joinedAtFrom,
          joinedAtTo,
          agentId,
          sort,
          domainId,
          fromId,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [timeFrom]
     * @param {string} [timeTo]
     * @param {string} [q]
     * @param {Array<string>} [agentId]
     * @param {Array<string>} [status]
     * @param {Array<number>} [queueId]
     * @param {Array<number>} [teamId]
     * @param {string} [utilizationFrom]
     * @param {string} [utilizationTo]
     * @param {boolean} [hasCall]
     * @param {string} [sort]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAgentStatusStatistic(
      page?: number,
      size?: number,
      timeFrom?: string,
      timeTo?: string,
      q?: string,
      agentId?: Array<string>,
      status?: Array<string>,
      queueId?: Array<number>,
      teamId?: Array<number>,
      utilizationFrom?: string,
      utilizationTo?: string,
      hasCall?: boolean,
      sort?: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListAgentStatsStatistic> {
      return AgentServiceApiFp(configuration)
        .searchAgentStatusStatistic(
          page,
          size,
          timeFrom,
          timeTo,
          q,
          agentId,
          status,
          queueId,
          teamId,
          utilizationFrom,
          utilizationTo,
          hasCall,
          sort,
          domainId,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary SearchLookupAgentNotExistsUser
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchLookupUsersAgentNotExists(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListAgentUser> {
      return AgentServiceApiFp(configuration)
        .searchLookupUsersAgentNotExists(page, size, q, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update Agent
     * @param {string} id
     * @param {EngineUpdateAgentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAgent(
      id: string,
      body: EngineUpdateAgentRequest,
      options?: any
    ): AxiosPromise<EngineAgent> {
      return AgentServiceApiFp(configuration)
        .updateAgent(id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Change agent status
     * @param {string} id
     * @param {EngineAgentStatusRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAgentStatus(
      id: string,
      body: EngineAgentStatusRequest,
      options?: any
    ): AxiosPromise<EngineResponse> {
      return AgentServiceApiFp(configuration)
        .updateAgentStatus(id, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * AgentServiceApi - object-oriented interface
 * @export
 * @class AgentServiceApi
 * @extends {BaseAPI}
 */
export class AgentServiceApi extends BaseAPI {
  /**
   *
   * @param {string} agentId
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [timeFrom]
   * @param {string} [timeTo]
   * @param {string} [q]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentServiceApi
   */
  public agentStateHistory(
    agentId: string,
    page?: number,
    size?: number,
    timeFrom?: string,
    timeTo?: string,
    q?: string,
    domainId?: string,
    options?: any
  ) {
    return AgentServiceApiFp(this.configuration)
      .agentStateHistory(
        agentId,
        page,
        size,
        timeFrom,
        timeTo,
        q,
        domainId,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create Agent
   * @param {EngineCreateAgentRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentServiceApi
   */
  public createAgent(body: EngineCreateAgentRequest, options?: any) {
    return AgentServiceApiFp(this.configuration)
      .createAgent(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Remove Agent
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentServiceApi
   */
  public deleteAgent(id: string, domainId?: string, options?: any) {
    return AgentServiceApiFp(this.configuration)
      .deleteAgent(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Agent item
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentServiceApi
   */
  public readAgent(id: string, domainId?: string, options?: any) {
    return AgentServiceApiFp(this.configuration)
      .readAgent(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List of Agent
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [domainId]
   * @param {Array<string>} [fields]
   * @param {string} [sort]
   * @param {Array<string>} [id]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentServiceApi
   */
  public searchAgent(
    page?: number,
    size?: number,
    q?: string,
    domainId?: string,
    fields?: Array<string>,
    sort?: string,
    id?: Array<string>,
    options?: any
  ) {
    return AgentServiceApiFp(this.configuration)
      .searchAgent(page, size, q, domainId, fields, sort, id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [timeFrom]
   * @param {string} [timeTo]
   * @param {Array<number>} [agentId]
   * @param {string} [domainId]
   * @param {string} [q]
   * @param {Array<string>} [fields]
   * @param {string} [sort]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentServiceApi
   */
  public searchAgentCallStatistics(
    page?: number,
    size?: number,
    timeFrom?: string,
    timeTo?: string,
    agentId?: Array<number>,
    domainId?: string,
    q?: string,
    fields?: Array<string>,
    sort?: string,
    options?: any
  ) {
    return AgentServiceApiFp(this.configuration)
      .searchAgentCallStatistics(
        page,
        size,
        timeFrom,
        timeTo,
        agentId,
        domainId,
        q,
        fields,
        sort,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} id
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentServiceApi
   */
  public searchAgentInQueue(
    id: string,
    page?: number,
    size?: number,
    q?: string,
    domainId?: string,
    options?: any
  ) {
    return AgentServiceApiFp(this.configuration)
      .searchAgentInQueue(id, page, size, q, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} agentId
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentServiceApi
   */
  public searchAgentInQueueStatistics(
    agentId: string,
    domainId?: string,
    options?: any
  ) {
    return AgentServiceApiFp(this.configuration)
      .searchAgentInQueueStatistics(agentId, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} id
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentServiceApi
   */
  public searchAgentInTeam(
    id: string,
    page?: number,
    size?: number,
    q?: string,
    domainId?: string,
    options?: any
  ) {
    return AgentServiceApiFp(this.configuration)
      .searchAgentInTeam(id, page, size, q, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [joinedAtFrom]
   * @param {string} [joinedAtTo]
   * @param {Array<string>} [agentId]
   * @param {string} [sort]
   * @param {string} [domainId]
   * @param {string} [fromId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentServiceApi
   */
  public searchAgentStateHistory(
    page?: number,
    size?: number,
    joinedAtFrom?: string,
    joinedAtTo?: string,
    agentId?: Array<string>,
    sort?: string,
    domainId?: string,
    fromId?: string,
    options?: any
  ) {
    return AgentServiceApiFp(this.configuration)
      .searchAgentStateHistory(
        page,
        size,
        joinedAtFrom,
        joinedAtTo,
        agentId,
        sort,
        domainId,
        fromId,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [timeFrom]
   * @param {string} [timeTo]
   * @param {string} [q]
   * @param {Array<string>} [agentId]
   * @param {Array<string>} [status]
   * @param {Array<number>} [queueId]
   * @param {Array<number>} [teamId]
   * @param {string} [utilizationFrom]
   * @param {string} [utilizationTo]
   * @param {boolean} [hasCall]
   * @param {string} [sort]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentServiceApi
   */
  public searchAgentStatusStatistic(
    page?: number,
    size?: number,
    timeFrom?: string,
    timeTo?: string,
    q?: string,
    agentId?: Array<string>,
    status?: Array<string>,
    queueId?: Array<number>,
    teamId?: Array<number>,
    utilizationFrom?: string,
    utilizationTo?: string,
    hasCall?: boolean,
    sort?: string,
    domainId?: string,
    options?: any
  ) {
    return AgentServiceApiFp(this.configuration)
      .searchAgentStatusStatistic(
        page,
        size,
        timeFrom,
        timeTo,
        q,
        agentId,
        status,
        queueId,
        teamId,
        utilizationFrom,
        utilizationTo,
        hasCall,
        sort,
        domainId,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary SearchLookupAgentNotExistsUser
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentServiceApi
   */
  public searchLookupUsersAgentNotExists(
    page?: number,
    size?: number,
    q?: string,
    domainId?: string,
    options?: any
  ) {
    return AgentServiceApiFp(this.configuration)
      .searchLookupUsersAgentNotExists(page, size, q, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update Agent
   * @param {string} id
   * @param {EngineUpdateAgentRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentServiceApi
   */
  public updateAgent(
    id: string,
    body: EngineUpdateAgentRequest,
    options?: any
  ) {
    return AgentServiceApiFp(this.configuration)
      .updateAgent(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Change agent status
   * @param {string} id
   * @param {EngineAgentStatusRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentServiceApi
   */
  public updateAgentStatus(
    id: string,
    body: EngineAgentStatusRequest,
    options?: any
  ) {
    return AgentServiceApiFp(this.configuration)
      .updateAgentStatus(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * AgentSkillServiceApi - axios parameter creator
 * @export
 */
export const AgentSkillServiceApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create AgentSkill
     * @param {string} agentId
     * @param {EngineCreateAgentSkillRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAgentSkill: async (
      agentId: string,
      body: EngineCreateAgentSkillRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'agentId' is not null or undefined
      if (agentId === null || agentId === undefined) {
        throw new RequiredError(
          'agentId',
          'Required parameter agentId was null or undefined when calling createAgentSkill.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createAgentSkill.'
        )
      }
      const localVarPath = `/call_center/agents/{agent_id}/skills`.replace(
        `{${'agent_id'}}`,
        encodeURIComponent(String(agentId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Remove AgentSkill
     * @param {string} agentId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAgentSkill: async (
      agentId: string,
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'agentId' is not null or undefined
      if (agentId === null || agentId === undefined) {
        throw new RequiredError(
          'agentId',
          'Required parameter agentId was null or undefined when calling deleteAgentSkill.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteAgentSkill.'
        )
      }
      const localVarPath = `/call_center/agents/{agent_id}/skills/{id}`
        .replace(`{${'agent_id'}}`, encodeURIComponent(String(agentId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary AgentSkill item
     * @param {string} agentId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readAgentSkill: async (
      agentId: string,
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'agentId' is not null or undefined
      if (agentId === null || agentId === undefined) {
        throw new RequiredError(
          'agentId',
          'Required parameter agentId was null or undefined when calling readAgentSkill.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readAgentSkill.'
        )
      }
      const localVarPath = `/call_center/agents/{agent_id}/skills/{id}`
        .replace(`{${'agent_id'}}`, encodeURIComponent(String(agentId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List of AgentSkill
     * @param {string} agentId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAgentSkill: async (
      agentId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'agentId' is not null or undefined
      if (agentId === null || agentId === undefined) {
        throw new RequiredError(
          'agentId',
          'Required parameter agentId was null or undefined when calling searchAgentSkill.'
        )
      }
      const localVarPath = `/call_center/agents/{agent_id}/skills`.replace(
        `{${'agent_id'}}`,
        encodeURIComponent(String(agentId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary SearchLookupAgentNotExistsSkill
     * @param {string} agentId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchLookupAgentNotExistsSkill: async (
      agentId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'agentId' is not null or undefined
      if (agentId === null || agentId === undefined) {
        throw new RequiredError(
          'agentId',
          'Required parameter agentId was null or undefined when calling searchLookupAgentNotExistsSkill.'
        )
      }
      const localVarPath = `/call_center/lookups/agents/skills/{agent_id}`.replace(
        `{${'agent_id'}}`,
        encodeURIComponent(String(agentId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update AgentSkill
     * @param {string} agentId
     * @param {string} id
     * @param {EngineUpdateAgentSkillRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAgentSkill: async (
      agentId: string,
      id: string,
      body: EngineUpdateAgentSkillRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'agentId' is not null or undefined
      if (agentId === null || agentId === undefined) {
        throw new RequiredError(
          'agentId',
          'Required parameter agentId was null or undefined when calling updateAgentSkill.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateAgentSkill.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateAgentSkill.'
        )
      }
      const localVarPath = `/call_center/agents/{agent_id}/skills/{id}`
        .replace(`{${'agent_id'}}`, encodeURIComponent(String(agentId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AgentSkillServiceApi - functional programming interface
 * @export
 */
export const AgentSkillServiceApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create AgentSkill
     * @param {string} agentId
     * @param {EngineCreateAgentSkillRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createAgentSkill(
      agentId: string,
      body: EngineCreateAgentSkillRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineAgentSkill>
    > {
      const localVarAxiosArgs = await AgentSkillServiceApiAxiosParamCreator(
        configuration
      ).createAgentSkill(agentId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Remove AgentSkill
     * @param {string} agentId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAgentSkill(
      agentId: string,
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineAgentSkill>
    > {
      const localVarAxiosArgs = await AgentSkillServiceApiAxiosParamCreator(
        configuration
      ).deleteAgentSkill(agentId, id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary AgentSkill item
     * @param {string} agentId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readAgentSkill(
      agentId: string,
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineAgentSkill>
    > {
      const localVarAxiosArgs = await AgentSkillServiceApiAxiosParamCreator(
        configuration
      ).readAgentSkill(agentId, id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List of AgentSkill
     * @param {string} agentId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchAgentSkill(
      agentId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListAgentSkill>
    > {
      const localVarAxiosArgs = await AgentSkillServiceApiAxiosParamCreator(
        configuration
      ).searchAgentSkill(agentId, page, size, q, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary SearchLookupAgentNotExistsSkill
     * @param {string} agentId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchLookupAgentNotExistsSkill(
      agentId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListSkill>
    > {
      const localVarAxiosArgs = await AgentSkillServiceApiAxiosParamCreator(
        configuration
      ).searchLookupAgentNotExistsSkill(
        agentId,
        page,
        size,
        q,
        domainId,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update AgentSkill
     * @param {string} agentId
     * @param {string} id
     * @param {EngineUpdateAgentSkillRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateAgentSkill(
      agentId: string,
      id: string,
      body: EngineUpdateAgentSkillRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineAgentSkill>
    > {
      const localVarAxiosArgs = await AgentSkillServiceApiAxiosParamCreator(
        configuration
      ).updateAgentSkill(agentId, id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * AgentSkillServiceApi - factory interface
 * @export
 */
export const AgentSkillServiceApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Create AgentSkill
     * @param {string} agentId
     * @param {EngineCreateAgentSkillRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAgentSkill(
      agentId: string,
      body: EngineCreateAgentSkillRequest,
      options?: any
    ): AxiosPromise<EngineAgentSkill> {
      return AgentSkillServiceApiFp(configuration)
        .createAgentSkill(agentId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Remove AgentSkill
     * @param {string} agentId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAgentSkill(
      agentId: string,
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineAgentSkill> {
      return AgentSkillServiceApiFp(configuration)
        .deleteAgentSkill(agentId, id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary AgentSkill item
     * @param {string} agentId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readAgentSkill(
      agentId: string,
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineAgentSkill> {
      return AgentSkillServiceApiFp(configuration)
        .readAgentSkill(agentId, id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List of AgentSkill
     * @param {string} agentId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAgentSkill(
      agentId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListAgentSkill> {
      return AgentSkillServiceApiFp(configuration)
        .searchAgentSkill(agentId, page, size, q, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary SearchLookupAgentNotExistsSkill
     * @param {string} agentId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchLookupAgentNotExistsSkill(
      agentId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListSkill> {
      return AgentSkillServiceApiFp(configuration)
        .searchLookupAgentNotExistsSkill(
          agentId,
          page,
          size,
          q,
          domainId,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update AgentSkill
     * @param {string} agentId
     * @param {string} id
     * @param {EngineUpdateAgentSkillRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAgentSkill(
      agentId: string,
      id: string,
      body: EngineUpdateAgentSkillRequest,
      options?: any
    ): AxiosPromise<EngineAgentSkill> {
      return AgentSkillServiceApiFp(configuration)
        .updateAgentSkill(agentId, id, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * AgentSkillServiceApi - object-oriented interface
 * @export
 * @class AgentSkillServiceApi
 * @extends {BaseAPI}
 */
export class AgentSkillServiceApi extends BaseAPI {
  /**
   *
   * @summary Create AgentSkill
   * @param {string} agentId
   * @param {EngineCreateAgentSkillRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentSkillServiceApi
   */
  public createAgentSkill(
    agentId: string,
    body: EngineCreateAgentSkillRequest,
    options?: any
  ) {
    return AgentSkillServiceApiFp(this.configuration)
      .createAgentSkill(agentId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Remove AgentSkill
   * @param {string} agentId
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentSkillServiceApi
   */
  public deleteAgentSkill(
    agentId: string,
    id: string,
    domainId?: string,
    options?: any
  ) {
    return AgentSkillServiceApiFp(this.configuration)
      .deleteAgentSkill(agentId, id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary AgentSkill item
   * @param {string} agentId
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentSkillServiceApi
   */
  public readAgentSkill(
    agentId: string,
    id: string,
    domainId?: string,
    options?: any
  ) {
    return AgentSkillServiceApiFp(this.configuration)
      .readAgentSkill(agentId, id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List of AgentSkill
   * @param {string} agentId
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentSkillServiceApi
   */
  public searchAgentSkill(
    agentId: string,
    page?: number,
    size?: number,
    q?: string,
    domainId?: string,
    options?: any
  ) {
    return AgentSkillServiceApiFp(this.configuration)
      .searchAgentSkill(agentId, page, size, q, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary SearchLookupAgentNotExistsSkill
   * @param {string} agentId
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentSkillServiceApi
   */
  public searchLookupAgentNotExistsSkill(
    agentId: string,
    page?: number,
    size?: number,
    q?: string,
    domainId?: string,
    options?: any
  ) {
    return AgentSkillServiceApiFp(this.configuration)
      .searchLookupAgentNotExistsSkill(
        agentId,
        page,
        size,
        q,
        domainId,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update AgentSkill
   * @param {string} agentId
   * @param {string} id
   * @param {EngineUpdateAgentSkillRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentSkillServiceApi
   */
  public updateAgentSkill(
    agentId: string,
    id: string,
    body: EngineUpdateAgentSkillRequest,
    options?: any
  ) {
    return AgentSkillServiceApiFp(this.configuration)
      .updateAgentSkill(agentId, id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * AgentTeamServiceApi - axios parameter creator
 * @export
 */
export const AgentTeamServiceApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create AgentTeam
     * @param {EngineCreateAgentTeamRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAgentTeam: async (
      body: EngineCreateAgentTeamRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createAgentTeam.'
        )
      }
      const localVarPath = `/call_center/teams`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Remove AgentTeam
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAgentTeam: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteAgentTeam.'
        )
      }
      const localVarPath = `/call_center/teams/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary AgentTeam item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readAgentTeam: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readAgentTeam.'
        )
      }
      const localVarPath = `/call_center/teams/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List of AgentTeam
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {Array<string>} [id]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAgentTeam: async (
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      fields?: Array<string>,
      sort?: string,
      id?: Array<string>,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/call_center/teams`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (id) {
        localVarQueryParameter['id'] = id
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update AgentTeam
     * @param {string} id
     * @param {EngineUpdateAgentTeamRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAgentTeam: async (
      id: string,
      body: EngineUpdateAgentTeamRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateAgentTeam.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateAgentTeam.'
        )
      }
      const localVarPath = `/call_center/teams/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AgentTeamServiceApi - functional programming interface
 * @export
 */
export const AgentTeamServiceApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create AgentTeam
     * @param {EngineCreateAgentTeamRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createAgentTeam(
      body: EngineCreateAgentTeamRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineAgentTeam>
    > {
      const localVarAxiosArgs = await AgentTeamServiceApiAxiosParamCreator(
        configuration
      ).createAgentTeam(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Remove AgentTeam
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAgentTeam(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineAgentTeam>
    > {
      const localVarAxiosArgs = await AgentTeamServiceApiAxiosParamCreator(
        configuration
      ).deleteAgentTeam(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary AgentTeam item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readAgentTeam(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineAgentTeam>
    > {
      const localVarAxiosArgs = await AgentTeamServiceApiAxiosParamCreator(
        configuration
      ).readAgentTeam(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List of AgentTeam
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {Array<string>} [id]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchAgentTeam(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      fields?: Array<string>,
      sort?: string,
      id?: Array<string>,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListAgentTeam>
    > {
      const localVarAxiosArgs = await AgentTeamServiceApiAxiosParamCreator(
        configuration
      ).searchAgentTeam(page, size, q, domainId, fields, sort, id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update AgentTeam
     * @param {string} id
     * @param {EngineUpdateAgentTeamRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateAgentTeam(
      id: string,
      body: EngineUpdateAgentTeamRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineAgentTeam>
    > {
      const localVarAxiosArgs = await AgentTeamServiceApiAxiosParamCreator(
        configuration
      ).updateAgentTeam(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * AgentTeamServiceApi - factory interface
 * @export
 */
export const AgentTeamServiceApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Create AgentTeam
     * @param {EngineCreateAgentTeamRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAgentTeam(
      body: EngineCreateAgentTeamRequest,
      options?: any
    ): AxiosPromise<EngineAgentTeam> {
      return AgentTeamServiceApiFp(configuration)
        .createAgentTeam(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Remove AgentTeam
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAgentTeam(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineAgentTeam> {
      return AgentTeamServiceApiFp(configuration)
        .deleteAgentTeam(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary AgentTeam item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readAgentTeam(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineAgentTeam> {
      return AgentTeamServiceApiFp(configuration)
        .readAgentTeam(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List of AgentTeam
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {Array<string>} [id]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAgentTeam(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      fields?: Array<string>,
      sort?: string,
      id?: Array<string>,
      options?: any
    ): AxiosPromise<EngineListAgentTeam> {
      return AgentTeamServiceApiFp(configuration)
        .searchAgentTeam(page, size, q, domainId, fields, sort, id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update AgentTeam
     * @param {string} id
     * @param {EngineUpdateAgentTeamRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAgentTeam(
      id: string,
      body: EngineUpdateAgentTeamRequest,
      options?: any
    ): AxiosPromise<EngineAgentTeam> {
      return AgentTeamServiceApiFp(configuration)
        .updateAgentTeam(id, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * AgentTeamServiceApi - object-oriented interface
 * @export
 * @class AgentTeamServiceApi
 * @extends {BaseAPI}
 */
export class AgentTeamServiceApi extends BaseAPI {
  /**
   *
   * @summary Create AgentTeam
   * @param {EngineCreateAgentTeamRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentTeamServiceApi
   */
  public createAgentTeam(body: EngineCreateAgentTeamRequest, options?: any) {
    return AgentTeamServiceApiFp(this.configuration)
      .createAgentTeam(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Remove AgentTeam
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentTeamServiceApi
   */
  public deleteAgentTeam(id: string, domainId?: string, options?: any) {
    return AgentTeamServiceApiFp(this.configuration)
      .deleteAgentTeam(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary AgentTeam item
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentTeamServiceApi
   */
  public readAgentTeam(id: string, domainId?: string, options?: any) {
    return AgentTeamServiceApiFp(this.configuration)
      .readAgentTeam(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List of AgentTeam
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [domainId]
   * @param {Array<string>} [fields]
   * @param {string} [sort]
   * @param {Array<string>} [id]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentTeamServiceApi
   */
  public searchAgentTeam(
    page?: number,
    size?: number,
    q?: string,
    domainId?: string,
    fields?: Array<string>,
    sort?: string,
    id?: Array<string>,
    options?: any
  ) {
    return AgentTeamServiceApiFp(this.configuration)
      .searchAgentTeam(page, size, q, domainId, fields, sort, id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update AgentTeam
   * @param {string} id
   * @param {EngineUpdateAgentTeamRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AgentTeamServiceApi
   */
  public updateAgentTeam(
    id: string,
    body: EngineUpdateAgentTeamRequest,
    options?: any
  ) {
    return AgentTeamServiceApiFp(this.configuration)
      .updateAgentTeam(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * BackendProfileServiceApi - axios parameter creator
 * @export
 */
export const BackendProfileServiceApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create BackendProfile
     * @param {StorageCreateBackendProfileRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBackendProfile: async (
      body: StorageCreateBackendProfileRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createBackendProfile.'
        )
      }
      const localVarPath = `/storage/backend_profiles`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Remove BackendProfile
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteBackendProfile: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteBackendProfile.'
        )
      }
      const localVarPath = `/storage/backend_profiles/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Patch BackendProfile
     * @param {string} id
     * @param {StoragePatchBackendProfileRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchBackendProfile: async (
      id: string,
      body: StoragePatchBackendProfileRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling patchBackendProfile.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling patchBackendProfile.'
        )
      }
      const localVarPath = `/storage/backend_profiles/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary BackendProfile item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readBackendProfile: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readBackendProfile.'
        )
      }
      const localVarPath = `/storage/backend_profiles/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List of BackendProfile
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchBackendProfile: async (
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/storage/backend_profiles`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update BackendProfile
     * @param {string} id
     * @param {StorageUpdateBackendProfileRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateBackendProfile: async (
      id: string,
      body: StorageUpdateBackendProfileRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateBackendProfile.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateBackendProfile.'
        )
      }
      const localVarPath = `/storage/backend_profiles/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * BackendProfileServiceApi - functional programming interface
 * @export
 */
export const BackendProfileServiceApiFp = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create BackendProfile
     * @param {StorageCreateBackendProfileRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createBackendProfile(
      body: StorageCreateBackendProfileRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<StorageBackendProfile>
    > {
      const localVarAxiosArgs = await BackendProfileServiceApiAxiosParamCreator(
        configuration
      ).createBackendProfile(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Remove BackendProfile
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteBackendProfile(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<StorageBackendProfile>
    > {
      const localVarAxiosArgs = await BackendProfileServiceApiAxiosParamCreator(
        configuration
      ).deleteBackendProfile(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Patch BackendProfile
     * @param {string} id
     * @param {StoragePatchBackendProfileRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchBackendProfile(
      id: string,
      body: StoragePatchBackendProfileRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<StorageBackendProfile>
    > {
      const localVarAxiosArgs = await BackendProfileServiceApiAxiosParamCreator(
        configuration
      ).patchBackendProfile(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary BackendProfile item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readBackendProfile(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<StorageBackendProfile>
    > {
      const localVarAxiosArgs = await BackendProfileServiceApiAxiosParamCreator(
        configuration
      ).readBackendProfile(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List of BackendProfile
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchBackendProfile(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<StorageListBackendProfile>
    > {
      const localVarAxiosArgs = await BackendProfileServiceApiAxiosParamCreator(
        configuration
      ).searchBackendProfile(page, size, q, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update BackendProfile
     * @param {string} id
     * @param {StorageUpdateBackendProfileRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateBackendProfile(
      id: string,
      body: StorageUpdateBackendProfileRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<StorageBackendProfile>
    > {
      const localVarAxiosArgs = await BackendProfileServiceApiAxiosParamCreator(
        configuration
      ).updateBackendProfile(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * BackendProfileServiceApi - factory interface
 * @export
 */
export const BackendProfileServiceApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Create BackendProfile
     * @param {StorageCreateBackendProfileRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBackendProfile(
      body: StorageCreateBackendProfileRequest,
      options?: any
    ): AxiosPromise<StorageBackendProfile> {
      return BackendProfileServiceApiFp(configuration)
        .createBackendProfile(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Remove BackendProfile
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteBackendProfile(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<StorageBackendProfile> {
      return BackendProfileServiceApiFp(configuration)
        .deleteBackendProfile(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Patch BackendProfile
     * @param {string} id
     * @param {StoragePatchBackendProfileRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchBackendProfile(
      id: string,
      body: StoragePatchBackendProfileRequest,
      options?: any
    ): AxiosPromise<StorageBackendProfile> {
      return BackendProfileServiceApiFp(configuration)
        .patchBackendProfile(id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary BackendProfile item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readBackendProfile(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<StorageBackendProfile> {
      return BackendProfileServiceApiFp(configuration)
        .readBackendProfile(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List of BackendProfile
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchBackendProfile(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<StorageListBackendProfile> {
      return BackendProfileServiceApiFp(configuration)
        .searchBackendProfile(page, size, q, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update BackendProfile
     * @param {string} id
     * @param {StorageUpdateBackendProfileRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateBackendProfile(
      id: string,
      body: StorageUpdateBackendProfileRequest,
      options?: any
    ): AxiosPromise<StorageBackendProfile> {
      return BackendProfileServiceApiFp(configuration)
        .updateBackendProfile(id, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * BackendProfileServiceApi - object-oriented interface
 * @export
 * @class BackendProfileServiceApi
 * @extends {BaseAPI}
 */
export class BackendProfileServiceApi extends BaseAPI {
  /**
   *
   * @summary Create BackendProfile
   * @param {StorageCreateBackendProfileRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BackendProfileServiceApi
   */
  public createBackendProfile(
    body: StorageCreateBackendProfileRequest,
    options?: any
  ) {
    return BackendProfileServiceApiFp(this.configuration)
      .createBackendProfile(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Remove BackendProfile
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BackendProfileServiceApi
   */
  public deleteBackendProfile(id: string, domainId?: string, options?: any) {
    return BackendProfileServiceApiFp(this.configuration)
      .deleteBackendProfile(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Patch BackendProfile
   * @param {string} id
   * @param {StoragePatchBackendProfileRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BackendProfileServiceApi
   */
  public patchBackendProfile(
    id: string,
    body: StoragePatchBackendProfileRequest,
    options?: any
  ) {
    return BackendProfileServiceApiFp(this.configuration)
      .patchBackendProfile(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary BackendProfile item
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BackendProfileServiceApi
   */
  public readBackendProfile(id: string, domainId?: string, options?: any) {
    return BackendProfileServiceApiFp(this.configuration)
      .readBackendProfile(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List of BackendProfile
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BackendProfileServiceApi
   */
  public searchBackendProfile(
    page?: number,
    size?: number,
    q?: string,
    domainId?: string,
    options?: any
  ) {
    return BackendProfileServiceApiFp(this.configuration)
      .searchBackendProfile(page, size, q, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update BackendProfile
   * @param {string} id
   * @param {StorageUpdateBackendProfileRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BackendProfileServiceApi
   */
  public updateBackendProfile(
    id: string,
    body: StorageUpdateBackendProfileRequest,
    options?: any
  ) {
    return BackendProfileServiceApiFp(this.configuration)
      .updateBackendProfile(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * BucketServiceApi - axios parameter creator
 * @export
 */
export const BucketServiceApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create Bucket
     * @param {EngineCreateBucketRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBucket: async (
      body: EngineCreateBucketRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createBucket.'
        )
      }
      const localVarPath = `/call_center/buckets`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Remove Bucket
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteBucket: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteBucket.'
        )
      }
      const localVarPath = `/call_center/buckets/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Bucket item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readBucket: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readBucket.'
        )
      }
      const localVarPath = `/call_center/buckets/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List of Bucket
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchBucket: async (
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/call_center/buckets`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update Bucket
     * @param {string} id
     * @param {EngineUpdateBucketRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateBucket: async (
      id: string,
      body: EngineUpdateBucketRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateBucket.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateBucket.'
        )
      }
      const localVarPath = `/call_center/buckets/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * BucketServiceApi - functional programming interface
 * @export
 */
export const BucketServiceApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create Bucket
     * @param {EngineCreateBucketRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createBucket(
      body: EngineCreateBucketRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineBucket>
    > {
      const localVarAxiosArgs = await BucketServiceApiAxiosParamCreator(
        configuration
      ).createBucket(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Remove Bucket
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteBucket(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineBucket>
    > {
      const localVarAxiosArgs = await BucketServiceApiAxiosParamCreator(
        configuration
      ).deleteBucket(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Bucket item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readBucket(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineBucket>
    > {
      const localVarAxiosArgs = await BucketServiceApiAxiosParamCreator(
        configuration
      ).readBucket(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List of Bucket
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchBucket(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListBucket>
    > {
      const localVarAxiosArgs = await BucketServiceApiAxiosParamCreator(
        configuration
      ).searchBucket(page, size, q, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update Bucket
     * @param {string} id
     * @param {EngineUpdateBucketRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateBucket(
      id: string,
      body: EngineUpdateBucketRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineBucket>
    > {
      const localVarAxiosArgs = await BucketServiceApiAxiosParamCreator(
        configuration
      ).updateBucket(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * BucketServiceApi - factory interface
 * @export
 */
export const BucketServiceApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Create Bucket
     * @param {EngineCreateBucketRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBucket(
      body: EngineCreateBucketRequest,
      options?: any
    ): AxiosPromise<EngineBucket> {
      return BucketServiceApiFp(configuration)
        .createBucket(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Remove Bucket
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteBucket(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineBucket> {
      return BucketServiceApiFp(configuration)
        .deleteBucket(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Bucket item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readBucket(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineBucket> {
      return BucketServiceApiFp(configuration)
        .readBucket(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List of Bucket
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchBucket(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListBucket> {
      return BucketServiceApiFp(configuration)
        .searchBucket(page, size, q, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update Bucket
     * @param {string} id
     * @param {EngineUpdateBucketRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateBucket(
      id: string,
      body: EngineUpdateBucketRequest,
      options?: any
    ): AxiosPromise<EngineBucket> {
      return BucketServiceApiFp(configuration)
        .updateBucket(id, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * BucketServiceApi - object-oriented interface
 * @export
 * @class BucketServiceApi
 * @extends {BaseAPI}
 */
export class BucketServiceApi extends BaseAPI {
  /**
   *
   * @summary Create Bucket
   * @param {EngineCreateBucketRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BucketServiceApi
   */
  public createBucket(body: EngineCreateBucketRequest, options?: any) {
    return BucketServiceApiFp(this.configuration)
      .createBucket(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Remove Bucket
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BucketServiceApi
   */
  public deleteBucket(id: string, domainId?: string, options?: any) {
    return BucketServiceApiFp(this.configuration)
      .deleteBucket(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Bucket item
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BucketServiceApi
   */
  public readBucket(id: string, domainId?: string, options?: any) {
    return BucketServiceApiFp(this.configuration)
      .readBucket(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List of Bucket
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BucketServiceApi
   */
  public searchBucket(
    page?: number,
    size?: number,
    q?: string,
    domainId?: string,
    options?: any
  ) {
    return BucketServiceApiFp(this.configuration)
      .searchBucket(page, size, q, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update Bucket
   * @param {string} id
   * @param {EngineUpdateBucketRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BucketServiceApi
   */
  public updateBucket(
    id: string,
    body: EngineUpdateBucketRequest,
    options?: any
  ) {
    return BucketServiceApiFp(this.configuration)
      .updateBucket(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * CalendarServiceApi - axios parameter creator
 * @export
 */
export const CalendarServiceApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create calendar
     * @param {EngineCreateCalendarRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCalendar: async (
      body: EngineCreateCalendarRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createCalendar.'
        )
      }
      const localVarPath = `/calendars`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Remove calendar
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCalendar: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteCalendar.'
        )
      }
      const localVarPath = `/calendars/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Calendar item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readCalendar: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readCalendar.'
        )
      }
      const localVarPath = `/calendars/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List of calendar
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchCalendar: async (
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/calendars`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List timezones
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchTimezones: async (
      page?: number,
      size?: number,
      q?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/calendars/timezones`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update calendar
     * @param {string} id
     * @param {EngineUpdateCalendarRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCalendar: async (
      id: string,
      body: EngineUpdateCalendarRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateCalendar.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateCalendar.'
        )
      }
      const localVarPath = `/calendars/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * CalendarServiceApi - functional programming interface
 * @export
 */
export const CalendarServiceApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create calendar
     * @param {EngineCreateCalendarRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createCalendar(
      body: EngineCreateCalendarRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineCalendar>
    > {
      const localVarAxiosArgs = await CalendarServiceApiAxiosParamCreator(
        configuration
      ).createCalendar(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Remove calendar
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteCalendar(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineCalendar>
    > {
      const localVarAxiosArgs = await CalendarServiceApiAxiosParamCreator(
        configuration
      ).deleteCalendar(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Calendar item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readCalendar(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineCalendar>
    > {
      const localVarAxiosArgs = await CalendarServiceApiAxiosParamCreator(
        configuration
      ).readCalendar(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List of calendar
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchCalendar(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListCalendar>
    > {
      const localVarAxiosArgs = await CalendarServiceApiAxiosParamCreator(
        configuration
      ).searchCalendar(page, size, q, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List timezones
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchTimezones(
      page?: number,
      size?: number,
      q?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListTimezoneResponse>
    > {
      const localVarAxiosArgs = await CalendarServiceApiAxiosParamCreator(
        configuration
      ).searchTimezones(page, size, q, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update calendar
     * @param {string} id
     * @param {EngineUpdateCalendarRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateCalendar(
      id: string,
      body: EngineUpdateCalendarRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineCalendar>
    > {
      const localVarAxiosArgs = await CalendarServiceApiAxiosParamCreator(
        configuration
      ).updateCalendar(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * CalendarServiceApi - factory interface
 * @export
 */
export const CalendarServiceApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Create calendar
     * @param {EngineCreateCalendarRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCalendar(
      body: EngineCreateCalendarRequest,
      options?: any
    ): AxiosPromise<EngineCalendar> {
      return CalendarServiceApiFp(configuration)
        .createCalendar(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Remove calendar
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCalendar(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineCalendar> {
      return CalendarServiceApiFp(configuration)
        .deleteCalendar(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Calendar item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readCalendar(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineCalendar> {
      return CalendarServiceApiFp(configuration)
        .readCalendar(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List of calendar
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchCalendar(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListCalendar> {
      return CalendarServiceApiFp(configuration)
        .searchCalendar(page, size, q, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List timezones
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchTimezones(
      page?: number,
      size?: number,
      q?: string,
      options?: any
    ): AxiosPromise<EngineListTimezoneResponse> {
      return CalendarServiceApiFp(configuration)
        .searchTimezones(page, size, q, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update calendar
     * @param {string} id
     * @param {EngineUpdateCalendarRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCalendar(
      id: string,
      body: EngineUpdateCalendarRequest,
      options?: any
    ): AxiosPromise<EngineCalendar> {
      return CalendarServiceApiFp(configuration)
        .updateCalendar(id, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * CalendarServiceApi - object-oriented interface
 * @export
 * @class CalendarServiceApi
 * @extends {BaseAPI}
 */
export class CalendarServiceApi extends BaseAPI {
  /**
   *
   * @summary Create calendar
   * @param {EngineCreateCalendarRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CalendarServiceApi
   */
  public createCalendar(body: EngineCreateCalendarRequest, options?: any) {
    return CalendarServiceApiFp(this.configuration)
      .createCalendar(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Remove calendar
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CalendarServiceApi
   */
  public deleteCalendar(id: string, domainId?: string, options?: any) {
    return CalendarServiceApiFp(this.configuration)
      .deleteCalendar(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Calendar item
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CalendarServiceApi
   */
  public readCalendar(id: string, domainId?: string, options?: any) {
    return CalendarServiceApiFp(this.configuration)
      .readCalendar(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List of calendar
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CalendarServiceApi
   */
  public searchCalendar(
    page?: number,
    size?: number,
    q?: string,
    domainId?: string,
    options?: any
  ) {
    return CalendarServiceApiFp(this.configuration)
      .searchCalendar(page, size, q, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List timezones
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CalendarServiceApi
   */
  public searchTimezones(
    page?: number,
    size?: number,
    q?: string,
    options?: any
  ) {
    return CalendarServiceApiFp(this.configuration)
      .searchTimezones(page, size, q, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update calendar
   * @param {string} id
   * @param {EngineUpdateCalendarRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CalendarServiceApi
   */
  public updateCalendar(
    id: string,
    body: EngineUpdateCalendarRequest,
    options?: any
  ) {
    return CalendarServiceApiFp(this.configuration)
      .updateCalendar(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * CallServiceApi - axios parameter creator
 * @export
 */
export const CallServiceApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {string} id
     * @param {EngineBlindTransferCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blindTransferCall: async (
      id: string,
      body: EngineBlindTransferCallRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling blindTransferCall.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling blindTransferCall.'
        )
      }
      const localVarPath = `/calls/active/{id}/transfer`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create e call
     * @param {EngineCreateCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCall: async (
      body: EngineCreateCallRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createCall.'
        )
      }
      const localVarPath = `/calls`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineDtmfCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dtmfCall: async (
      id: string,
      body: EngineDtmfCallRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling dtmfCall.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling dtmfCall.'
        )
      }
      const localVarPath = `/calls/active/{id}/dtmf`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineEavesdropCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eavesdropCall: async (
      id: string,
      body: EngineEavesdropCallRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling eavesdropCall.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling eavesdropCall.'
        )
      }
      const localVarPath = `/calls/active/{id}/eavesdrop`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineHangupCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hangupCall: async (
      id: string,
      body: EngineHangupCallRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling hangupCall.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling hangupCall.'
        )
      }
      const localVarPath = `/calls/active/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineUserCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    holdCall: async (
      id: string,
      body: EngineUserCallRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling holdCall.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling holdCall.'
        )
      }
      const localVarPath = `/calls/active/{id}/hold`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Call item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readCall: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readCall.'
        )
      }
      const localVarPath = `/calls/active/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [createdAtFrom]
     * @param {string} [createdAtTo]
     * @param {Array<string>} [userId]
     * @param {Array<string>} [agentId]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [teamId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [gatewayId]
     * @param {string} [q]
     * @param {string} [durationFrom]
     * @param {string} [durationTo]
     * @param {boolean} [skipParent]
     * @param {string} [parentId]
     * @param {string} [cause]
     * @param {boolean} [existsFile]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {string} [domainId]
     * @param {string} [number]
     * @param {Array<string>} [direction]
     * @param {string} [answeredAtFrom]
     * @param {string} [answeredAtTo]
     * @param {boolean} [missed]
     * @param {string} [storedAtFrom]
     * @param {string} [storedAtTo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchActiveCall: async (
      page?: number,
      size?: number,
      createdAtFrom?: string,
      createdAtTo?: string,
      userId?: Array<string>,
      agentId?: Array<string>,
      queueId?: Array<string>,
      teamId?: Array<string>,
      memberId?: Array<string>,
      gatewayId?: Array<string>,
      q?: string,
      durationFrom?: string,
      durationTo?: string,
      skipParent?: boolean,
      parentId?: string,
      cause?: string,
      existsFile?: boolean,
      fields?: Array<string>,
      sort?: string,
      domainId?: string,
      number?: string,
      direction?: Array<string>,
      answeredAtFrom?: string,
      answeredAtTo?: string,
      missed?: boolean,
      storedAtFrom?: string,
      storedAtTo?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/calls/active`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (createdAtFrom !== undefined) {
        localVarQueryParameter['created_at.from'] = createdAtFrom
      }

      if (createdAtTo !== undefined) {
        localVarQueryParameter['created_at.to'] = createdAtTo
      }

      if (userId) {
        localVarQueryParameter['user_id'] = userId
      }

      if (agentId) {
        localVarQueryParameter['agent_id'] = agentId
      }

      if (queueId) {
        localVarQueryParameter['queue_id'] = queueId
      }

      if (teamId) {
        localVarQueryParameter['team_id'] = teamId
      }

      if (memberId) {
        localVarQueryParameter['member_id'] = memberId
      }

      if (gatewayId) {
        localVarQueryParameter['gateway_id'] = gatewayId
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (durationFrom !== undefined) {
        localVarQueryParameter['duration.from'] = durationFrom
      }

      if (durationTo !== undefined) {
        localVarQueryParameter['duration.to'] = durationTo
      }

      if (skipParent !== undefined) {
        localVarQueryParameter['skip_parent'] = skipParent
      }

      if (parentId !== undefined) {
        localVarQueryParameter['parent_id'] = parentId
      }

      if (cause !== undefined) {
        localVarQueryParameter['cause'] = cause
      }

      if (existsFile !== undefined) {
        localVarQueryParameter['exists_file'] = existsFile
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      if (number !== undefined) {
        localVarQueryParameter['number'] = number
      }

      if (direction) {
        localVarQueryParameter['direction'] = direction
      }

      if (answeredAtFrom !== undefined) {
        localVarQueryParameter['answered_at.from'] = answeredAtFrom
      }

      if (answeredAtTo !== undefined) {
        localVarQueryParameter['answered_at.to'] = answeredAtTo
      }

      if (missed !== undefined) {
        localVarQueryParameter['missed'] = missed
      }

      if (storedAtFrom !== undefined) {
        localVarQueryParameter['stored_at.from'] = storedAtFrom
      }

      if (storedAtTo !== undefined) {
        localVarQueryParameter['stored_at.to'] = storedAtTo
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List of call
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [createdAtFrom]
     * @param {string} [createdAtTo]
     * @param {Array<string>} [userId]
     * @param {Array<string>} [agentId]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [teamId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [gatewayId]
     * @param {string} [q]
     * @param {string} [durationFrom]
     * @param {string} [durationTo]
     * @param {boolean} [skipParent]
     * @param {string} [parentId]
     * @param {string} [cause]
     * @param {boolean} [hasFile]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {string} [domainId]
     * @param {string} [number]
     * @param {string} [direction]
     * @param {string} [answeredAtFrom]
     * @param {string} [answeredAtTo]
     * @param {boolean} [missed]
     * @param {string} [storedAtFrom]
     * @param {string} [storedAtTo]
     * @param {Array<string>} [id]
     * @param {Array<string>} [transferFrom]
     * @param {Array<string>} [transferTo]
     * @param {Array<string>} [dependencyId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchHistoryCall: async (
      page?: number,
      size?: number,
      createdAtFrom?: string,
      createdAtTo?: string,
      userId?: Array<string>,
      agentId?: Array<string>,
      queueId?: Array<string>,
      teamId?: Array<string>,
      memberId?: Array<string>,
      gatewayId?: Array<string>,
      q?: string,
      durationFrom?: string,
      durationTo?: string,
      skipParent?: boolean,
      parentId?: string,
      cause?: string,
      hasFile?: boolean,
      fields?: Array<string>,
      sort?: string,
      domainId?: string,
      number?: string,
      direction?: string,
      answeredAtFrom?: string,
      answeredAtTo?: string,
      missed?: boolean,
      storedAtFrom?: string,
      storedAtTo?: string,
      id?: Array<string>,
      transferFrom?: Array<string>,
      transferTo?: Array<string>,
      dependencyId?: Array<string>,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/calls/history`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (createdAtFrom !== undefined) {
        localVarQueryParameter['created_at.from'] = createdAtFrom
      }

      if (createdAtTo !== undefined) {
        localVarQueryParameter['created_at.to'] = createdAtTo
      }

      if (userId) {
        localVarQueryParameter['user_id'] = userId
      }

      if (agentId) {
        localVarQueryParameter['agent_id'] = agentId
      }

      if (queueId) {
        localVarQueryParameter['queue_id'] = queueId
      }

      if (teamId) {
        localVarQueryParameter['team_id'] = teamId
      }

      if (memberId) {
        localVarQueryParameter['member_id'] = memberId
      }

      if (gatewayId) {
        localVarQueryParameter['gateway_id'] = gatewayId
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (durationFrom !== undefined) {
        localVarQueryParameter['duration.from'] = durationFrom
      }

      if (durationTo !== undefined) {
        localVarQueryParameter['duration.to'] = durationTo
      }

      if (skipParent !== undefined) {
        localVarQueryParameter['skip_parent'] = skipParent
      }

      if (parentId !== undefined) {
        localVarQueryParameter['parent_id'] = parentId
      }

      if (cause !== undefined) {
        localVarQueryParameter['cause'] = cause
      }

      if (hasFile !== undefined) {
        localVarQueryParameter['has_file'] = hasFile
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      if (number !== undefined) {
        localVarQueryParameter['number'] = number
      }

      if (direction !== undefined) {
        localVarQueryParameter['direction'] = direction
      }

      if (answeredAtFrom !== undefined) {
        localVarQueryParameter['answered_at.from'] = answeredAtFrom
      }

      if (answeredAtTo !== undefined) {
        localVarQueryParameter['answered_at.to'] = answeredAtTo
      }

      if (missed !== undefined) {
        localVarQueryParameter['missed'] = missed
      }

      if (storedAtFrom !== undefined) {
        localVarQueryParameter['stored_at.from'] = storedAtFrom
      }

      if (storedAtTo !== undefined) {
        localVarQueryParameter['stored_at.to'] = storedAtTo
      }

      if (id) {
        localVarQueryParameter['id'] = id
      }

      if (transferFrom) {
        localVarQueryParameter['transfer_from'] = transferFrom
      }

      if (transferTo) {
        localVarQueryParameter['transfer_to'] = transferTo
      }

      if (dependencyId) {
        localVarQueryParameter['dependency_id'] = dependencyId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineUserCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unHoldCall: async (
      id: string,
      body: EngineUserCallRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling unHoldCall.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling unHoldCall.'
        )
      }
      const localVarPath = `/calls/active/{id}/unhold`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * CallServiceApi - functional programming interface
 * @export
 */
export const CallServiceApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} id
     * @param {EngineBlindTransferCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async blindTransferCall(
      id: string,
      body: EngineBlindTransferCallRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).blindTransferCall(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create e call
     * @param {EngineCreateCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createCall(
      body: EngineCreateCallRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineCreateCallResponse>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).createCall(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineDtmfCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async dtmfCall(
      id: string,
      body: EngineDtmfCallRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).dtmfCall(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineEavesdropCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eavesdropCall(
      id: string,
      body: EngineEavesdropCallRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineCreateCallResponse>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).eavesdropCall(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineHangupCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async hangupCall(
      id: string,
      body: EngineHangupCallRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).hangupCall(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineUserCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async holdCall(
      id: string,
      body: EngineUserCallRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineHoldCallResponse>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).holdCall(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Call item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readCall(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineActiveCall>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).readCall(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [createdAtFrom]
     * @param {string} [createdAtTo]
     * @param {Array<string>} [userId]
     * @param {Array<string>} [agentId]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [teamId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [gatewayId]
     * @param {string} [q]
     * @param {string} [durationFrom]
     * @param {string} [durationTo]
     * @param {boolean} [skipParent]
     * @param {string} [parentId]
     * @param {string} [cause]
     * @param {boolean} [existsFile]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {string} [domainId]
     * @param {string} [number]
     * @param {Array<string>} [direction]
     * @param {string} [answeredAtFrom]
     * @param {string} [answeredAtTo]
     * @param {boolean} [missed]
     * @param {string} [storedAtFrom]
     * @param {string} [storedAtTo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchActiveCall(
      page?: number,
      size?: number,
      createdAtFrom?: string,
      createdAtTo?: string,
      userId?: Array<string>,
      agentId?: Array<string>,
      queueId?: Array<string>,
      teamId?: Array<string>,
      memberId?: Array<string>,
      gatewayId?: Array<string>,
      q?: string,
      durationFrom?: string,
      durationTo?: string,
      skipParent?: boolean,
      parentId?: string,
      cause?: string,
      existsFile?: boolean,
      fields?: Array<string>,
      sort?: string,
      domainId?: string,
      number?: string,
      direction?: Array<string>,
      answeredAtFrom?: string,
      answeredAtTo?: string,
      missed?: boolean,
      storedAtFrom?: string,
      storedAtTo?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineListCall>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).searchActiveCall(
        page,
        size,
        createdAtFrom,
        createdAtTo,
        userId,
        agentId,
        queueId,
        teamId,
        memberId,
        gatewayId,
        q,
        durationFrom,
        durationTo,
        skipParent,
        parentId,
        cause,
        existsFile,
        fields,
        sort,
        domainId,
        number,
        direction,
        answeredAtFrom,
        answeredAtTo,
        missed,
        storedAtFrom,
        storedAtTo,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List of call
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [createdAtFrom]
     * @param {string} [createdAtTo]
     * @param {Array<string>} [userId]
     * @param {Array<string>} [agentId]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [teamId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [gatewayId]
     * @param {string} [q]
     * @param {string} [durationFrom]
     * @param {string} [durationTo]
     * @param {boolean} [skipParent]
     * @param {string} [parentId]
     * @param {string} [cause]
     * @param {boolean} [hasFile]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {string} [domainId]
     * @param {string} [number]
     * @param {string} [direction]
     * @param {string} [answeredAtFrom]
     * @param {string} [answeredAtTo]
     * @param {boolean} [missed]
     * @param {string} [storedAtFrom]
     * @param {string} [storedAtTo]
     * @param {Array<string>} [id]
     * @param {Array<string>} [transferFrom]
     * @param {Array<string>} [transferTo]
     * @param {Array<string>} [dependencyId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchHistoryCall(
      page?: number,
      size?: number,
      createdAtFrom?: string,
      createdAtTo?: string,
      userId?: Array<string>,
      agentId?: Array<string>,
      queueId?: Array<string>,
      teamId?: Array<string>,
      memberId?: Array<string>,
      gatewayId?: Array<string>,
      q?: string,
      durationFrom?: string,
      durationTo?: string,
      skipParent?: boolean,
      parentId?: string,
      cause?: string,
      hasFile?: boolean,
      fields?: Array<string>,
      sort?: string,
      domainId?: string,
      number?: string,
      direction?: string,
      answeredAtFrom?: string,
      answeredAtTo?: string,
      missed?: boolean,
      storedAtFrom?: string,
      storedAtTo?: string,
      id?: Array<string>,
      transferFrom?: Array<string>,
      transferTo?: Array<string>,
      dependencyId?: Array<string>,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListHistoryCall>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).searchHistoryCall(
        page,
        size,
        createdAtFrom,
        createdAtTo,
        userId,
        agentId,
        queueId,
        teamId,
        memberId,
        gatewayId,
        q,
        durationFrom,
        durationTo,
        skipParent,
        parentId,
        cause,
        hasFile,
        fields,
        sort,
        domainId,
        number,
        direction,
        answeredAtFrom,
        answeredAtTo,
        missed,
        storedAtFrom,
        storedAtTo,
        id,
        transferFrom,
        transferTo,
        dependencyId,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {string} id
     * @param {EngineUserCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unHoldCall(
      id: string,
      body: EngineUserCallRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineHoldCallResponse>
    > {
      const localVarAxiosArgs = await CallServiceApiAxiosParamCreator(
        configuration
      ).unHoldCall(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * CallServiceApi - factory interface
 * @export
 */
export const CallServiceApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @param {string} id
     * @param {EngineBlindTransferCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    blindTransferCall(
      id: string,
      body: EngineBlindTransferCallRequest,
      options?: any
    ): AxiosPromise<object> {
      return CallServiceApiFp(configuration)
        .blindTransferCall(id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create e call
     * @param {EngineCreateCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCall(
      body: EngineCreateCallRequest,
      options?: any
    ): AxiosPromise<EngineCreateCallResponse> {
      return CallServiceApiFp(configuration)
        .createCall(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} id
     * @param {EngineDtmfCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    dtmfCall(
      id: string,
      body: EngineDtmfCallRequest,
      options?: any
    ): AxiosPromise<object> {
      return CallServiceApiFp(configuration)
        .dtmfCall(id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} id
     * @param {EngineEavesdropCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eavesdropCall(
      id: string,
      body: EngineEavesdropCallRequest,
      options?: any
    ): AxiosPromise<EngineCreateCallResponse> {
      return CallServiceApiFp(configuration)
        .eavesdropCall(id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} id
     * @param {EngineHangupCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hangupCall(
      id: string,
      body: EngineHangupCallRequest,
      options?: any
    ): AxiosPromise<object> {
      return CallServiceApiFp(configuration)
        .hangupCall(id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} id
     * @param {EngineUserCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    holdCall(
      id: string,
      body: EngineUserCallRequest,
      options?: any
    ): AxiosPromise<EngineHoldCallResponse> {
      return CallServiceApiFp(configuration)
        .holdCall(id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Call item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readCall(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineActiveCall> {
      return CallServiceApiFp(configuration)
        .readCall(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [createdAtFrom]
     * @param {string} [createdAtTo]
     * @param {Array<string>} [userId]
     * @param {Array<string>} [agentId]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [teamId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [gatewayId]
     * @param {string} [q]
     * @param {string} [durationFrom]
     * @param {string} [durationTo]
     * @param {boolean} [skipParent]
     * @param {string} [parentId]
     * @param {string} [cause]
     * @param {boolean} [existsFile]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {string} [domainId]
     * @param {string} [number]
     * @param {Array<string>} [direction]
     * @param {string} [answeredAtFrom]
     * @param {string} [answeredAtTo]
     * @param {boolean} [missed]
     * @param {string} [storedAtFrom]
     * @param {string} [storedAtTo]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchActiveCall(
      page?: number,
      size?: number,
      createdAtFrom?: string,
      createdAtTo?: string,
      userId?: Array<string>,
      agentId?: Array<string>,
      queueId?: Array<string>,
      teamId?: Array<string>,
      memberId?: Array<string>,
      gatewayId?: Array<string>,
      q?: string,
      durationFrom?: string,
      durationTo?: string,
      skipParent?: boolean,
      parentId?: string,
      cause?: string,
      existsFile?: boolean,
      fields?: Array<string>,
      sort?: string,
      domainId?: string,
      number?: string,
      direction?: Array<string>,
      answeredAtFrom?: string,
      answeredAtTo?: string,
      missed?: boolean,
      storedAtFrom?: string,
      storedAtTo?: string,
      options?: any
    ): AxiosPromise<EngineListCall> {
      return CallServiceApiFp(configuration)
        .searchActiveCall(
          page,
          size,
          createdAtFrom,
          createdAtTo,
          userId,
          agentId,
          queueId,
          teamId,
          memberId,
          gatewayId,
          q,
          durationFrom,
          durationTo,
          skipParent,
          parentId,
          cause,
          existsFile,
          fields,
          sort,
          domainId,
          number,
          direction,
          answeredAtFrom,
          answeredAtTo,
          missed,
          storedAtFrom,
          storedAtTo,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List of call
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [createdAtFrom]
     * @param {string} [createdAtTo]
     * @param {Array<string>} [userId]
     * @param {Array<string>} [agentId]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [teamId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [gatewayId]
     * @param {string} [q]
     * @param {string} [durationFrom]
     * @param {string} [durationTo]
     * @param {boolean} [skipParent]
     * @param {string} [parentId]
     * @param {string} [cause]
     * @param {boolean} [hasFile]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {string} [domainId]
     * @param {string} [number]
     * @param {string} [direction]
     * @param {string} [answeredAtFrom]
     * @param {string} [answeredAtTo]
     * @param {boolean} [missed]
     * @param {string} [storedAtFrom]
     * @param {string} [storedAtTo]
     * @param {Array<string>} [id]
     * @param {Array<string>} [transferFrom]
     * @param {Array<string>} [transferTo]
     * @param {Array<string>} [dependencyId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchHistoryCall(
      page?: number,
      size?: number,
      createdAtFrom?: string,
      createdAtTo?: string,
      userId?: Array<string>,
      agentId?: Array<string>,
      queueId?: Array<string>,
      teamId?: Array<string>,
      memberId?: Array<string>,
      gatewayId?: Array<string>,
      q?: string,
      durationFrom?: string,
      durationTo?: string,
      skipParent?: boolean,
      parentId?: string,
      cause?: string,
      hasFile?: boolean,
      fields?: Array<string>,
      sort?: string,
      domainId?: string,
      number?: string,
      direction?: string,
      answeredAtFrom?: string,
      answeredAtTo?: string,
      missed?: boolean,
      storedAtFrom?: string,
      storedAtTo?: string,
      id?: Array<string>,
      transferFrom?: Array<string>,
      transferTo?: Array<string>,
      dependencyId?: Array<string>,
      options?: any
    ): AxiosPromise<EngineListHistoryCall> {
      return CallServiceApiFp(configuration)
        .searchHistoryCall(
          page,
          size,
          createdAtFrom,
          createdAtTo,
          userId,
          agentId,
          queueId,
          teamId,
          memberId,
          gatewayId,
          q,
          durationFrom,
          durationTo,
          skipParent,
          parentId,
          cause,
          hasFile,
          fields,
          sort,
          domainId,
          number,
          direction,
          answeredAtFrom,
          answeredAtTo,
          missed,
          storedAtFrom,
          storedAtTo,
          id,
          transferFrom,
          transferTo,
          dependencyId,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {string} id
     * @param {EngineUserCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unHoldCall(
      id: string,
      body: EngineUserCallRequest,
      options?: any
    ): AxiosPromise<EngineHoldCallResponse> {
      return CallServiceApiFp(configuration)
        .unHoldCall(id, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * CallServiceApi - object-oriented interface
 * @export
 * @class CallServiceApi
 * @extends {BaseAPI}
 */
export class CallServiceApi extends BaseAPI {
  /**
   *
   * @param {string} id
   * @param {EngineBlindTransferCallRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public blindTransferCall(
    id: string,
    body: EngineBlindTransferCallRequest,
    options?: any
  ) {
    return CallServiceApiFp(this.configuration)
      .blindTransferCall(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create e call
   * @param {EngineCreateCallRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public createCall(body: EngineCreateCallRequest, options?: any) {
    return CallServiceApiFp(this.configuration)
      .createCall(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} id
   * @param {EngineDtmfCallRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public dtmfCall(id: string, body: EngineDtmfCallRequest, options?: any) {
    return CallServiceApiFp(this.configuration)
      .dtmfCall(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} id
   * @param {EngineEavesdropCallRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public eavesdropCall(
    id: string,
    body: EngineEavesdropCallRequest,
    options?: any
  ) {
    return CallServiceApiFp(this.configuration)
      .eavesdropCall(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} id
   * @param {EngineHangupCallRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public hangupCall(id: string, body: EngineHangupCallRequest, options?: any) {
    return CallServiceApiFp(this.configuration)
      .hangupCall(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} id
   * @param {EngineUserCallRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public holdCall(id: string, body: EngineUserCallRequest, options?: any) {
    return CallServiceApiFp(this.configuration)
      .holdCall(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Call item
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public readCall(id: string, domainId?: string, options?: any) {
    return CallServiceApiFp(this.configuration)
      .readCall(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [createdAtFrom]
   * @param {string} [createdAtTo]
   * @param {Array<string>} [userId]
   * @param {Array<string>} [agentId]
   * @param {Array<string>} [queueId]
   * @param {Array<string>} [teamId]
   * @param {Array<string>} [memberId]
   * @param {Array<string>} [gatewayId]
   * @param {string} [q]
   * @param {string} [durationFrom]
   * @param {string} [durationTo]
   * @param {boolean} [skipParent]
   * @param {string} [parentId]
   * @param {string} [cause]
   * @param {boolean} [existsFile]
   * @param {Array<string>} [fields]
   * @param {string} [sort]
   * @param {string} [domainId]
   * @param {string} [number]
   * @param {Array<string>} [direction]
   * @param {string} [answeredAtFrom]
   * @param {string} [answeredAtTo]
   * @param {boolean} [missed]
   * @param {string} [storedAtFrom]
   * @param {string} [storedAtTo]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public searchActiveCall(
    page?: number,
    size?: number,
    createdAtFrom?: string,
    createdAtTo?: string,
    userId?: Array<string>,
    agentId?: Array<string>,
    queueId?: Array<string>,
    teamId?: Array<string>,
    memberId?: Array<string>,
    gatewayId?: Array<string>,
    q?: string,
    durationFrom?: string,
    durationTo?: string,
    skipParent?: boolean,
    parentId?: string,
    cause?: string,
    existsFile?: boolean,
    fields?: Array<string>,
    sort?: string,
    domainId?: string,
    number?: string,
    direction?: Array<string>,
    answeredAtFrom?: string,
    answeredAtTo?: string,
    missed?: boolean,
    storedAtFrom?: string,
    storedAtTo?: string,
    options?: any
  ) {
    return CallServiceApiFp(this.configuration)
      .searchActiveCall(
        page,
        size,
        createdAtFrom,
        createdAtTo,
        userId,
        agentId,
        queueId,
        teamId,
        memberId,
        gatewayId,
        q,
        durationFrom,
        durationTo,
        skipParent,
        parentId,
        cause,
        existsFile,
        fields,
        sort,
        domainId,
        number,
        direction,
        answeredAtFrom,
        answeredAtTo,
        missed,
        storedAtFrom,
        storedAtTo,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List of call
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [createdAtFrom]
   * @param {string} [createdAtTo]
   * @param {Array<string>} [userId]
   * @param {Array<string>} [agentId]
   * @param {Array<string>} [queueId]
   * @param {Array<string>} [teamId]
   * @param {Array<string>} [memberId]
   * @param {Array<string>} [gatewayId]
   * @param {string} [q]
   * @param {string} [durationFrom]
   * @param {string} [durationTo]
   * @param {boolean} [skipParent]
   * @param {string} [parentId]
   * @param {string} [cause]
   * @param {boolean} [hasFile]
   * @param {Array<string>} [fields]
   * @param {string} [sort]
   * @param {string} [domainId]
   * @param {string} [number]
   * @param {string} [direction]
   * @param {string} [answeredAtFrom]
   * @param {string} [answeredAtTo]
   * @param {boolean} [missed]
   * @param {string} [storedAtFrom]
   * @param {string} [storedAtTo]
   * @param {Array<string>} [id]
   * @param {Array<string>} [transferFrom]
   * @param {Array<string>} [transferTo]
   * @param {Array<string>} [dependencyId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public searchHistoryCall(
    page?: number,
    size?: number,
    createdAtFrom?: string,
    createdAtTo?: string,
    userId?: Array<string>,
    agentId?: Array<string>,
    queueId?: Array<string>,
    teamId?: Array<string>,
    memberId?: Array<string>,
    gatewayId?: Array<string>,
    q?: string,
    durationFrom?: string,
    durationTo?: string,
    skipParent?: boolean,
    parentId?: string,
    cause?: string,
    hasFile?: boolean,
    fields?: Array<string>,
    sort?: string,
    domainId?: string,
    number?: string,
    direction?: string,
    answeredAtFrom?: string,
    answeredAtTo?: string,
    missed?: boolean,
    storedAtFrom?: string,
    storedAtTo?: string,
    id?: Array<string>,
    transferFrom?: Array<string>,
    transferTo?: Array<string>,
    dependencyId?: Array<string>,
    options?: any
  ) {
    return CallServiceApiFp(this.configuration)
      .searchHistoryCall(
        page,
        size,
        createdAtFrom,
        createdAtTo,
        userId,
        agentId,
        queueId,
        teamId,
        memberId,
        gatewayId,
        q,
        durationFrom,
        durationTo,
        skipParent,
        parentId,
        cause,
        hasFile,
        fields,
        sort,
        domainId,
        number,
        direction,
        answeredAtFrom,
        answeredAtTo,
        missed,
        storedAtFrom,
        storedAtTo,
        id,
        transferFrom,
        transferTo,
        dependencyId,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} id
   * @param {EngineUserCallRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CallServiceApi
   */
  public unHoldCall(id: string, body: EngineUserCallRequest, options?: any) {
    return CallServiceApiFp(this.configuration)
      .unHoldCall(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * CommunicationTypeServiceApi - axios parameter creator
 * @export
 */
export const CommunicationTypeServiceApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create CommunicationType
     * @param {EngineCommunicationTypeRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCommunicationType: async (
      body: EngineCommunicationTypeRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createCommunicationType.'
        )
      }
      const localVarPath = `/call_center/communication_type`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Remove CommunicationType
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCommunicationType: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteCommunicationType.'
        )
      }
      const localVarPath = `/call_center/communication_type/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary CommunicationType item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readCommunicationType: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readCommunicationType.'
        )
      }
      const localVarPath = `/call_center/communication_type/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List of CommunicationType
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchCommunicationType: async (
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/call_center/communication_type`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update CommunicationType
     * @param {string} id
     * @param {EngineUpdateCommunicationTypeRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCommunicationType: async (
      id: string,
      body: EngineUpdateCommunicationTypeRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateCommunicationType.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateCommunicationType.'
        )
      }
      const localVarPath = `/call_center/communication_type/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * CommunicationTypeServiceApi - functional programming interface
 * @export
 */
export const CommunicationTypeServiceApiFp = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create CommunicationType
     * @param {EngineCommunicationTypeRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createCommunicationType(
      body: EngineCommunicationTypeRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineCommunicationType>
    > {
      const localVarAxiosArgs = await CommunicationTypeServiceApiAxiosParamCreator(
        configuration
      ).createCommunicationType(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Remove CommunicationType
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteCommunicationType(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineCommunicationType>
    > {
      const localVarAxiosArgs = await CommunicationTypeServiceApiAxiosParamCreator(
        configuration
      ).deleteCommunicationType(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary CommunicationType item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readCommunicationType(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineCommunicationType>
    > {
      const localVarAxiosArgs = await CommunicationTypeServiceApiAxiosParamCreator(
        configuration
      ).readCommunicationType(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List of CommunicationType
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchCommunicationType(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListCommunicationType>
    > {
      const localVarAxiosArgs = await CommunicationTypeServiceApiAxiosParamCreator(
        configuration
      ).searchCommunicationType(page, size, q, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update CommunicationType
     * @param {string} id
     * @param {EngineUpdateCommunicationTypeRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateCommunicationType(
      id: string,
      body: EngineUpdateCommunicationTypeRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineCommunicationType>
    > {
      const localVarAxiosArgs = await CommunicationTypeServiceApiAxiosParamCreator(
        configuration
      ).updateCommunicationType(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * CommunicationTypeServiceApi - factory interface
 * @export
 */
export const CommunicationTypeServiceApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Create CommunicationType
     * @param {EngineCommunicationTypeRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createCommunicationType(
      body: EngineCommunicationTypeRequest,
      options?: any
    ): AxiosPromise<EngineCommunicationType> {
      return CommunicationTypeServiceApiFp(configuration)
        .createCommunicationType(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Remove CommunicationType
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCommunicationType(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineCommunicationType> {
      return CommunicationTypeServiceApiFp(configuration)
        .deleteCommunicationType(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary CommunicationType item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readCommunicationType(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineCommunicationType> {
      return CommunicationTypeServiceApiFp(configuration)
        .readCommunicationType(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List of CommunicationType
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchCommunicationType(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListCommunicationType> {
      return CommunicationTypeServiceApiFp(configuration)
        .searchCommunicationType(page, size, q, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update CommunicationType
     * @param {string} id
     * @param {EngineUpdateCommunicationTypeRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCommunicationType(
      id: string,
      body: EngineUpdateCommunicationTypeRequest,
      options?: any
    ): AxiosPromise<EngineCommunicationType> {
      return CommunicationTypeServiceApiFp(configuration)
        .updateCommunicationType(id, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * CommunicationTypeServiceApi - object-oriented interface
 * @export
 * @class CommunicationTypeServiceApi
 * @extends {BaseAPI}
 */
export class CommunicationTypeServiceApi extends BaseAPI {
  /**
   *
   * @summary Create CommunicationType
   * @param {EngineCommunicationTypeRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommunicationTypeServiceApi
   */
  public createCommunicationType(
    body: EngineCommunicationTypeRequest,
    options?: any
  ) {
    return CommunicationTypeServiceApiFp(this.configuration)
      .createCommunicationType(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Remove CommunicationType
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommunicationTypeServiceApi
   */
  public deleteCommunicationType(id: string, domainId?: string, options?: any) {
    return CommunicationTypeServiceApiFp(this.configuration)
      .deleteCommunicationType(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary CommunicationType item
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommunicationTypeServiceApi
   */
  public readCommunicationType(id: string, domainId?: string, options?: any) {
    return CommunicationTypeServiceApiFp(this.configuration)
      .readCommunicationType(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List of CommunicationType
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommunicationTypeServiceApi
   */
  public searchCommunicationType(
    page?: number,
    size?: number,
    q?: string,
    domainId?: string,
    options?: any
  ) {
    return CommunicationTypeServiceApiFp(this.configuration)
      .searchCommunicationType(page, size, q, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update CommunicationType
   * @param {string} id
   * @param {EngineUpdateCommunicationTypeRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommunicationTypeServiceApi
   */
  public updateCommunicationType(
    id: string,
    body: EngineUpdateCommunicationTypeRequest,
    options?: any
  ) {
    return CommunicationTypeServiceApiFp(this.configuration)
      .updateCommunicationType(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * EmailProfileServiceApi - axios parameter creator
 * @export
 */
export const EmailProfileServiceApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create EmailProfile
     * @param {EngineCreateEmailProfileRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEmailProfile: async (
      body: EngineCreateEmailProfileRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createEmailProfile.'
        )
      }
      const localVarPath = `/email/profile`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Remove EmailProfile
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEmailProfile: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteEmailProfile.'
        )
      }
      const localVarPath = `/email/profile/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary EmailProfile item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readEmailProfile: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readEmailProfile.'
        )
      }
      const localVarPath = `/email/profile/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Search EmailProfile
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchEmailProfile: async (
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      fields?: Array<string>,
      sort?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/email/profile`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update EmailProfile
     * @param {string} id
     * @param {EngineUpdateEmailProfileRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEmailProfile: async (
      id: string,
      body: EngineUpdateEmailProfileRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateEmailProfile.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateEmailProfile.'
        )
      }
      const localVarPath = `/email/profile/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * EmailProfileServiceApi - functional programming interface
 * @export
 */
export const EmailProfileServiceApiFp = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create EmailProfile
     * @param {EngineCreateEmailProfileRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createEmailProfile(
      body: EngineCreateEmailProfileRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineEmailProfile>
    > {
      const localVarAxiosArgs = await EmailProfileServiceApiAxiosParamCreator(
        configuration
      ).createEmailProfile(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Remove EmailProfile
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteEmailProfile(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineEmailProfile>
    > {
      const localVarAxiosArgs = await EmailProfileServiceApiAxiosParamCreator(
        configuration
      ).deleteEmailProfile(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary EmailProfile item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readEmailProfile(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineEmailProfile>
    > {
      const localVarAxiosArgs = await EmailProfileServiceApiAxiosParamCreator(
        configuration
      ).readEmailProfile(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Search EmailProfile
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchEmailProfile(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      fields?: Array<string>,
      sort?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListEmailProfile>
    > {
      const localVarAxiosArgs = await EmailProfileServiceApiAxiosParamCreator(
        configuration
      ).searchEmailProfile(page, size, q, domainId, fields, sort, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update EmailProfile
     * @param {string} id
     * @param {EngineUpdateEmailProfileRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateEmailProfile(
      id: string,
      body: EngineUpdateEmailProfileRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineEmailProfile>
    > {
      const localVarAxiosArgs = await EmailProfileServiceApiAxiosParamCreator(
        configuration
      ).updateEmailProfile(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * EmailProfileServiceApi - factory interface
 * @export
 */
export const EmailProfileServiceApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Create EmailProfile
     * @param {EngineCreateEmailProfileRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createEmailProfile(
      body: EngineCreateEmailProfileRequest,
      options?: any
    ): AxiosPromise<EngineEmailProfile> {
      return EmailProfileServiceApiFp(configuration)
        .createEmailProfile(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Remove EmailProfile
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEmailProfile(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineEmailProfile> {
      return EmailProfileServiceApiFp(configuration)
        .deleteEmailProfile(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary EmailProfile item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readEmailProfile(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineEmailProfile> {
      return EmailProfileServiceApiFp(configuration)
        .readEmailProfile(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Search EmailProfile
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchEmailProfile(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      fields?: Array<string>,
      sort?: string,
      options?: any
    ): AxiosPromise<EngineListEmailProfile> {
      return EmailProfileServiceApiFp(configuration)
        .searchEmailProfile(page, size, q, domainId, fields, sort, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update EmailProfile
     * @param {string} id
     * @param {EngineUpdateEmailProfileRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEmailProfile(
      id: string,
      body: EngineUpdateEmailProfileRequest,
      options?: any
    ): AxiosPromise<EngineEmailProfile> {
      return EmailProfileServiceApiFp(configuration)
        .updateEmailProfile(id, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * EmailProfileServiceApi - object-oriented interface
 * @export
 * @class EmailProfileServiceApi
 * @extends {BaseAPI}
 */
export class EmailProfileServiceApi extends BaseAPI {
  /**
   *
   * @summary Create EmailProfile
   * @param {EngineCreateEmailProfileRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EmailProfileServiceApi
   */
  public createEmailProfile(
    body: EngineCreateEmailProfileRequest,
    options?: any
  ) {
    return EmailProfileServiceApiFp(this.configuration)
      .createEmailProfile(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Remove EmailProfile
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EmailProfileServiceApi
   */
  public deleteEmailProfile(id: string, domainId?: string, options?: any) {
    return EmailProfileServiceApiFp(this.configuration)
      .deleteEmailProfile(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary EmailProfile item
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EmailProfileServiceApi
   */
  public readEmailProfile(id: string, domainId?: string, options?: any) {
    return EmailProfileServiceApiFp(this.configuration)
      .readEmailProfile(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Search EmailProfile
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [domainId]
   * @param {Array<string>} [fields]
   * @param {string} [sort]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EmailProfileServiceApi
   */
  public searchEmailProfile(
    page?: number,
    size?: number,
    q?: string,
    domainId?: string,
    fields?: Array<string>,
    sort?: string,
    options?: any
  ) {
    return EmailProfileServiceApiFp(this.configuration)
      .searchEmailProfile(page, size, q, domainId, fields, sort, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update EmailProfile
   * @param {string} id
   * @param {EngineUpdateEmailProfileRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EmailProfileServiceApi
   */
  public updateEmailProfile(
    id: string,
    body: EngineUpdateEmailProfileRequest,
    options?: any
  ) {
    return EmailProfileServiceApiFp(this.configuration)
      .updateEmailProfile(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ListServiceApi - axios parameter creator
 * @export
 */
export const ListServiceApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create List
     * @param {EngineCreateListRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createList: async (
      body: EngineCreateListRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createList.'
        )
      }
      const localVarPath = `/call_center/list`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create ListCommunication
     * @param {string} listId
     * @param {EngineCreateListCommunicationRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createListCommunication: async (
      listId: string,
      body: EngineCreateListCommunicationRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'listId' is not null or undefined
      if (listId === null || listId === undefined) {
        throw new RequiredError(
          'listId',
          'Required parameter listId was null or undefined when calling createListCommunication.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createListCommunication.'
        )
      }
      const localVarPath = `/call_center/list/{list_id}/communication`.replace(
        `{${'list_id'}}`,
        encodeURIComponent(String(listId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Remove list
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteList: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteList.'
        )
      }
      const localVarPath = `/call_center/list/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Remove ListCommunication
     * @param {string} listId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteListCommunication: async (
      listId: string,
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'listId' is not null or undefined
      if (listId === null || listId === undefined) {
        throw new RequiredError(
          'listId',
          'Required parameter listId was null or undefined when calling deleteListCommunication.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteListCommunication.'
        )
      }
      const localVarPath = `/call_center/list/{list_id}/communication/{id}`
        .replace(`{${'list_id'}}`, encodeURIComponent(String(listId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readList: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readList.'
        )
      }
      const localVarPath = `/call_center/list/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List item
     * @param {string} listId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readListCommunication: async (
      listId: string,
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'listId' is not null or undefined
      if (listId === null || listId === undefined) {
        throw new RequiredError(
          'listId',
          'Required parameter listId was null or undefined when calling readListCommunication.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readListCommunication.'
        )
      }
      const localVarPath = `/call_center/list/{list_id}/communication/{id}`
        .replace(`{${'list_id'}}`, encodeURIComponent(String(listId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List of List
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchList: async (
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/call_center/list`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List of List
     * @param {string} listId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchListCommunication: async (
      listId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'listId' is not null or undefined
      if (listId === null || listId === undefined) {
        throw new RequiredError(
          'listId',
          'Required parameter listId was null or undefined when calling searchListCommunication.'
        )
      }
      const localVarPath = `/call_center/list/{list_id}/communication`.replace(
        `{${'list_id'}}`,
        encodeURIComponent(String(listId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update list
     * @param {string} id
     * @param {EngineUpdateListRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateList: async (
      id: string,
      body: EngineUpdateListRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateList.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateList.'
        )
      }
      const localVarPath = `/call_center/list/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update ListCommunication
     * @param {string} listId
     * @param {string} id
     * @param {EngineUpdateListCommunicationRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateListCommunication: async (
      listId: string,
      id: string,
      body: EngineUpdateListCommunicationRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'listId' is not null or undefined
      if (listId === null || listId === undefined) {
        throw new RequiredError(
          'listId',
          'Required parameter listId was null or undefined when calling updateListCommunication.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateListCommunication.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateListCommunication.'
        )
      }
      const localVarPath = `/call_center/list/{list_id}/communication/{id}`
        .replace(`{${'list_id'}}`, encodeURIComponent(String(listId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ListServiceApi - functional programming interface
 * @export
 */
export const ListServiceApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create List
     * @param {EngineCreateListRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createList(
      body: EngineCreateListRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineList>
    > {
      const localVarAxiosArgs = await ListServiceApiAxiosParamCreator(
        configuration
      ).createList(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create ListCommunication
     * @param {string} listId
     * @param {EngineCreateListCommunicationRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createListCommunication(
      listId: string,
      body: EngineCreateListCommunicationRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListCommunication>
    > {
      const localVarAxiosArgs = await ListServiceApiAxiosParamCreator(
        configuration
      ).createListCommunication(listId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Remove list
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteList(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineList>
    > {
      const localVarAxiosArgs = await ListServiceApiAxiosParamCreator(
        configuration
      ).deleteList(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Remove ListCommunication
     * @param {string} listId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteListCommunication(
      listId: string,
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListCommunication>
    > {
      const localVarAxiosArgs = await ListServiceApiAxiosParamCreator(
        configuration
      ).deleteListCommunication(listId, id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readList(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineList>
    > {
      const localVarAxiosArgs = await ListServiceApiAxiosParamCreator(
        configuration
      ).readList(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List item
     * @param {string} listId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readListCommunication(
      listId: string,
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListCommunication>
    > {
      const localVarAxiosArgs = await ListServiceApiAxiosParamCreator(
        configuration
      ).readListCommunication(listId, id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List of List
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchList(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListOfList>
    > {
      const localVarAxiosArgs = await ListServiceApiAxiosParamCreator(
        configuration
      ).searchList(page, size, q, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List of List
     * @param {string} listId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchListCommunication(
      listId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListOfListCommunication>
    > {
      const localVarAxiosArgs = await ListServiceApiAxiosParamCreator(
        configuration
      ).searchListCommunication(listId, page, size, q, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update list
     * @param {string} id
     * @param {EngineUpdateListRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateList(
      id: string,
      body: EngineUpdateListRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineList>
    > {
      const localVarAxiosArgs = await ListServiceApiAxiosParamCreator(
        configuration
      ).updateList(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update ListCommunication
     * @param {string} listId
     * @param {string} id
     * @param {EngineUpdateListCommunicationRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateListCommunication(
      listId: string,
      id: string,
      body: EngineUpdateListCommunicationRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListCommunication>
    > {
      const localVarAxiosArgs = await ListServiceApiAxiosParamCreator(
        configuration
      ).updateListCommunication(listId, id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * ListServiceApi - factory interface
 * @export
 */
export const ListServiceApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Create List
     * @param {EngineCreateListRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createList(
      body: EngineCreateListRequest,
      options?: any
    ): AxiosPromise<EngineList> {
      return ListServiceApiFp(configuration)
        .createList(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create ListCommunication
     * @param {string} listId
     * @param {EngineCreateListCommunicationRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createListCommunication(
      listId: string,
      body: EngineCreateListCommunicationRequest,
      options?: any
    ): AxiosPromise<EngineListCommunication> {
      return ListServiceApiFp(configuration)
        .createListCommunication(listId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Remove list
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteList(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineList> {
      return ListServiceApiFp(configuration)
        .deleteList(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Remove ListCommunication
     * @param {string} listId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteListCommunication(
      listId: string,
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListCommunication> {
      return ListServiceApiFp(configuration)
        .deleteListCommunication(listId, id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readList(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineList> {
      return ListServiceApiFp(configuration)
        .readList(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List item
     * @param {string} listId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readListCommunication(
      listId: string,
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListCommunication> {
      return ListServiceApiFp(configuration)
        .readListCommunication(listId, id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List of List
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchList(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListOfList> {
      return ListServiceApiFp(configuration)
        .searchList(page, size, q, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List of List
     * @param {string} listId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchListCommunication(
      listId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListOfListCommunication> {
      return ListServiceApiFp(configuration)
        .searchListCommunication(listId, page, size, q, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update list
     * @param {string} id
     * @param {EngineUpdateListRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateList(
      id: string,
      body: EngineUpdateListRequest,
      options?: any
    ): AxiosPromise<EngineList> {
      return ListServiceApiFp(configuration)
        .updateList(id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update ListCommunication
     * @param {string} listId
     * @param {string} id
     * @param {EngineUpdateListCommunicationRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateListCommunication(
      listId: string,
      id: string,
      body: EngineUpdateListCommunicationRequest,
      options?: any
    ): AxiosPromise<EngineListCommunication> {
      return ListServiceApiFp(configuration)
        .updateListCommunication(listId, id, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ListServiceApi - object-oriented interface
 * @export
 * @class ListServiceApi
 * @extends {BaseAPI}
 */
export class ListServiceApi extends BaseAPI {
  /**
   *
   * @summary Create List
   * @param {EngineCreateListRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ListServiceApi
   */
  public createList(body: EngineCreateListRequest, options?: any) {
    return ListServiceApiFp(this.configuration)
      .createList(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create ListCommunication
   * @param {string} listId
   * @param {EngineCreateListCommunicationRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ListServiceApi
   */
  public createListCommunication(
    listId: string,
    body: EngineCreateListCommunicationRequest,
    options?: any
  ) {
    return ListServiceApiFp(this.configuration)
      .createListCommunication(listId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Remove list
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ListServiceApi
   */
  public deleteList(id: string, domainId?: string, options?: any) {
    return ListServiceApiFp(this.configuration)
      .deleteList(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Remove ListCommunication
   * @param {string} listId
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ListServiceApi
   */
  public deleteListCommunication(
    listId: string,
    id: string,
    domainId?: string,
    options?: any
  ) {
    return ListServiceApiFp(this.configuration)
      .deleteListCommunication(listId, id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List item
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ListServiceApi
   */
  public readList(id: string, domainId?: string, options?: any) {
    return ListServiceApiFp(this.configuration)
      .readList(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List item
   * @param {string} listId
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ListServiceApi
   */
  public readListCommunication(
    listId: string,
    id: string,
    domainId?: string,
    options?: any
  ) {
    return ListServiceApiFp(this.configuration)
      .readListCommunication(listId, id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List of List
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ListServiceApi
   */
  public searchList(
    page?: number,
    size?: number,
    q?: string,
    domainId?: string,
    options?: any
  ) {
    return ListServiceApiFp(this.configuration)
      .searchList(page, size, q, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List of List
   * @param {string} listId
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ListServiceApi
   */
  public searchListCommunication(
    listId: string,
    page?: number,
    size?: number,
    q?: string,
    domainId?: string,
    options?: any
  ) {
    return ListServiceApiFp(this.configuration)
      .searchListCommunication(listId, page, size, q, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update list
   * @param {string} id
   * @param {EngineUpdateListRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ListServiceApi
   */
  public updateList(id: string, body: EngineUpdateListRequest, options?: any) {
    return ListServiceApiFp(this.configuration)
      .updateList(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update ListCommunication
   * @param {string} listId
   * @param {string} id
   * @param {EngineUpdateListCommunicationRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ListServiceApi
   */
  public updateListCommunication(
    listId: string,
    id: string,
    body: EngineUpdateListCommunicationRequest,
    options?: any
  ) {
    return ListServiceApiFp(this.configuration)
      .updateListCommunication(listId, id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * MediaFileServiceApi - axios parameter creator
 * @export
 */
export const MediaFileServiceApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Remove MediaFile
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMediaFile: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteMediaFile.'
        )
      }
      const localVarPath = `/storage/media/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary MediaFile item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readMediaFile: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readMediaFile.'
        )
      }
      const localVarPath = `/storage/media/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Search MediaFile
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchMediaFile: async (
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/storage/media`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * MediaFileServiceApi - functional programming interface
 * @export
 */
export const MediaFileServiceApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Remove MediaFile
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteMediaFile(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<StorageMediaFile>
    > {
      const localVarAxiosArgs = await MediaFileServiceApiAxiosParamCreator(
        configuration
      ).deleteMediaFile(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary MediaFile item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readMediaFile(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<StorageMediaFile>
    > {
      const localVarAxiosArgs = await MediaFileServiceApiAxiosParamCreator(
        configuration
      ).readMediaFile(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Search MediaFile
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchMediaFile(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<StorageListMedia>
    > {
      const localVarAxiosArgs = await MediaFileServiceApiAxiosParamCreator(
        configuration
      ).searchMediaFile(page, size, q, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * MediaFileServiceApi - factory interface
 * @export
 */
export const MediaFileServiceApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Remove MediaFile
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMediaFile(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<StorageMediaFile> {
      return MediaFileServiceApiFp(configuration)
        .deleteMediaFile(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary MediaFile item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readMediaFile(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<StorageMediaFile> {
      return MediaFileServiceApiFp(configuration)
        .readMediaFile(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Search MediaFile
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchMediaFile(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<StorageListMedia> {
      return MediaFileServiceApiFp(configuration)
        .searchMediaFile(page, size, q, domainId, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * MediaFileServiceApi - object-oriented interface
 * @export
 * @class MediaFileServiceApi
 * @extends {BaseAPI}
 */
export class MediaFileServiceApi extends BaseAPI {
  /**
   *
   * @summary Remove MediaFile
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MediaFileServiceApi
   */
  public deleteMediaFile(id: string, domainId?: string, options?: any) {
    return MediaFileServiceApiFp(this.configuration)
      .deleteMediaFile(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary MediaFile item
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MediaFileServiceApi
   */
  public readMediaFile(id: string, domainId?: string, options?: any) {
    return MediaFileServiceApiFp(this.configuration)
      .readMediaFile(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Search MediaFile
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MediaFileServiceApi
   */
  public searchMediaFile(
    page?: number,
    size?: number,
    q?: string,
    domainId?: string,
    options?: any
  ) {
    return MediaFileServiceApiFp(this.configuration)
      .searchMediaFile(page, size, q, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * MemberServiceApi - axios parameter creator
 * @export
 */
export const MemberServiceApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {string} attemptId
     * @param {EngineAttemptCallbackRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    attemptCallback: async (
      attemptId: string,
      body: EngineAttemptCallbackRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'attemptId' is not null or undefined
      if (attemptId === null || attemptId === undefined) {
        throw new RequiredError(
          'attemptId',
          'Required parameter attemptId was null or undefined when calling attemptCallback.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling attemptCallback.'
        )
      }
      const localVarPath = `/call_center/attempts/{attempt_id}`.replace(
        `{${'attempt_id'}}`,
        encodeURIComponent(String(attemptId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} queueId
     * @param {string} memberId
     * @param {string} attemptId
     * @param {EngineAttemptResultRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    attemptResult: async (
      queueId: number,
      memberId: string,
      attemptId: string,
      body: EngineAttemptResultRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling attemptResult.'
        )
      }
      // verify required parameter 'memberId' is not null or undefined
      if (memberId === null || memberId === undefined) {
        throw new RequiredError(
          'memberId',
          'Required parameter memberId was null or undefined when calling attemptResult.'
        )
      }
      // verify required parameter 'attemptId' is not null or undefined
      if (attemptId === null || attemptId === undefined) {
        throw new RequiredError(
          'attemptId',
          'Required parameter attemptId was null or undefined when calling attemptResult.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling attemptResult.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/members/{member_id}/attempts/{attempt_id}`
        .replace(`{${'queue_id'}}`, encodeURIComponent(String(queueId)))
        .replace(`{${'member_id'}}`, encodeURIComponent(String(memberId)))
        .replace(`{${'attempt_id'}}`, encodeURIComponent(String(attemptId)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Offline queue
     * @param {string} queueId
     * @param {string} memberId
     * @param {EngineCreateAttemptRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAttempt: async (
      queueId: string,
      memberId: string,
      body: EngineCreateAttemptRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling createAttempt.'
        )
      }
      // verify required parameter 'memberId' is not null or undefined
      if (memberId === null || memberId === undefined) {
        throw new RequiredError(
          'memberId',
          'Required parameter memberId was null or undefined when calling createAttempt.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createAttempt.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/members/{member_id}/attempts`
        .replace(`{${'queue_id'}}`, encodeURIComponent(String(queueId)))
        .replace(`{${'member_id'}}`, encodeURIComponent(String(memberId)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create Member
     * @param {string} queueId
     * @param {EngineCreateMemberRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMember: async (
      queueId: string,
      body: EngineCreateMemberRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling createMember.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createMember.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/members`.replace(
        `{${'queue_id'}}`,
        encodeURIComponent(String(queueId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create Member
     * @param {string} queueId
     * @param {EngineCreateMemberBulkRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMemberBulk: async (
      queueId: string,
      body: EngineCreateMemberBulkRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling createMemberBulk.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createMemberBulk.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/members/bulk`.replace(
        `{${'queue_id'}}`,
        encodeURIComponent(String(queueId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary DeleteMember
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMember: async (
      queueId: string,
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling deleteMember.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteMember.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/members/{id}`
        .replace(`{${'queue_id'}}`, encodeURIComponent(String(queueId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary DeleteMembers
     * @param {string} queueId
     * @param {EngineDeleteMembersRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMembers: async (
      queueId: string,
      body: EngineDeleteMembersRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling deleteMembers.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling deleteMembers.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/members`.replace(
        `{${'queue_id'}}`,
        encodeURIComponent(String(queueId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Patch Member
     * @param {string} queueId
     * @param {string} id
     * @param {EnginePatchMemberRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchMember: async (
      queueId: string,
      id: string,
      body: EnginePatchMemberRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling patchMember.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling patchMember.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling patchMember.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/members/{id}`
        .replace(`{${'queue_id'}}`, encodeURIComponent(String(queueId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary ReadQueueRouting
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readMember: async (
      queueId: string,
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling readMember.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readMember.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/members/{id}`
        .replace(`{${'queue_id'}}`, encodeURIComponent(String(queueId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary SearchAttempts
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [joinedAtFrom]
     * @param {string} [joinedAtTo]
     * @param {Array<string>} [id]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [bucketId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [agentId]
     * @param {string} [result]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAttempts: async (
      page?: number,
      size?: number,
      joinedAtFrom?: string,
      joinedAtTo?: string,
      id?: Array<string>,
      queueId?: Array<string>,
      bucketId?: Array<string>,
      memberId?: Array<string>,
      agentId?: Array<string>,
      result?: string,
      fields?: Array<string>,
      sort?: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/call_center/queues/attempts/active`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (joinedAtFrom !== undefined) {
        localVarQueryParameter['joined_at.from'] = joinedAtFrom
      }

      if (joinedAtTo !== undefined) {
        localVarQueryParameter['joined_at.to'] = joinedAtTo
      }

      if (id) {
        localVarQueryParameter['id'] = id
      }

      if (queueId) {
        localVarQueryParameter['queue_id'] = queueId
      }

      if (bucketId) {
        localVarQueryParameter['bucket_id'] = bucketId
      }

      if (memberId) {
        localVarQueryParameter['member_id'] = memberId
      }

      if (agentId) {
        localVarQueryParameter['agent_id'] = agentId
      }

      if (result !== undefined) {
        localVarQueryParameter['result'] = result
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary SearchMemberAttempts
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [joinedAtFrom]
     * @param {string} [joinedAtTo]
     * @param {Array<string>} [id]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [bucketId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [agentId]
     * @param {string} [result]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAttemptsHistory: async (
      page?: number,
      size?: number,
      joinedAtFrom?: string,
      joinedAtTo?: string,
      id?: Array<string>,
      queueId?: Array<string>,
      bucketId?: Array<string>,
      memberId?: Array<string>,
      agentId?: Array<string>,
      result?: string,
      fields?: Array<string>,
      sort?: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/call_center/queues/attempts/history`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (joinedAtFrom !== undefined) {
        localVarQueryParameter['joined_at.from'] = joinedAtFrom
      }

      if (joinedAtTo !== undefined) {
        localVarQueryParameter['joined_at.to'] = joinedAtTo
      }

      if (id) {
        localVarQueryParameter['id'] = id
      }

      if (queueId) {
        localVarQueryParameter['queue_id'] = queueId
      }

      if (bucketId) {
        localVarQueryParameter['bucket_id'] = bucketId
      }

      if (memberId) {
        localVarQueryParameter['member_id'] = memberId
      }

      if (agentId) {
        localVarQueryParameter['agent_id'] = agentId
      }

      if (result !== undefined) {
        localVarQueryParameter['result'] = result
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary SearchMemberAttempts
     * @param {string} queueId
     * @param {string} memberId
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchMemberAttempts: async (
      queueId: string,
      memberId: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling searchMemberAttempts.'
        )
      }
      // verify required parameter 'memberId' is not null or undefined
      if (memberId === null || memberId === undefined) {
        throw new RequiredError(
          'memberId',
          'Required parameter memberId was null or undefined when calling searchMemberAttempts.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/members/{member_id}/attempts`
        .replace(`{${'queue_id'}}`, encodeURIComponent(String(queueId)))
        .replace(`{${'member_id'}}`, encodeURIComponent(String(memberId)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List of Member
     * @param {string} queueId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchMemberInQueue: async (
      queueId: string,
      page?: number,
      size?: number,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling searchMemberInQueue.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/members`.replace(
        `{${'queue_id'}}`,
        encodeURIComponent(String(queueId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Search of Member
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [id]
     * @param {string} [queueId]
     * @param {number} [bucketId]
     * @param {string} [destination]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchMembers: async (
      page?: number,
      size?: number,
      id?: string,
      queueId?: string,
      bucketId?: number,
      destination?: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/call_center/members`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      if (queueId !== undefined) {
        localVarQueryParameter['queue_id'] = queueId
      }

      if (bucketId !== undefined) {
        localVarQueryParameter['bucket_id'] = bucketId
      }

      if (destination !== undefined) {
        localVarQueryParameter['destination'] = destination
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary UpdateMember
     * @param {string} queueId
     * @param {string} id
     * @param {EngineUpdateMemberRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMember: async (
      queueId: string,
      id: string,
      body: EngineUpdateMemberRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling updateMember.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateMember.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateMember.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/members/{id}`
        .replace(`{${'queue_id'}}`, encodeURIComponent(String(queueId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * MemberServiceApi - functional programming interface
 * @export
 */
export const MemberServiceApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @param {string} attemptId
     * @param {EngineAttemptCallbackRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async attemptCallback(
      attemptId: string,
      body: EngineAttemptCallbackRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineAttemptResultResponse>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).attemptCallback(attemptId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {number} queueId
     * @param {string} memberId
     * @param {string} attemptId
     * @param {EngineAttemptResultRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async attemptResult(
      queueId: number,
      memberId: string,
      attemptId: string,
      body: EngineAttemptResultRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineAttemptResultResponse>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).attemptResult(queueId, memberId, attemptId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Offline queue
     * @param {string} queueId
     * @param {string} memberId
     * @param {EngineCreateAttemptRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createAttempt(
      queueId: string,
      memberId: string,
      body: EngineCreateAttemptRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineCreateAttemptResponse>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).createAttempt(queueId, memberId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create Member
     * @param {string} queueId
     * @param {EngineCreateMemberRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createMember(
      queueId: string,
      body: EngineCreateMemberRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineMemberInQueue>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).createMember(queueId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create Member
     * @param {string} queueId
     * @param {EngineCreateMemberBulkRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createMemberBulk(
      queueId: string,
      body: EngineCreateMemberBulkRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineMemberBulkResponse>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).createMemberBulk(queueId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary DeleteMember
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteMember(
      queueId: string,
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineMemberInQueue>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).deleteMember(queueId, id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary DeleteMembers
     * @param {string} queueId
     * @param {EngineDeleteMembersRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteMembers(
      queueId: string,
      body: EngineDeleteMembersRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListMember>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).deleteMembers(queueId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Patch Member
     * @param {string} queueId
     * @param {string} id
     * @param {EnginePatchMemberRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchMember(
      queueId: string,
      id: string,
      body: EnginePatchMemberRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineMemberInQueue>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).patchMember(queueId, id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary ReadQueueRouting
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readMember(
      queueId: string,
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineMemberInQueue>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).readMember(queueId, id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary SearchAttempts
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [joinedAtFrom]
     * @param {string} [joinedAtTo]
     * @param {Array<string>} [id]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [bucketId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [agentId]
     * @param {string} [result]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchAttempts(
      page?: number,
      size?: number,
      joinedAtFrom?: string,
      joinedAtTo?: string,
      id?: Array<string>,
      queueId?: Array<string>,
      bucketId?: Array<string>,
      memberId?: Array<string>,
      agentId?: Array<string>,
      result?: string,
      fields?: Array<string>,
      sort?: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListAttempt>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).searchAttempts(
        page,
        size,
        joinedAtFrom,
        joinedAtTo,
        id,
        queueId,
        bucketId,
        memberId,
        agentId,
        result,
        fields,
        sort,
        domainId,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary SearchMemberAttempts
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [joinedAtFrom]
     * @param {string} [joinedAtTo]
     * @param {Array<string>} [id]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [bucketId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [agentId]
     * @param {string} [result]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchAttemptsHistory(
      page?: number,
      size?: number,
      joinedAtFrom?: string,
      joinedAtTo?: string,
      id?: Array<string>,
      queueId?: Array<string>,
      bucketId?: Array<string>,
      memberId?: Array<string>,
      agentId?: Array<string>,
      result?: string,
      fields?: Array<string>,
      sort?: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListHistoryAttempt>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).searchAttemptsHistory(
        page,
        size,
        joinedAtFrom,
        joinedAtTo,
        id,
        queueId,
        bucketId,
        memberId,
        agentId,
        result,
        fields,
        sort,
        domainId,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary SearchMemberAttempts
     * @param {string} queueId
     * @param {string} memberId
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchMemberAttempts(
      queueId: string,
      memberId: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListMemberAttempt>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).searchMemberAttempts(queueId, memberId, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List of Member
     * @param {string} queueId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchMemberInQueue(
      queueId: string,
      page?: number,
      size?: number,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListMember>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).searchMemberInQueue(queueId, page, size, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Search of Member
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [id]
     * @param {string} [queueId]
     * @param {number} [bucketId]
     * @param {string} [destination]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchMembers(
      page?: number,
      size?: number,
      id?: string,
      queueId?: string,
      bucketId?: number,
      destination?: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListMember>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).searchMembers(
        page,
        size,
        id,
        queueId,
        bucketId,
        destination,
        domainId,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary UpdateMember
     * @param {string} queueId
     * @param {string} id
     * @param {EngineUpdateMemberRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateMember(
      queueId: string,
      id: string,
      body: EngineUpdateMemberRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineMemberInQueue>
    > {
      const localVarAxiosArgs = await MemberServiceApiAxiosParamCreator(
        configuration
      ).updateMember(queueId, id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * MemberServiceApi - factory interface
 * @export
 */
export const MemberServiceApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @param {string} attemptId
     * @param {EngineAttemptCallbackRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    attemptCallback(
      attemptId: string,
      body: EngineAttemptCallbackRequest,
      options?: any
    ): AxiosPromise<EngineAttemptResultResponse> {
      return MemberServiceApiFp(configuration)
        .attemptCallback(attemptId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} queueId
     * @param {string} memberId
     * @param {string} attemptId
     * @param {EngineAttemptResultRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    attemptResult(
      queueId: number,
      memberId: string,
      attemptId: string,
      body: EngineAttemptResultRequest,
      options?: any
    ): AxiosPromise<EngineAttemptResultResponse> {
      return MemberServiceApiFp(configuration)
        .attemptResult(queueId, memberId, attemptId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Offline queue
     * @param {string} queueId
     * @param {string} memberId
     * @param {EngineCreateAttemptRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAttempt(
      queueId: string,
      memberId: string,
      body: EngineCreateAttemptRequest,
      options?: any
    ): AxiosPromise<EngineCreateAttemptResponse> {
      return MemberServiceApiFp(configuration)
        .createAttempt(queueId, memberId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create Member
     * @param {string} queueId
     * @param {EngineCreateMemberRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMember(
      queueId: string,
      body: EngineCreateMemberRequest,
      options?: any
    ): AxiosPromise<EngineMemberInQueue> {
      return MemberServiceApiFp(configuration)
        .createMember(queueId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create Member
     * @param {string} queueId
     * @param {EngineCreateMemberBulkRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMemberBulk(
      queueId: string,
      body: EngineCreateMemberBulkRequest,
      options?: any
    ): AxiosPromise<EngineMemberBulkResponse> {
      return MemberServiceApiFp(configuration)
        .createMemberBulk(queueId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary DeleteMember
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMember(
      queueId: string,
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineMemberInQueue> {
      return MemberServiceApiFp(configuration)
        .deleteMember(queueId, id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary DeleteMembers
     * @param {string} queueId
     * @param {EngineDeleteMembersRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMembers(
      queueId: string,
      body: EngineDeleteMembersRequest,
      options?: any
    ): AxiosPromise<EngineListMember> {
      return MemberServiceApiFp(configuration)
        .deleteMembers(queueId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Patch Member
     * @param {string} queueId
     * @param {string} id
     * @param {EnginePatchMemberRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchMember(
      queueId: string,
      id: string,
      body: EnginePatchMemberRequest,
      options?: any
    ): AxiosPromise<EngineMemberInQueue> {
      return MemberServiceApiFp(configuration)
        .patchMember(queueId, id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary ReadQueueRouting
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readMember(
      queueId: string,
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineMemberInQueue> {
      return MemberServiceApiFp(configuration)
        .readMember(queueId, id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary SearchAttempts
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [joinedAtFrom]
     * @param {string} [joinedAtTo]
     * @param {Array<string>} [id]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [bucketId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [agentId]
     * @param {string} [result]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAttempts(
      page?: number,
      size?: number,
      joinedAtFrom?: string,
      joinedAtTo?: string,
      id?: Array<string>,
      queueId?: Array<string>,
      bucketId?: Array<string>,
      memberId?: Array<string>,
      agentId?: Array<string>,
      result?: string,
      fields?: Array<string>,
      sort?: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListAttempt> {
      return MemberServiceApiFp(configuration)
        .searchAttempts(
          page,
          size,
          joinedAtFrom,
          joinedAtTo,
          id,
          queueId,
          bucketId,
          memberId,
          agentId,
          result,
          fields,
          sort,
          domainId,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary SearchMemberAttempts
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [joinedAtFrom]
     * @param {string} [joinedAtTo]
     * @param {Array<string>} [id]
     * @param {Array<string>} [queueId]
     * @param {Array<string>} [bucketId]
     * @param {Array<string>} [memberId]
     * @param {Array<string>} [agentId]
     * @param {string} [result]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAttemptsHistory(
      page?: number,
      size?: number,
      joinedAtFrom?: string,
      joinedAtTo?: string,
      id?: Array<string>,
      queueId?: Array<string>,
      bucketId?: Array<string>,
      memberId?: Array<string>,
      agentId?: Array<string>,
      result?: string,
      fields?: Array<string>,
      sort?: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListHistoryAttempt> {
      return MemberServiceApiFp(configuration)
        .searchAttemptsHistory(
          page,
          size,
          joinedAtFrom,
          joinedAtTo,
          id,
          queueId,
          bucketId,
          memberId,
          agentId,
          result,
          fields,
          sort,
          domainId,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary SearchMemberAttempts
     * @param {string} queueId
     * @param {string} memberId
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchMemberAttempts(
      queueId: string,
      memberId: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListMemberAttempt> {
      return MemberServiceApiFp(configuration)
        .searchMemberAttempts(queueId, memberId, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List of Member
     * @param {string} queueId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchMemberInQueue(
      queueId: string,
      page?: number,
      size?: number,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListMember> {
      return MemberServiceApiFp(configuration)
        .searchMemberInQueue(queueId, page, size, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Search of Member
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [id]
     * @param {string} [queueId]
     * @param {number} [bucketId]
     * @param {string} [destination]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchMembers(
      page?: number,
      size?: number,
      id?: string,
      queueId?: string,
      bucketId?: number,
      destination?: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListMember> {
      return MemberServiceApiFp(configuration)
        .searchMembers(
          page,
          size,
          id,
          queueId,
          bucketId,
          destination,
          domainId,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary UpdateMember
     * @param {string} queueId
     * @param {string} id
     * @param {EngineUpdateMemberRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMember(
      queueId: string,
      id: string,
      body: EngineUpdateMemberRequest,
      options?: any
    ): AxiosPromise<EngineMemberInQueue> {
      return MemberServiceApiFp(configuration)
        .updateMember(queueId, id, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * MemberServiceApi - object-oriented interface
 * @export
 * @class MemberServiceApi
 * @extends {BaseAPI}
 */
export class MemberServiceApi extends BaseAPI {
  /**
   *
   * @param {string} attemptId
   * @param {EngineAttemptCallbackRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public attemptCallback(
    attemptId: string,
    body: EngineAttemptCallbackRequest,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .attemptCallback(attemptId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} queueId
   * @param {string} memberId
   * @param {string} attemptId
   * @param {EngineAttemptResultRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public attemptResult(
    queueId: number,
    memberId: string,
    attemptId: string,
    body: EngineAttemptResultRequest,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .attemptResult(queueId, memberId, attemptId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Offline queue
   * @param {string} queueId
   * @param {string} memberId
   * @param {EngineCreateAttemptRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public createAttempt(
    queueId: string,
    memberId: string,
    body: EngineCreateAttemptRequest,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .createAttempt(queueId, memberId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create Member
   * @param {string} queueId
   * @param {EngineCreateMemberRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public createMember(
    queueId: string,
    body: EngineCreateMemberRequest,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .createMember(queueId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create Member
   * @param {string} queueId
   * @param {EngineCreateMemberBulkRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public createMemberBulk(
    queueId: string,
    body: EngineCreateMemberBulkRequest,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .createMemberBulk(queueId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary DeleteMember
   * @param {string} queueId
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public deleteMember(
    queueId: string,
    id: string,
    domainId?: string,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .deleteMember(queueId, id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary DeleteMembers
   * @param {string} queueId
   * @param {EngineDeleteMembersRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public deleteMembers(
    queueId: string,
    body: EngineDeleteMembersRequest,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .deleteMembers(queueId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Patch Member
   * @param {string} queueId
   * @param {string} id
   * @param {EnginePatchMemberRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public patchMember(
    queueId: string,
    id: string,
    body: EnginePatchMemberRequest,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .patchMember(queueId, id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary ReadQueueRouting
   * @param {string} queueId
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public readMember(
    queueId: string,
    id: string,
    domainId?: string,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .readMember(queueId, id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary SearchAttempts
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [joinedAtFrom]
   * @param {string} [joinedAtTo]
   * @param {Array<string>} [id]
   * @param {Array<string>} [queueId]
   * @param {Array<string>} [bucketId]
   * @param {Array<string>} [memberId]
   * @param {Array<string>} [agentId]
   * @param {string} [result]
   * @param {Array<string>} [fields]
   * @param {string} [sort]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public searchAttempts(
    page?: number,
    size?: number,
    joinedAtFrom?: string,
    joinedAtTo?: string,
    id?: Array<string>,
    queueId?: Array<string>,
    bucketId?: Array<string>,
    memberId?: Array<string>,
    agentId?: Array<string>,
    result?: string,
    fields?: Array<string>,
    sort?: string,
    domainId?: string,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .searchAttempts(
        page,
        size,
        joinedAtFrom,
        joinedAtTo,
        id,
        queueId,
        bucketId,
        memberId,
        agentId,
        result,
        fields,
        sort,
        domainId,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary SearchMemberAttempts
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [joinedAtFrom]
   * @param {string} [joinedAtTo]
   * @param {Array<string>} [id]
   * @param {Array<string>} [queueId]
   * @param {Array<string>} [bucketId]
   * @param {Array<string>} [memberId]
   * @param {Array<string>} [agentId]
   * @param {string} [result]
   * @param {Array<string>} [fields]
   * @param {string} [sort]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public searchAttemptsHistory(
    page?: number,
    size?: number,
    joinedAtFrom?: string,
    joinedAtTo?: string,
    id?: Array<string>,
    queueId?: Array<string>,
    bucketId?: Array<string>,
    memberId?: Array<string>,
    agentId?: Array<string>,
    result?: string,
    fields?: Array<string>,
    sort?: string,
    domainId?: string,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .searchAttemptsHistory(
        page,
        size,
        joinedAtFrom,
        joinedAtTo,
        id,
        queueId,
        bucketId,
        memberId,
        agentId,
        result,
        fields,
        sort,
        domainId,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary SearchMemberAttempts
   * @param {string} queueId
   * @param {string} memberId
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public searchMemberAttempts(
    queueId: string,
    memberId: string,
    domainId?: string,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .searchMemberAttempts(queueId, memberId, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List of Member
   * @param {string} queueId
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public searchMemberInQueue(
    queueId: string,
    page?: number,
    size?: number,
    domainId?: string,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .searchMemberInQueue(queueId, page, size, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Search of Member
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [id]
   * @param {string} [queueId]
   * @param {number} [bucketId]
   * @param {string} [destination]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public searchMembers(
    page?: number,
    size?: number,
    id?: string,
    queueId?: string,
    bucketId?: number,
    destination?: string,
    domainId?: string,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .searchMembers(
        page,
        size,
        id,
        queueId,
        bucketId,
        destination,
        domainId,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary UpdateMember
   * @param {string} queueId
   * @param {string} id
   * @param {EngineUpdateMemberRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MemberServiceApi
   */
  public updateMember(
    queueId: string,
    id: string,
    body: EngineUpdateMemberRequest,
    options?: any
  ) {
    return MemberServiceApiFp(this.configuration)
      .updateMember(queueId, id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * OutboundResourceGroupServiceApi - axios parameter creator
 * @export
 */
export const OutboundResourceGroupServiceApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create OutboundResourceGroup
     * @param {EngineCreateOutboundResourceGroupRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOutboundResourceGroup: async (
      body: EngineCreateOutboundResourceGroupRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createOutboundResourceGroup.'
        )
      }
      const localVarPath = `/call_center/resource_group`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create OutboundResourceGroup
     * @param {string} groupId
     * @param {EngineCreateOutboundResourceInGroupRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOutboundResourceInGroup: async (
      groupId: string,
      body: EngineCreateOutboundResourceInGroupRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupId' is not null or undefined
      if (groupId === null || groupId === undefined) {
        throw new RequiredError(
          'groupId',
          'Required parameter groupId was null or undefined when calling createOutboundResourceInGroup.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createOutboundResourceInGroup.'
        )
      }
      const localVarPath = `/call_center/resource_group/{group_id}/resource`.replace(
        `{${'group_id'}}`,
        encodeURIComponent(String(groupId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Remove OutboundResourceGroup
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOutboundResourceGroup: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteOutboundResourceGroup.'
        )
      }
      const localVarPath = `/call_center/resource_group/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Remove OutboundResourceInGroup
     * @param {string} groupId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOutboundResourceInGroup: async (
      groupId: string,
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupId' is not null or undefined
      if (groupId === null || groupId === undefined) {
        throw new RequiredError(
          'groupId',
          'Required parameter groupId was null or undefined when calling deleteOutboundResourceInGroup.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteOutboundResourceInGroup.'
        )
      }
      const localVarPath = `/call_center/resource_group/{group_id}/resource/{id}`
        .replace(`{${'group_id'}}`, encodeURIComponent(String(groupId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary OutboundResourceGroup item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readOutboundResourceGroup: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readOutboundResourceGroup.'
        )
      }
      const localVarPath = `/call_center/resource_group/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary OutboundResourceInGroup item
     * @param {string} groupId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readOutboundResourceInGroup: async (
      groupId: string,
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupId' is not null or undefined
      if (groupId === null || groupId === undefined) {
        throw new RequiredError(
          'groupId',
          'Required parameter groupId was null or undefined when calling readOutboundResourceInGroup.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readOutboundResourceInGroup.'
        )
      }
      const localVarPath = `/call_center/resource_group/{group_id}/resource/{id}`
        .replace(`{${'group_id'}}`, encodeURIComponent(String(groupId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List of OutboundResourceGroup
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchOutboundResourceGroup: async (
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/call_center/resource_group`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List of OutboundResourceInGroup
     * @param {string} groupId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchOutboundResourceInGroup: async (
      groupId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupId' is not null or undefined
      if (groupId === null || groupId === undefined) {
        throw new RequiredError(
          'groupId',
          'Required parameter groupId was null or undefined when calling searchOutboundResourceInGroup.'
        )
      }
      const localVarPath = `/call_center/resource_group/{group_id}/resource`.replace(
        `{${'group_id'}}`,
        encodeURIComponent(String(groupId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update OutboundResourceGroup
     * @param {string} id
     * @param {EngineUpdateOutboundResourceGroupRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateOutboundResourceGroup: async (
      id: string,
      body: EngineUpdateOutboundResourceGroupRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateOutboundResourceGroup.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateOutboundResourceGroup.'
        )
      }
      const localVarPath = `/call_center/resource_group/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update OutboundResourceInGroup
     * @param {string} groupId
     * @param {string} id
     * @param {EngineUpdateOutboundResourceInGroupRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateOutboundResourceInGroup: async (
      groupId: string,
      id: string,
      body: EngineUpdateOutboundResourceInGroupRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'groupId' is not null or undefined
      if (groupId === null || groupId === undefined) {
        throw new RequiredError(
          'groupId',
          'Required parameter groupId was null or undefined when calling updateOutboundResourceInGroup.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateOutboundResourceInGroup.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateOutboundResourceInGroup.'
        )
      }
      const localVarPath = `/call_center/resource_group/{group_id}/resource/{id}`
        .replace(`{${'group_id'}}`, encodeURIComponent(String(groupId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * OutboundResourceGroupServiceApi - functional programming interface
 * @export
 */
export const OutboundResourceGroupServiceApiFp = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create OutboundResourceGroup
     * @param {EngineCreateOutboundResourceGroupRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createOutboundResourceGroup(
      body: EngineCreateOutboundResourceGroupRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineOutboundResourceGroup>
    > {
      const localVarAxiosArgs = await OutboundResourceGroupServiceApiAxiosParamCreator(
        configuration
      ).createOutboundResourceGroup(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create OutboundResourceGroup
     * @param {string} groupId
     * @param {EngineCreateOutboundResourceInGroupRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createOutboundResourceInGroup(
      groupId: string,
      body: EngineCreateOutboundResourceInGroupRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineOutboundResourceInGroup>
    > {
      const localVarAxiosArgs = await OutboundResourceGroupServiceApiAxiosParamCreator(
        configuration
      ).createOutboundResourceInGroup(groupId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Remove OutboundResourceGroup
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteOutboundResourceGroup(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineOutboundResourceGroup>
    > {
      const localVarAxiosArgs = await OutboundResourceGroupServiceApiAxiosParamCreator(
        configuration
      ).deleteOutboundResourceGroup(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Remove OutboundResourceInGroup
     * @param {string} groupId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteOutboundResourceInGroup(
      groupId: string,
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineOutboundResourceInGroup>
    > {
      const localVarAxiosArgs = await OutboundResourceGroupServiceApiAxiosParamCreator(
        configuration
      ).deleteOutboundResourceInGroup(groupId, id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary OutboundResourceGroup item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readOutboundResourceGroup(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineOutboundResourceGroup>
    > {
      const localVarAxiosArgs = await OutboundResourceGroupServiceApiAxiosParamCreator(
        configuration
      ).readOutboundResourceGroup(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary OutboundResourceInGroup item
     * @param {string} groupId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readOutboundResourceInGroup(
      groupId: string,
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineOutboundResourceInGroup>
    > {
      const localVarAxiosArgs = await OutboundResourceGroupServiceApiAxiosParamCreator(
        configuration
      ).readOutboundResourceInGroup(groupId, id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List of OutboundResourceGroup
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchOutboundResourceGroup(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListOutboundResourceGroup>
    > {
      const localVarAxiosArgs = await OutboundResourceGroupServiceApiAxiosParamCreator(
        configuration
      ).searchOutboundResourceGroup(page, size, q, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List of OutboundResourceInGroup
     * @param {string} groupId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchOutboundResourceInGroup(
      groupId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListOutboundResourceInGroup>
    > {
      const localVarAxiosArgs = await OutboundResourceGroupServiceApiAxiosParamCreator(
        configuration
      ).searchOutboundResourceInGroup(groupId, page, size, q, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update OutboundResourceGroup
     * @param {string} id
     * @param {EngineUpdateOutboundResourceGroupRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateOutboundResourceGroup(
      id: string,
      body: EngineUpdateOutboundResourceGroupRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineOutboundResourceGroup>
    > {
      const localVarAxiosArgs = await OutboundResourceGroupServiceApiAxiosParamCreator(
        configuration
      ).updateOutboundResourceGroup(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update OutboundResourceInGroup
     * @param {string} groupId
     * @param {string} id
     * @param {EngineUpdateOutboundResourceInGroupRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateOutboundResourceInGroup(
      groupId: string,
      id: string,
      body: EngineUpdateOutboundResourceInGroupRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineOutboundResourceInGroup>
    > {
      const localVarAxiosArgs = await OutboundResourceGroupServiceApiAxiosParamCreator(
        configuration
      ).updateOutboundResourceInGroup(groupId, id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * OutboundResourceGroupServiceApi - factory interface
 * @export
 */
export const OutboundResourceGroupServiceApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Create OutboundResourceGroup
     * @param {EngineCreateOutboundResourceGroupRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOutboundResourceGroup(
      body: EngineCreateOutboundResourceGroupRequest,
      options?: any
    ): AxiosPromise<EngineOutboundResourceGroup> {
      return OutboundResourceGroupServiceApiFp(configuration)
        .createOutboundResourceGroup(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create OutboundResourceGroup
     * @param {string} groupId
     * @param {EngineCreateOutboundResourceInGroupRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOutboundResourceInGroup(
      groupId: string,
      body: EngineCreateOutboundResourceInGroupRequest,
      options?: any
    ): AxiosPromise<EngineOutboundResourceInGroup> {
      return OutboundResourceGroupServiceApiFp(configuration)
        .createOutboundResourceInGroup(groupId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Remove OutboundResourceGroup
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOutboundResourceGroup(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineOutboundResourceGroup> {
      return OutboundResourceGroupServiceApiFp(configuration)
        .deleteOutboundResourceGroup(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Remove OutboundResourceInGroup
     * @param {string} groupId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOutboundResourceInGroup(
      groupId: string,
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineOutboundResourceInGroup> {
      return OutboundResourceGroupServiceApiFp(configuration)
        .deleteOutboundResourceInGroup(groupId, id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary OutboundResourceGroup item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readOutboundResourceGroup(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineOutboundResourceGroup> {
      return OutboundResourceGroupServiceApiFp(configuration)
        .readOutboundResourceGroup(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary OutboundResourceInGroup item
     * @param {string} groupId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readOutboundResourceInGroup(
      groupId: string,
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineOutboundResourceInGroup> {
      return OutboundResourceGroupServiceApiFp(configuration)
        .readOutboundResourceInGroup(groupId, id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List of OutboundResourceGroup
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchOutboundResourceGroup(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListOutboundResourceGroup> {
      return OutboundResourceGroupServiceApiFp(configuration)
        .searchOutboundResourceGroup(page, size, q, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List of OutboundResourceInGroup
     * @param {string} groupId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchOutboundResourceInGroup(
      groupId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListOutboundResourceInGroup> {
      return OutboundResourceGroupServiceApiFp(configuration)
        .searchOutboundResourceInGroup(
          groupId,
          page,
          size,
          q,
          domainId,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update OutboundResourceGroup
     * @param {string} id
     * @param {EngineUpdateOutboundResourceGroupRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateOutboundResourceGroup(
      id: string,
      body: EngineUpdateOutboundResourceGroupRequest,
      options?: any
    ): AxiosPromise<EngineOutboundResourceGroup> {
      return OutboundResourceGroupServiceApiFp(configuration)
        .updateOutboundResourceGroup(id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update OutboundResourceInGroup
     * @param {string} groupId
     * @param {string} id
     * @param {EngineUpdateOutboundResourceInGroupRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateOutboundResourceInGroup(
      groupId: string,
      id: string,
      body: EngineUpdateOutboundResourceInGroupRequest,
      options?: any
    ): AxiosPromise<EngineOutboundResourceInGroup> {
      return OutboundResourceGroupServiceApiFp(configuration)
        .updateOutboundResourceInGroup(groupId, id, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * OutboundResourceGroupServiceApi - object-oriented interface
 * @export
 * @class OutboundResourceGroupServiceApi
 * @extends {BaseAPI}
 */
export class OutboundResourceGroupServiceApi extends BaseAPI {
  /**
   *
   * @summary Create OutboundResourceGroup
   * @param {EngineCreateOutboundResourceGroupRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OutboundResourceGroupServiceApi
   */
  public createOutboundResourceGroup(
    body: EngineCreateOutboundResourceGroupRequest,
    options?: any
  ) {
    return OutboundResourceGroupServiceApiFp(this.configuration)
      .createOutboundResourceGroup(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create OutboundResourceGroup
   * @param {string} groupId
   * @param {EngineCreateOutboundResourceInGroupRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OutboundResourceGroupServiceApi
   */
  public createOutboundResourceInGroup(
    groupId: string,
    body: EngineCreateOutboundResourceInGroupRequest,
    options?: any
  ) {
    return OutboundResourceGroupServiceApiFp(this.configuration)
      .createOutboundResourceInGroup(groupId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Remove OutboundResourceGroup
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OutboundResourceGroupServiceApi
   */
  public deleteOutboundResourceGroup(
    id: string,
    domainId?: string,
    options?: any
  ) {
    return OutboundResourceGroupServiceApiFp(this.configuration)
      .deleteOutboundResourceGroup(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Remove OutboundResourceInGroup
   * @param {string} groupId
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OutboundResourceGroupServiceApi
   */
  public deleteOutboundResourceInGroup(
    groupId: string,
    id: string,
    domainId?: string,
    options?: any
  ) {
    return OutboundResourceGroupServiceApiFp(this.configuration)
      .deleteOutboundResourceInGroup(groupId, id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary OutboundResourceGroup item
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OutboundResourceGroupServiceApi
   */
  public readOutboundResourceGroup(
    id: string,
    domainId?: string,
    options?: any
  ) {
    return OutboundResourceGroupServiceApiFp(this.configuration)
      .readOutboundResourceGroup(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary OutboundResourceInGroup item
   * @param {string} groupId
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OutboundResourceGroupServiceApi
   */
  public readOutboundResourceInGroup(
    groupId: string,
    id: string,
    domainId?: string,
    options?: any
  ) {
    return OutboundResourceGroupServiceApiFp(this.configuration)
      .readOutboundResourceInGroup(groupId, id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List of OutboundResourceGroup
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OutboundResourceGroupServiceApi
   */
  public searchOutboundResourceGroup(
    page?: number,
    size?: number,
    q?: string,
    domainId?: string,
    options?: any
  ) {
    return OutboundResourceGroupServiceApiFp(this.configuration)
      .searchOutboundResourceGroup(page, size, q, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List of OutboundResourceInGroup
   * @param {string} groupId
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OutboundResourceGroupServiceApi
   */
  public searchOutboundResourceInGroup(
    groupId: string,
    page?: number,
    size?: number,
    q?: string,
    domainId?: string,
    options?: any
  ) {
    return OutboundResourceGroupServiceApiFp(this.configuration)
      .searchOutboundResourceInGroup(groupId, page, size, q, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update OutboundResourceGroup
   * @param {string} id
   * @param {EngineUpdateOutboundResourceGroupRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OutboundResourceGroupServiceApi
   */
  public updateOutboundResourceGroup(
    id: string,
    body: EngineUpdateOutboundResourceGroupRequest,
    options?: any
  ) {
    return OutboundResourceGroupServiceApiFp(this.configuration)
      .updateOutboundResourceGroup(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update OutboundResourceInGroup
   * @param {string} groupId
   * @param {string} id
   * @param {EngineUpdateOutboundResourceInGroupRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OutboundResourceGroupServiceApi
   */
  public updateOutboundResourceInGroup(
    groupId: string,
    id: string,
    body: EngineUpdateOutboundResourceInGroupRequest,
    options?: any
  ) {
    return OutboundResourceGroupServiceApiFp(this.configuration)
      .updateOutboundResourceInGroup(groupId, id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * OutboundResourceServiceApi - axios parameter creator
 * @export
 */
export const OutboundResourceServiceApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create OutboundResource
     * @param {EngineCreateOutboundResourceRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOutboundResource: async (
      body: EngineCreateOutboundResourceRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createOutboundResource.'
        )
      }
      const localVarPath = `/call_center/resources`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create CreateOutboundResourceDisplay
     * @param {string} resourceId
     * @param {EngineCreateOutboundResourceDisplayRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOutboundResourceDisplay: async (
      resourceId: string,
      body: EngineCreateOutboundResourceDisplayRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'resourceId' is not null or undefined
      if (resourceId === null || resourceId === undefined) {
        throw new RequiredError(
          'resourceId',
          'Required parameter resourceId was null or undefined when calling createOutboundResourceDisplay.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createOutboundResourceDisplay.'
        )
      }
      const localVarPath = `/call_center/resources/{resource_id}/display`.replace(
        `{${'resource_id'}}`,
        encodeURIComponent(String(resourceId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Remove OutboundResource
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOutboundResource: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteOutboundResource.'
        )
      }
      const localVarPath = `/call_center/resources/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Remove ResourceDisplay
     * @param {string} resourceId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOutboundResourceDisplay: async (
      resourceId: string,
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'resourceId' is not null or undefined
      if (resourceId === null || resourceId === undefined) {
        throw new RequiredError(
          'resourceId',
          'Required parameter resourceId was null or undefined when calling deleteOutboundResourceDisplay.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteOutboundResourceDisplay.'
        )
      }
      const localVarPath = `/call_center/resources/{resource_id}/display/{id}`
        .replace(`{${'resource_id'}}`, encodeURIComponent(String(resourceId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Patch OutboundResource
     * @param {string} id
     * @param {EnginePatchOutboundResourceRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchOutboundResource: async (
      id: string,
      body: EnginePatchOutboundResourceRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling patchOutboundResource.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling patchOutboundResource.'
        )
      }
      const localVarPath = `/call_center/resources/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary OutboundResource item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readOutboundResource: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readOutboundResource.'
        )
      }
      const localVarPath = `/call_center/resources/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary ResourceDisplay item
     * @param {string} resourceId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readOutboundResourceDisplay: async (
      resourceId: string,
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'resourceId' is not null or undefined
      if (resourceId === null || resourceId === undefined) {
        throw new RequiredError(
          'resourceId',
          'Required parameter resourceId was null or undefined when calling readOutboundResourceDisplay.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readOutboundResourceDisplay.'
        )
      }
      const localVarPath = `/call_center/resources/{resource_id}/display/{id}`
        .replace(`{${'resource_id'}}`, encodeURIComponent(String(resourceId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List of OutboundResource
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchOutboundResource: async (
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/call_center/resources`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List of ResourceDisplay
     * @param {string} resourceId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchOutboundResourceDisplay: async (
      resourceId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'resourceId' is not null or undefined
      if (resourceId === null || resourceId === undefined) {
        throw new RequiredError(
          'resourceId',
          'Required parameter resourceId was null or undefined when calling searchOutboundResourceDisplay.'
        )
      }
      const localVarPath = `/call_center/resources/{resource_id}/display`.replace(
        `{${'resource_id'}}`,
        encodeURIComponent(String(resourceId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update OutboundResource
     * @param {string} id
     * @param {EngineUpdateOutboundResourceRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateOutboundResource: async (
      id: string,
      body: EngineUpdateOutboundResourceRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateOutboundResource.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateOutboundResource.'
        )
      }
      const localVarPath = `/call_center/resources/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update ResourceDisplay
     * @param {string} resourceId
     * @param {string} id
     * @param {EngineUpdateOutboundResourceDisplayRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateOutboundResourceDisplay: async (
      resourceId: string,
      id: string,
      body: EngineUpdateOutboundResourceDisplayRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'resourceId' is not null or undefined
      if (resourceId === null || resourceId === undefined) {
        throw new RequiredError(
          'resourceId',
          'Required parameter resourceId was null or undefined when calling updateOutboundResourceDisplay.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateOutboundResourceDisplay.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateOutboundResourceDisplay.'
        )
      }
      const localVarPath = `/call_center/resources/{resource_id}/display/{id}`
        .replace(`{${'resource_id'}}`, encodeURIComponent(String(resourceId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * OutboundResourceServiceApi - functional programming interface
 * @export
 */
export const OutboundResourceServiceApiFp = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create OutboundResource
     * @param {EngineCreateOutboundResourceRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createOutboundResource(
      body: EngineCreateOutboundResourceRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineOutboundResource>
    > {
      const localVarAxiosArgs = await OutboundResourceServiceApiAxiosParamCreator(
        configuration
      ).createOutboundResource(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create CreateOutboundResourceDisplay
     * @param {string} resourceId
     * @param {EngineCreateOutboundResourceDisplayRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createOutboundResourceDisplay(
      resourceId: string,
      body: EngineCreateOutboundResourceDisplayRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineResourceDisplay>
    > {
      const localVarAxiosArgs = await OutboundResourceServiceApiAxiosParamCreator(
        configuration
      ).createOutboundResourceDisplay(resourceId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Remove OutboundResource
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteOutboundResource(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineOutboundResource>
    > {
      const localVarAxiosArgs = await OutboundResourceServiceApiAxiosParamCreator(
        configuration
      ).deleteOutboundResource(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Remove ResourceDisplay
     * @param {string} resourceId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteOutboundResourceDisplay(
      resourceId: string,
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineResourceDisplay>
    > {
      const localVarAxiosArgs = await OutboundResourceServiceApiAxiosParamCreator(
        configuration
      ).deleteOutboundResourceDisplay(resourceId, id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Patch OutboundResource
     * @param {string} id
     * @param {EnginePatchOutboundResourceRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchOutboundResource(
      id: string,
      body: EnginePatchOutboundResourceRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineOutboundResource>
    > {
      const localVarAxiosArgs = await OutboundResourceServiceApiAxiosParamCreator(
        configuration
      ).patchOutboundResource(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary OutboundResource item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readOutboundResource(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineOutboundResource>
    > {
      const localVarAxiosArgs = await OutboundResourceServiceApiAxiosParamCreator(
        configuration
      ).readOutboundResource(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary ResourceDisplay item
     * @param {string} resourceId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readOutboundResourceDisplay(
      resourceId: string,
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineResourceDisplay>
    > {
      const localVarAxiosArgs = await OutboundResourceServiceApiAxiosParamCreator(
        configuration
      ).readOutboundResourceDisplay(resourceId, id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List of OutboundResource
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchOutboundResource(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListOutboundResource>
    > {
      const localVarAxiosArgs = await OutboundResourceServiceApiAxiosParamCreator(
        configuration
      ).searchOutboundResource(page, size, q, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List of ResourceDisplay
     * @param {string} resourceId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchOutboundResourceDisplay(
      resourceId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListOutboundResourceDisplay>
    > {
      const localVarAxiosArgs = await OutboundResourceServiceApiAxiosParamCreator(
        configuration
      ).searchOutboundResourceDisplay(
        resourceId,
        page,
        size,
        q,
        domainId,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update OutboundResource
     * @param {string} id
     * @param {EngineUpdateOutboundResourceRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateOutboundResource(
      id: string,
      body: EngineUpdateOutboundResourceRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineOutboundResource>
    > {
      const localVarAxiosArgs = await OutboundResourceServiceApiAxiosParamCreator(
        configuration
      ).updateOutboundResource(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update ResourceDisplay
     * @param {string} resourceId
     * @param {string} id
     * @param {EngineUpdateOutboundResourceDisplayRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateOutboundResourceDisplay(
      resourceId: string,
      id: string,
      body: EngineUpdateOutboundResourceDisplayRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineResourceDisplay>
    > {
      const localVarAxiosArgs = await OutboundResourceServiceApiAxiosParamCreator(
        configuration
      ).updateOutboundResourceDisplay(resourceId, id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * OutboundResourceServiceApi - factory interface
 * @export
 */
export const OutboundResourceServiceApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Create OutboundResource
     * @param {EngineCreateOutboundResourceRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOutboundResource(
      body: EngineCreateOutboundResourceRequest,
      options?: any
    ): AxiosPromise<EngineOutboundResource> {
      return OutboundResourceServiceApiFp(configuration)
        .createOutboundResource(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create CreateOutboundResourceDisplay
     * @param {string} resourceId
     * @param {EngineCreateOutboundResourceDisplayRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOutboundResourceDisplay(
      resourceId: string,
      body: EngineCreateOutboundResourceDisplayRequest,
      options?: any
    ): AxiosPromise<EngineResourceDisplay> {
      return OutboundResourceServiceApiFp(configuration)
        .createOutboundResourceDisplay(resourceId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Remove OutboundResource
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOutboundResource(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineOutboundResource> {
      return OutboundResourceServiceApiFp(configuration)
        .deleteOutboundResource(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Remove ResourceDisplay
     * @param {string} resourceId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteOutboundResourceDisplay(
      resourceId: string,
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineResourceDisplay> {
      return OutboundResourceServiceApiFp(configuration)
        .deleteOutboundResourceDisplay(resourceId, id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Patch OutboundResource
     * @param {string} id
     * @param {EnginePatchOutboundResourceRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchOutboundResource(
      id: string,
      body: EnginePatchOutboundResourceRequest,
      options?: any
    ): AxiosPromise<EngineOutboundResource> {
      return OutboundResourceServiceApiFp(configuration)
        .patchOutboundResource(id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary OutboundResource item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readOutboundResource(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineOutboundResource> {
      return OutboundResourceServiceApiFp(configuration)
        .readOutboundResource(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary ResourceDisplay item
     * @param {string} resourceId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readOutboundResourceDisplay(
      resourceId: string,
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineResourceDisplay> {
      return OutboundResourceServiceApiFp(configuration)
        .readOutboundResourceDisplay(resourceId, id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List of OutboundResource
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchOutboundResource(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListOutboundResource> {
      return OutboundResourceServiceApiFp(configuration)
        .searchOutboundResource(page, size, q, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List of ResourceDisplay
     * @param {string} resourceId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchOutboundResourceDisplay(
      resourceId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListOutboundResourceDisplay> {
      return OutboundResourceServiceApiFp(configuration)
        .searchOutboundResourceDisplay(
          resourceId,
          page,
          size,
          q,
          domainId,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update OutboundResource
     * @param {string} id
     * @param {EngineUpdateOutboundResourceRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateOutboundResource(
      id: string,
      body: EngineUpdateOutboundResourceRequest,
      options?: any
    ): AxiosPromise<EngineOutboundResource> {
      return OutboundResourceServiceApiFp(configuration)
        .updateOutboundResource(id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update ResourceDisplay
     * @param {string} resourceId
     * @param {string} id
     * @param {EngineUpdateOutboundResourceDisplayRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateOutboundResourceDisplay(
      resourceId: string,
      id: string,
      body: EngineUpdateOutboundResourceDisplayRequest,
      options?: any
    ): AxiosPromise<EngineResourceDisplay> {
      return OutboundResourceServiceApiFp(configuration)
        .updateOutboundResourceDisplay(resourceId, id, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * OutboundResourceServiceApi - object-oriented interface
 * @export
 * @class OutboundResourceServiceApi
 * @extends {BaseAPI}
 */
export class OutboundResourceServiceApi extends BaseAPI {
  /**
   *
   * @summary Create OutboundResource
   * @param {EngineCreateOutboundResourceRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OutboundResourceServiceApi
   */
  public createOutboundResource(
    body: EngineCreateOutboundResourceRequest,
    options?: any
  ) {
    return OutboundResourceServiceApiFp(this.configuration)
      .createOutboundResource(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create CreateOutboundResourceDisplay
   * @param {string} resourceId
   * @param {EngineCreateOutboundResourceDisplayRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OutboundResourceServiceApi
   */
  public createOutboundResourceDisplay(
    resourceId: string,
    body: EngineCreateOutboundResourceDisplayRequest,
    options?: any
  ) {
    return OutboundResourceServiceApiFp(this.configuration)
      .createOutboundResourceDisplay(resourceId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Remove OutboundResource
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OutboundResourceServiceApi
   */
  public deleteOutboundResource(id: string, domainId?: string, options?: any) {
    return OutboundResourceServiceApiFp(this.configuration)
      .deleteOutboundResource(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Remove ResourceDisplay
   * @param {string} resourceId
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OutboundResourceServiceApi
   */
  public deleteOutboundResourceDisplay(
    resourceId: string,
    id: string,
    domainId?: string,
    options?: any
  ) {
    return OutboundResourceServiceApiFp(this.configuration)
      .deleteOutboundResourceDisplay(resourceId, id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Patch OutboundResource
   * @param {string} id
   * @param {EnginePatchOutboundResourceRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OutboundResourceServiceApi
   */
  public patchOutboundResource(
    id: string,
    body: EnginePatchOutboundResourceRequest,
    options?: any
  ) {
    return OutboundResourceServiceApiFp(this.configuration)
      .patchOutboundResource(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary OutboundResource item
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OutboundResourceServiceApi
   */
  public readOutboundResource(id: string, domainId?: string, options?: any) {
    return OutboundResourceServiceApiFp(this.configuration)
      .readOutboundResource(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary ResourceDisplay item
   * @param {string} resourceId
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OutboundResourceServiceApi
   */
  public readOutboundResourceDisplay(
    resourceId: string,
    id: string,
    domainId?: string,
    options?: any
  ) {
    return OutboundResourceServiceApiFp(this.configuration)
      .readOutboundResourceDisplay(resourceId, id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List of OutboundResource
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OutboundResourceServiceApi
   */
  public searchOutboundResource(
    page?: number,
    size?: number,
    q?: string,
    domainId?: string,
    options?: any
  ) {
    return OutboundResourceServiceApiFp(this.configuration)
      .searchOutboundResource(page, size, q, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List of ResourceDisplay
   * @param {string} resourceId
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OutboundResourceServiceApi
   */
  public searchOutboundResourceDisplay(
    resourceId: string,
    page?: number,
    size?: number,
    q?: string,
    domainId?: string,
    options?: any
  ) {
    return OutboundResourceServiceApiFp(this.configuration)
      .searchOutboundResourceDisplay(
        resourceId,
        page,
        size,
        q,
        domainId,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update OutboundResource
   * @param {string} id
   * @param {EngineUpdateOutboundResourceRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OutboundResourceServiceApi
   */
  public updateOutboundResource(
    id: string,
    body: EngineUpdateOutboundResourceRequest,
    options?: any
  ) {
    return OutboundResourceServiceApiFp(this.configuration)
      .updateOutboundResource(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update ResourceDisplay
   * @param {string} resourceId
   * @param {string} id
   * @param {EngineUpdateOutboundResourceDisplayRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OutboundResourceServiceApi
   */
  public updateOutboundResourceDisplay(
    resourceId: string,
    id: string,
    body: EngineUpdateOutboundResourceDisplayRequest,
    options?: any
  ) {
    return OutboundResourceServiceApiFp(this.configuration)
      .updateOutboundResourceDisplay(resourceId, id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * QueueBucketServiceApi - axios parameter creator
 * @export
 */
export const QueueBucketServiceApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create QueueBucket
     * @param {string} queueId
     * @param {EngineCreateQueueBucketRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createQueueBucket: async (
      queueId: string,
      body: EngineCreateQueueBucketRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling createQueueBucket.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createQueueBucket.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/buckets`.replace(
        `{${'queue_id'}}`,
        encodeURIComponent(String(queueId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary DeleteQueueRouting
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueueBucket: async (
      queueId: string,
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling deleteQueueBucket.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteQueueBucket.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/buckets/{id}`
        .replace(`{${'queue_id'}}`, encodeURIComponent(String(queueId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary ReadQueueRouting
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readQueueBucket: async (
      queueId: string,
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling readQueueBucket.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readQueueBucket.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/buckets/{id}`
        .replace(`{${'queue_id'}}`, encodeURIComponent(String(queueId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary SearchQueueRouting
     * @param {string} queueId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchQueueBucket: async (
      queueId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling searchQueueBucket.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/buckets`.replace(
        `{${'queue_id'}}`,
        encodeURIComponent(String(queueId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary UpdateQueueBucket
     * @param {string} queueId
     * @param {string} id
     * @param {EngineUpdateQueueBucketRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateQueueBucket: async (
      queueId: string,
      id: string,
      body: EngineUpdateQueueBucketRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling updateQueueBucket.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateQueueBucket.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateQueueBucket.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/buckets/{id}`
        .replace(`{${'queue_id'}}`, encodeURIComponent(String(queueId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * QueueBucketServiceApi - functional programming interface
 * @export
 */
export const QueueBucketServiceApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create QueueBucket
     * @param {string} queueId
     * @param {EngineCreateQueueBucketRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createQueueBucket(
      queueId: string,
      body: EngineCreateQueueBucketRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineQueueBucket>
    > {
      const localVarAxiosArgs = await QueueBucketServiceApiAxiosParamCreator(
        configuration
      ).createQueueBucket(queueId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary DeleteQueueRouting
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteQueueBucket(
      queueId: string,
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineQueueBucket>
    > {
      const localVarAxiosArgs = await QueueBucketServiceApiAxiosParamCreator(
        configuration
      ).deleteQueueBucket(queueId, id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary ReadQueueRouting
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readQueueBucket(
      queueId: string,
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineQueueBucket>
    > {
      const localVarAxiosArgs = await QueueBucketServiceApiAxiosParamCreator(
        configuration
      ).readQueueBucket(queueId, id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary SearchQueueRouting
     * @param {string} queueId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchQueueBucket(
      queueId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListQueueBucket>
    > {
      const localVarAxiosArgs = await QueueBucketServiceApiAxiosParamCreator(
        configuration
      ).searchQueueBucket(queueId, page, size, q, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary UpdateQueueBucket
     * @param {string} queueId
     * @param {string} id
     * @param {EngineUpdateQueueBucketRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateQueueBucket(
      queueId: string,
      id: string,
      body: EngineUpdateQueueBucketRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineQueueBucket>
    > {
      const localVarAxiosArgs = await QueueBucketServiceApiAxiosParamCreator(
        configuration
      ).updateQueueBucket(queueId, id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * QueueBucketServiceApi - factory interface
 * @export
 */
export const QueueBucketServiceApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Create QueueBucket
     * @param {string} queueId
     * @param {EngineCreateQueueBucketRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createQueueBucket(
      queueId: string,
      body: EngineCreateQueueBucketRequest,
      options?: any
    ): AxiosPromise<EngineQueueBucket> {
      return QueueBucketServiceApiFp(configuration)
        .createQueueBucket(queueId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary DeleteQueueRouting
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueueBucket(
      queueId: string,
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineQueueBucket> {
      return QueueBucketServiceApiFp(configuration)
        .deleteQueueBucket(queueId, id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary ReadQueueRouting
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readQueueBucket(
      queueId: string,
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineQueueBucket> {
      return QueueBucketServiceApiFp(configuration)
        .readQueueBucket(queueId, id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary SearchQueueRouting
     * @param {string} queueId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchQueueBucket(
      queueId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListQueueBucket> {
      return QueueBucketServiceApiFp(configuration)
        .searchQueueBucket(queueId, page, size, q, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary UpdateQueueBucket
     * @param {string} queueId
     * @param {string} id
     * @param {EngineUpdateQueueBucketRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateQueueBucket(
      queueId: string,
      id: string,
      body: EngineUpdateQueueBucketRequest,
      options?: any
    ): AxiosPromise<EngineQueueBucket> {
      return QueueBucketServiceApiFp(configuration)
        .updateQueueBucket(queueId, id, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * QueueBucketServiceApi - object-oriented interface
 * @export
 * @class QueueBucketServiceApi
 * @extends {BaseAPI}
 */
export class QueueBucketServiceApi extends BaseAPI {
  /**
   *
   * @summary Create QueueBucket
   * @param {string} queueId
   * @param {EngineCreateQueueBucketRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueueBucketServiceApi
   */
  public createQueueBucket(
    queueId: string,
    body: EngineCreateQueueBucketRequest,
    options?: any
  ) {
    return QueueBucketServiceApiFp(this.configuration)
      .createQueueBucket(queueId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary DeleteQueueRouting
   * @param {string} queueId
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueueBucketServiceApi
   */
  public deleteQueueBucket(
    queueId: string,
    id: string,
    domainId?: string,
    options?: any
  ) {
    return QueueBucketServiceApiFp(this.configuration)
      .deleteQueueBucket(queueId, id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary ReadQueueRouting
   * @param {string} queueId
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueueBucketServiceApi
   */
  public readQueueBucket(
    queueId: string,
    id: string,
    domainId?: string,
    options?: any
  ) {
    return QueueBucketServiceApiFp(this.configuration)
      .readQueueBucket(queueId, id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary SearchQueueRouting
   * @param {string} queueId
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueueBucketServiceApi
   */
  public searchQueueBucket(
    queueId: string,
    page?: number,
    size?: number,
    q?: string,
    domainId?: string,
    options?: any
  ) {
    return QueueBucketServiceApiFp(this.configuration)
      .searchQueueBucket(queueId, page, size, q, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary UpdateQueueBucket
   * @param {string} queueId
   * @param {string} id
   * @param {EngineUpdateQueueBucketRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueueBucketServiceApi
   */
  public updateQueueBucket(
    queueId: string,
    id: string,
    body: EngineUpdateQueueBucketRequest,
    options?: any
  ) {
    return QueueBucketServiceApiFp(this.configuration)
      .updateQueueBucket(queueId, id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * QueueResourcesServiceApi - axios parameter creator
 * @export
 */
export const QueueResourcesServiceApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary CreateQueueResourceGroup
     * @param {string} queueId
     * @param {EngineCreateQueueResourceGroupRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createQueueResourceGroup: async (
      queueId: string,
      body: EngineCreateQueueResourceGroupRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling createQueueResourceGroup.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createQueueResourceGroup.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/resource_groups`.replace(
        `{${'queue_id'}}`,
        encodeURIComponent(String(queueId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary DeleteQueueResourceGroup
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueueResourceGroup: async (
      queueId: string,
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling deleteQueueResourceGroup.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteQueueResourceGroup.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/resource_groups/{id}`
        .replace(`{${'queue_id'}}`, encodeURIComponent(String(queueId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary ReadQueueResourceGroup
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readQueueResourceGroup: async (
      queueId: string,
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling readQueueResourceGroup.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readQueueResourceGroup.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/resource_groups/{id}`
        .replace(`{${'queue_id'}}`, encodeURIComponent(String(queueId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary SearchQueueResourceGroup
     * @param {string} queueId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchQueueResourceGroup: async (
      queueId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling searchQueueResourceGroup.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/resource_groups`.replace(
        `{${'queue_id'}}`,
        encodeURIComponent(String(queueId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary UpdateQueueResourceGroup
     * @param {string} queueId
     * @param {string} id
     * @param {EngineUpdateQueueResourceGroupRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateQueueResourceGroup: async (
      queueId: string,
      id: string,
      body: EngineUpdateQueueResourceGroupRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling updateQueueResourceGroup.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateQueueResourceGroup.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateQueueResourceGroup.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/resource_groups/{id}`
        .replace(`{${'queue_id'}}`, encodeURIComponent(String(queueId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * QueueResourcesServiceApi - functional programming interface
 * @export
 */
export const QueueResourcesServiceApiFp = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary CreateQueueResourceGroup
     * @param {string} queueId
     * @param {EngineCreateQueueResourceGroupRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createQueueResourceGroup(
      queueId: string,
      body: EngineCreateQueueResourceGroupRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineQueueResourceGroup>
    > {
      const localVarAxiosArgs = await QueueResourcesServiceApiAxiosParamCreator(
        configuration
      ).createQueueResourceGroup(queueId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary DeleteQueueResourceGroup
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteQueueResourceGroup(
      queueId: string,
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineQueueResourceGroup>
    > {
      const localVarAxiosArgs = await QueueResourcesServiceApiAxiosParamCreator(
        configuration
      ).deleteQueueResourceGroup(queueId, id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary ReadQueueResourceGroup
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readQueueResourceGroup(
      queueId: string,
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineQueueResourceGroup>
    > {
      const localVarAxiosArgs = await QueueResourcesServiceApiAxiosParamCreator(
        configuration
      ).readQueueResourceGroup(queueId, id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary SearchQueueResourceGroup
     * @param {string} queueId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchQueueResourceGroup(
      queueId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListQueueResourceGroup>
    > {
      const localVarAxiosArgs = await QueueResourcesServiceApiAxiosParamCreator(
        configuration
      ).searchQueueResourceGroup(queueId, page, size, q, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary UpdateQueueResourceGroup
     * @param {string} queueId
     * @param {string} id
     * @param {EngineUpdateQueueResourceGroupRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateQueueResourceGroup(
      queueId: string,
      id: string,
      body: EngineUpdateQueueResourceGroupRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineQueueResourceGroup>
    > {
      const localVarAxiosArgs = await QueueResourcesServiceApiAxiosParamCreator(
        configuration
      ).updateQueueResourceGroup(queueId, id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * QueueResourcesServiceApi - factory interface
 * @export
 */
export const QueueResourcesServiceApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary CreateQueueResourceGroup
     * @param {string} queueId
     * @param {EngineCreateQueueResourceGroupRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createQueueResourceGroup(
      queueId: string,
      body: EngineCreateQueueResourceGroupRequest,
      options?: any
    ): AxiosPromise<EngineQueueResourceGroup> {
      return QueueResourcesServiceApiFp(configuration)
        .createQueueResourceGroup(queueId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary DeleteQueueResourceGroup
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueueResourceGroup(
      queueId: string,
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineQueueResourceGroup> {
      return QueueResourcesServiceApiFp(configuration)
        .deleteQueueResourceGroup(queueId, id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary ReadQueueResourceGroup
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readQueueResourceGroup(
      queueId: string,
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineQueueResourceGroup> {
      return QueueResourcesServiceApiFp(configuration)
        .readQueueResourceGroup(queueId, id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary SearchQueueResourceGroup
     * @param {string} queueId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchQueueResourceGroup(
      queueId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListQueueResourceGroup> {
      return QueueResourcesServiceApiFp(configuration)
        .searchQueueResourceGroup(queueId, page, size, q, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary UpdateQueueResourceGroup
     * @param {string} queueId
     * @param {string} id
     * @param {EngineUpdateQueueResourceGroupRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateQueueResourceGroup(
      queueId: string,
      id: string,
      body: EngineUpdateQueueResourceGroupRequest,
      options?: any
    ): AxiosPromise<EngineQueueResourceGroup> {
      return QueueResourcesServiceApiFp(configuration)
        .updateQueueResourceGroup(queueId, id, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * QueueResourcesServiceApi - object-oriented interface
 * @export
 * @class QueueResourcesServiceApi
 * @extends {BaseAPI}
 */
export class QueueResourcesServiceApi extends BaseAPI {
  /**
   *
   * @summary CreateQueueResourceGroup
   * @param {string} queueId
   * @param {EngineCreateQueueResourceGroupRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueueResourcesServiceApi
   */
  public createQueueResourceGroup(
    queueId: string,
    body: EngineCreateQueueResourceGroupRequest,
    options?: any
  ) {
    return QueueResourcesServiceApiFp(this.configuration)
      .createQueueResourceGroup(queueId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary DeleteQueueResourceGroup
   * @param {string} queueId
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueueResourcesServiceApi
   */
  public deleteQueueResourceGroup(
    queueId: string,
    id: string,
    domainId?: string,
    options?: any
  ) {
    return QueueResourcesServiceApiFp(this.configuration)
      .deleteQueueResourceGroup(queueId, id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary ReadQueueResourceGroup
   * @param {string} queueId
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueueResourcesServiceApi
   */
  public readQueueResourceGroup(
    queueId: string,
    id: string,
    domainId?: string,
    options?: any
  ) {
    return QueueResourcesServiceApiFp(this.configuration)
      .readQueueResourceGroup(queueId, id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary SearchQueueResourceGroup
   * @param {string} queueId
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueueResourcesServiceApi
   */
  public searchQueueResourceGroup(
    queueId: string,
    page?: number,
    size?: number,
    q?: string,
    domainId?: string,
    options?: any
  ) {
    return QueueResourcesServiceApiFp(this.configuration)
      .searchQueueResourceGroup(queueId, page, size, q, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary UpdateQueueResourceGroup
   * @param {string} queueId
   * @param {string} id
   * @param {EngineUpdateQueueResourceGroupRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueueResourcesServiceApi
   */
  public updateQueueResourceGroup(
    queueId: string,
    id: string,
    body: EngineUpdateQueueResourceGroupRequest,
    options?: any
  ) {
    return QueueResourcesServiceApiFp(this.configuration)
      .updateQueueResourceGroup(queueId, id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * QueueRoutingServiceApi - axios parameter creator
 * @export
 */
export const QueueRoutingServiceApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary CreateQueueRouting
     * @param {string} queueId
     * @param {EngineCreateQueueRoutingRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createQueueRouting: async (
      queueId: string,
      body: EngineCreateQueueRoutingRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling createQueueRouting.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createQueueRouting.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/routings`.replace(
        `{${'queue_id'}}`,
        encodeURIComponent(String(queueId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary DeleteQueueRouting
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueueRouting: async (
      queueId: string,
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling deleteQueueRouting.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteQueueRouting.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/routings/{id}`
        .replace(`{${'queue_id'}}`, encodeURIComponent(String(queueId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary ReadQueueRouting
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readQueueRouting: async (
      queueId: string,
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling readQueueRouting.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readQueueRouting.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/routings/{id}`
        .replace(`{${'queue_id'}}`, encodeURIComponent(String(queueId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary SearchQueueRouting
     * @param {string} queueId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchQueueRouting: async (
      queueId: string,
      page?: number,
      size?: number,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling searchQueueRouting.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/routings`.replace(
        `{${'queue_id'}}`,
        encodeURIComponent(String(queueId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary UpdateQueueRouting
     * @param {string} queueId
     * @param {string} id
     * @param {EngineUpdateQueueRoutingRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateQueueRouting: async (
      queueId: string,
      id: string,
      body: EngineUpdateQueueRoutingRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queueId' is not null or undefined
      if (queueId === null || queueId === undefined) {
        throw new RequiredError(
          'queueId',
          'Required parameter queueId was null or undefined when calling updateQueueRouting.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateQueueRouting.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateQueueRouting.'
        )
      }
      const localVarPath = `/call_center/queues/{queue_id}/routings/{id}`
        .replace(`{${'queue_id'}}`, encodeURIComponent(String(queueId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * QueueRoutingServiceApi - functional programming interface
 * @export
 */
export const QueueRoutingServiceApiFp = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary CreateQueueRouting
     * @param {string} queueId
     * @param {EngineCreateQueueRoutingRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createQueueRouting(
      queueId: string,
      body: EngineCreateQueueRoutingRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineQueueRouting>
    > {
      const localVarAxiosArgs = await QueueRoutingServiceApiAxiosParamCreator(
        configuration
      ).createQueueRouting(queueId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary DeleteQueueRouting
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteQueueRouting(
      queueId: string,
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineQueueRouting>
    > {
      const localVarAxiosArgs = await QueueRoutingServiceApiAxiosParamCreator(
        configuration
      ).deleteQueueRouting(queueId, id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary ReadQueueRouting
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readQueueRouting(
      queueId: string,
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineQueueRouting>
    > {
      const localVarAxiosArgs = await QueueRoutingServiceApiAxiosParamCreator(
        configuration
      ).readQueueRouting(queueId, id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary SearchQueueRouting
     * @param {string} queueId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchQueueRouting(
      queueId: string,
      page?: number,
      size?: number,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListQueueRouting>
    > {
      const localVarAxiosArgs = await QueueRoutingServiceApiAxiosParamCreator(
        configuration
      ).searchQueueRouting(queueId, page, size, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary UpdateQueueRouting
     * @param {string} queueId
     * @param {string} id
     * @param {EngineUpdateQueueRoutingRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateQueueRouting(
      queueId: string,
      id: string,
      body: EngineUpdateQueueRoutingRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineQueueRouting>
    > {
      const localVarAxiosArgs = await QueueRoutingServiceApiAxiosParamCreator(
        configuration
      ).updateQueueRouting(queueId, id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * QueueRoutingServiceApi - factory interface
 * @export
 */
export const QueueRoutingServiceApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary CreateQueueRouting
     * @param {string} queueId
     * @param {EngineCreateQueueRoutingRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createQueueRouting(
      queueId: string,
      body: EngineCreateQueueRoutingRequest,
      options?: any
    ): AxiosPromise<EngineQueueRouting> {
      return QueueRoutingServiceApiFp(configuration)
        .createQueueRouting(queueId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary DeleteQueueRouting
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueueRouting(
      queueId: string,
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineQueueRouting> {
      return QueueRoutingServiceApiFp(configuration)
        .deleteQueueRouting(queueId, id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary ReadQueueRouting
     * @param {string} queueId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readQueueRouting(
      queueId: string,
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineQueueRouting> {
      return QueueRoutingServiceApiFp(configuration)
        .readQueueRouting(queueId, id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary SearchQueueRouting
     * @param {string} queueId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchQueueRouting(
      queueId: string,
      page?: number,
      size?: number,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListQueueRouting> {
      return QueueRoutingServiceApiFp(configuration)
        .searchQueueRouting(queueId, page, size, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary UpdateQueueRouting
     * @param {string} queueId
     * @param {string} id
     * @param {EngineUpdateQueueRoutingRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateQueueRouting(
      queueId: string,
      id: string,
      body: EngineUpdateQueueRoutingRequest,
      options?: any
    ): AxiosPromise<EngineQueueRouting> {
      return QueueRoutingServiceApiFp(configuration)
        .updateQueueRouting(queueId, id, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * QueueRoutingServiceApi - object-oriented interface
 * @export
 * @class QueueRoutingServiceApi
 * @extends {BaseAPI}
 */
export class QueueRoutingServiceApi extends BaseAPI {
  /**
   *
   * @summary CreateQueueRouting
   * @param {string} queueId
   * @param {EngineCreateQueueRoutingRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueueRoutingServiceApi
   */
  public createQueueRouting(
    queueId: string,
    body: EngineCreateQueueRoutingRequest,
    options?: any
  ) {
    return QueueRoutingServiceApiFp(this.configuration)
      .createQueueRouting(queueId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary DeleteQueueRouting
   * @param {string} queueId
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueueRoutingServiceApi
   */
  public deleteQueueRouting(
    queueId: string,
    id: string,
    domainId?: string,
    options?: any
  ) {
    return QueueRoutingServiceApiFp(this.configuration)
      .deleteQueueRouting(queueId, id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary ReadQueueRouting
   * @param {string} queueId
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueueRoutingServiceApi
   */
  public readQueueRouting(
    queueId: string,
    id: string,
    domainId?: string,
    options?: any
  ) {
    return QueueRoutingServiceApiFp(this.configuration)
      .readQueueRouting(queueId, id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary SearchQueueRouting
   * @param {string} queueId
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueueRoutingServiceApi
   */
  public searchQueueRouting(
    queueId: string,
    page?: number,
    size?: number,
    domainId?: string,
    options?: any
  ) {
    return QueueRoutingServiceApiFp(this.configuration)
      .searchQueueRouting(queueId, page, size, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary UpdateQueueRouting
   * @param {string} queueId
   * @param {string} id
   * @param {EngineUpdateQueueRoutingRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueueRoutingServiceApi
   */
  public updateQueueRouting(
    queueId: string,
    id: string,
    body: EngineUpdateQueueRoutingRequest,
    options?: any
  ) {
    return QueueRoutingServiceApiFp(this.configuration)
      .updateQueueRouting(queueId, id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * QueueServiceApi - axios parameter creator
 * @export
 */
export const QueueServiceApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create Queue
     * @param {EngineCreateQueueRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createQueue: async (
      body: EngineCreateQueueRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createQueue.'
        )
      }
      const localVarPath = `/call_center/queues`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Remove Queue
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueue: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteQueue.'
        )
      }
      const localVarPath = `/call_center/queues/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Patch Queue
     * @param {string} id
     * @param {EnginePatchQueueRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchQueue: async (
      id: string,
      body: EnginePatchQueueRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling patchQueue.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling patchQueue.'
        )
      }
      const localVarPath = `/call_center/queues/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Queue item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readQueue: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readQueue.'
        )
      }
      const localVarPath = `/call_center/queues/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List of Queue
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {Array<string>} [id]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchQueue: async (
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      fields?: Array<string>,
      sort?: string,
      id?: Array<string>,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/call_center/queues`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (id) {
        localVarQueryParameter['id'] = id
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [joinedAtFrom]
     * @param {string} [joinedAtTo]
     * @param {string} [domainId]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {string} [q]
     * @param {Array<number>} [queueId]
     * @param {Array<number>} [teamId]
     * @param {Array<number>} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchQueueReportGeneral: async (
      page?: number,
      size?: number,
      joinedAtFrom?: string,
      joinedAtTo?: string,
      domainId?: string,
      fields?: Array<string>,
      sort?: string,
      q?: string,
      queueId?: Array<number>,
      teamId?: Array<number>,
      type?: Array<number>,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/call_center/queues/reports/general`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (joinedAtFrom !== undefined) {
        localVarQueryParameter['joined_at.from'] = joinedAtFrom
      }

      if (joinedAtTo !== undefined) {
        localVarQueryParameter['joined_at.to'] = joinedAtTo
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      if (fields) {
        localVarQueryParameter['fields'] = fields
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (queueId) {
        localVarQueryParameter['queue_id'] = queueId
      }

      if (teamId) {
        localVarQueryParameter['team_id'] = teamId
      }

      if (type) {
        localVarQueryParameter['type'] = type
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update Queue
     * @param {string} id
     * @param {EngineUpdateQueueRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateQueue: async (
      id: string,
      body: EngineUpdateQueueRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateQueue.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateQueue.'
        )
      }
      const localVarPath = `/call_center/queues/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * QueueServiceApi - functional programming interface
 * @export
 */
export const QueueServiceApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create Queue
     * @param {EngineCreateQueueRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createQueue(
      body: EngineCreateQueueRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineQueue>
    > {
      const localVarAxiosArgs = await QueueServiceApiAxiosParamCreator(
        configuration
      ).createQueue(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Remove Queue
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteQueue(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineQueue>
    > {
      const localVarAxiosArgs = await QueueServiceApiAxiosParamCreator(
        configuration
      ).deleteQueue(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Patch Queue
     * @param {string} id
     * @param {EnginePatchQueueRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchQueue(
      id: string,
      body: EnginePatchQueueRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineQueue>
    > {
      const localVarAxiosArgs = await QueueServiceApiAxiosParamCreator(
        configuration
      ).patchQueue(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Queue item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readQueue(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineQueue>
    > {
      const localVarAxiosArgs = await QueueServiceApiAxiosParamCreator(
        configuration
      ).readQueue(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List of Queue
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {Array<string>} [id]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchQueue(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      fields?: Array<string>,
      sort?: string,
      id?: Array<string>,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListQueue>
    > {
      const localVarAxiosArgs = await QueueServiceApiAxiosParamCreator(
        configuration
      ).searchQueue(page, size, q, domainId, fields, sort, id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [joinedAtFrom]
     * @param {string} [joinedAtTo]
     * @param {string} [domainId]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {string} [q]
     * @param {Array<number>} [queueId]
     * @param {Array<number>} [teamId]
     * @param {Array<number>} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchQueueReportGeneral(
      page?: number,
      size?: number,
      joinedAtFrom?: string,
      joinedAtTo?: string,
      domainId?: string,
      fields?: Array<string>,
      sort?: string,
      q?: string,
      queueId?: Array<number>,
      teamId?: Array<number>,
      type?: Array<number>,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListReportGeneral>
    > {
      const localVarAxiosArgs = await QueueServiceApiAxiosParamCreator(
        configuration
      ).searchQueueReportGeneral(
        page,
        size,
        joinedAtFrom,
        joinedAtTo,
        domainId,
        fields,
        sort,
        q,
        queueId,
        teamId,
        type,
        options
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update Queue
     * @param {string} id
     * @param {EngineUpdateQueueRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateQueue(
      id: string,
      body: EngineUpdateQueueRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineQueue>
    > {
      const localVarAxiosArgs = await QueueServiceApiAxiosParamCreator(
        configuration
      ).updateQueue(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * QueueServiceApi - factory interface
 * @export
 */
export const QueueServiceApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Create Queue
     * @param {EngineCreateQueueRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createQueue(
      body: EngineCreateQueueRequest,
      options?: any
    ): AxiosPromise<EngineQueue> {
      return QueueServiceApiFp(configuration)
        .createQueue(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Remove Queue
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueue(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineQueue> {
      return QueueServiceApiFp(configuration)
        .deleteQueue(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Patch Queue
     * @param {string} id
     * @param {EnginePatchQueueRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchQueue(
      id: string,
      body: EnginePatchQueueRequest,
      options?: any
    ): AxiosPromise<EngineQueue> {
      return QueueServiceApiFp(configuration)
        .patchQueue(id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Queue item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readQueue(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineQueue> {
      return QueueServiceApiFp(configuration)
        .readQueue(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List of Queue
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {Array<string>} [id]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchQueue(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      fields?: Array<string>,
      sort?: string,
      id?: Array<string>,
      options?: any
    ): AxiosPromise<EngineListQueue> {
      return QueueServiceApiFp(configuration)
        .searchQueue(page, size, q, domainId, fields, sort, id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [joinedAtFrom]
     * @param {string} [joinedAtTo]
     * @param {string} [domainId]
     * @param {Array<string>} [fields]
     * @param {string} [sort]
     * @param {string} [q]
     * @param {Array<number>} [queueId]
     * @param {Array<number>} [teamId]
     * @param {Array<number>} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchQueueReportGeneral(
      page?: number,
      size?: number,
      joinedAtFrom?: string,
      joinedAtTo?: string,
      domainId?: string,
      fields?: Array<string>,
      sort?: string,
      q?: string,
      queueId?: Array<number>,
      teamId?: Array<number>,
      type?: Array<number>,
      options?: any
    ): AxiosPromise<EngineListReportGeneral> {
      return QueueServiceApiFp(configuration)
        .searchQueueReportGeneral(
          page,
          size,
          joinedAtFrom,
          joinedAtTo,
          domainId,
          fields,
          sort,
          q,
          queueId,
          teamId,
          type,
          options
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update Queue
     * @param {string} id
     * @param {EngineUpdateQueueRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateQueue(
      id: string,
      body: EngineUpdateQueueRequest,
      options?: any
    ): AxiosPromise<EngineQueue> {
      return QueueServiceApiFp(configuration)
        .updateQueue(id, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * QueueServiceApi - object-oriented interface
 * @export
 * @class QueueServiceApi
 * @extends {BaseAPI}
 */
export class QueueServiceApi extends BaseAPI {
  /**
   *
   * @summary Create Queue
   * @param {EngineCreateQueueRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueueServiceApi
   */
  public createQueue(body: EngineCreateQueueRequest, options?: any) {
    return QueueServiceApiFp(this.configuration)
      .createQueue(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Remove Queue
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueueServiceApi
   */
  public deleteQueue(id: string, domainId?: string, options?: any) {
    return QueueServiceApiFp(this.configuration)
      .deleteQueue(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Patch Queue
   * @param {string} id
   * @param {EnginePatchQueueRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueueServiceApi
   */
  public patchQueue(id: string, body: EnginePatchQueueRequest, options?: any) {
    return QueueServiceApiFp(this.configuration)
      .patchQueue(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Queue item
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueueServiceApi
   */
  public readQueue(id: string, domainId?: string, options?: any) {
    return QueueServiceApiFp(this.configuration)
      .readQueue(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List of Queue
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [domainId]
   * @param {Array<string>} [fields]
   * @param {string} [sort]
   * @param {Array<string>} [id]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueueServiceApi
   */
  public searchQueue(
    page?: number,
    size?: number,
    q?: string,
    domainId?: string,
    fields?: Array<string>,
    sort?: string,
    id?: Array<string>,
    options?: any
  ) {
    return QueueServiceApiFp(this.configuration)
      .searchQueue(page, size, q, domainId, fields, sort, id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [joinedAtFrom]
   * @param {string} [joinedAtTo]
   * @param {string} [domainId]
   * @param {Array<string>} [fields]
   * @param {string} [sort]
   * @param {string} [q]
   * @param {Array<number>} [queueId]
   * @param {Array<number>} [teamId]
   * @param {Array<number>} [type]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueueServiceApi
   */
  public searchQueueReportGeneral(
    page?: number,
    size?: number,
    joinedAtFrom?: string,
    joinedAtTo?: string,
    domainId?: string,
    fields?: Array<string>,
    sort?: string,
    q?: string,
    queueId?: Array<number>,
    teamId?: Array<number>,
    type?: Array<number>,
    options?: any
  ) {
    return QueueServiceApiFp(this.configuration)
      .searchQueueReportGeneral(
        page,
        size,
        joinedAtFrom,
        joinedAtTo,
        domainId,
        fields,
        sort,
        q,
        queueId,
        teamId,
        type,
        options
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update Queue
   * @param {string} id
   * @param {EngineUpdateQueueRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof QueueServiceApi
   */
  public updateQueue(
    id: string,
    body: EngineUpdateQueueRequest,
    options?: any
  ) {
    return QueueServiceApiFp(this.configuration)
      .updateQueue(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ResourceTeamServiceApi - axios parameter creator
 * @export
 */
export const ResourceTeamServiceApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create ResourceTeamAgent
     * @param {string} teamId
     * @param {EngineCreateResourceTeamAgentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResourceTeamAgent: async (
      teamId: string,
      body: EngineCreateResourceTeamAgentRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      if (teamId === null || teamId === undefined) {
        throw new RequiredError(
          'teamId',
          'Required parameter teamId was null or undefined when calling createResourceTeamAgent.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createResourceTeamAgent.'
        )
      }
      const localVarPath = `/call_center/teams/{team_id}/agents`.replace(
        `{${'team_id'}}`,
        encodeURIComponent(String(teamId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary SKill Create ResourceTeamSkill
     * @param {string} teamId
     * @param {EngineCreateResourceTeamSkillRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResourceTeamSkill: async (
      teamId: string,
      body: EngineCreateResourceTeamSkillRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      if (teamId === null || teamId === undefined) {
        throw new RequiredError(
          'teamId',
          'Required parameter teamId was null or undefined when calling createResourceTeamSkill.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createResourceTeamSkill.'
        )
      }
      const localVarPath = `/call_center/teams/{team_id}/skills`.replace(
        `{${'team_id'}}`,
        encodeURIComponent(String(teamId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Remove ResourceTeamAgent
     * @param {string} teamId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResourceTeamAgent: async (
      teamId: string,
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      if (teamId === null || teamId === undefined) {
        throw new RequiredError(
          'teamId',
          'Required parameter teamId was null or undefined when calling deleteResourceTeamAgent.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteResourceTeamAgent.'
        )
      }
      const localVarPath = `/call_center/teams/{team_id}/agents/{id}`
        .replace(`{${'team_id'}}`, encodeURIComponent(String(teamId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Remove ResourceTeamSkill
     * @param {string} teamId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResourceTeamSkill: async (
      teamId: string,
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      if (teamId === null || teamId === undefined) {
        throw new RequiredError(
          'teamId',
          'Required parameter teamId was null or undefined when calling deleteResourceTeamSkill.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteResourceTeamSkill.'
        )
      }
      const localVarPath = `/call_center/teams/{team_id}/skills/{id}`
        .replace(`{${'team_id'}}`, encodeURIComponent(String(teamId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Patch ResourceTeamAgent
     * @param {string} teamId
     * @param {string} id
     * @param {EnginePatchResourceTeamAgentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchResourceTeamAgent: async (
      teamId: string,
      id: string,
      body: EnginePatchResourceTeamAgentRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      if (teamId === null || teamId === undefined) {
        throw new RequiredError(
          'teamId',
          'Required parameter teamId was null or undefined when calling patchResourceTeamAgent.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling patchResourceTeamAgent.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling patchResourceTeamAgent.'
        )
      }
      const localVarPath = `/call_center/teams/{team_id}/agents/{id}`
        .replace(`{${'team_id'}}`, encodeURIComponent(String(teamId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Patch ResourceTeamAgent
     * @param {string} teamId
     * @param {string} id
     * @param {EnginePatchResourceTeamSkillRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchResourceTeamSkill: async (
      teamId: string,
      id: string,
      body: EnginePatchResourceTeamSkillRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      if (teamId === null || teamId === undefined) {
        throw new RequiredError(
          'teamId',
          'Required parameter teamId was null or undefined when calling patchResourceTeamSkill.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling patchResourceTeamSkill.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling patchResourceTeamSkill.'
        )
      }
      const localVarPath = `/call_center/teams/{team_id}/skills/{id}`
        .replace(`{${'team_id'}}`, encodeURIComponent(String(teamId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary ResourceTeamAgent item
     * @param {string} teamId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readResourceTeamAgent: async (
      teamId: string,
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      if (teamId === null || teamId === undefined) {
        throw new RequiredError(
          'teamId',
          'Required parameter teamId was null or undefined when calling readResourceTeamAgent.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readResourceTeamAgent.'
        )
      }
      const localVarPath = `/call_center/teams/{team_id}/agents/{id}`
        .replace(`{${'team_id'}}`, encodeURIComponent(String(teamId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary ResourceTeamSkill item
     * @param {string} teamId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readResourceTeamSkill: async (
      teamId: string,
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      if (teamId === null || teamId === undefined) {
        throw new RequiredError(
          'teamId',
          'Required parameter teamId was null or undefined when calling readResourceTeamSkill.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readResourceTeamSkill.'
        )
      }
      const localVarPath = `/call_center/teams/{team_id}/skills/{id}`
        .replace(`{${'team_id'}}`, encodeURIComponent(String(teamId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List of ResourceTeamAgent
     * @param {string} teamId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchResourceTeamAgent: async (
      teamId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      if (teamId === null || teamId === undefined) {
        throw new RequiredError(
          'teamId',
          'Required parameter teamId was null or undefined when calling searchResourceTeamAgent.'
        )
      }
      const localVarPath = `/call_center/teams/{team_id}/agents`.replace(
        `{${'team_id'}}`,
        encodeURIComponent(String(teamId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List of ResourceTeamSkill
     * @param {string} teamId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchResourceTeamSkill: async (
      teamId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      if (teamId === null || teamId === undefined) {
        throw new RequiredError(
          'teamId',
          'Required parameter teamId was null or undefined when calling searchResourceTeamSkill.'
        )
      }
      const localVarPath = `/call_center/teams/{team_id}/skills`.replace(
        `{${'team_id'}}`,
        encodeURIComponent(String(teamId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update ResourceTeamAgent
     * @param {string} teamId
     * @param {string} id
     * @param {EngineUpdateResourceTeamAgentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResourceTeamAgent: async (
      teamId: string,
      id: string,
      body: EngineUpdateResourceTeamAgentRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      if (teamId === null || teamId === undefined) {
        throw new RequiredError(
          'teamId',
          'Required parameter teamId was null or undefined when calling updateResourceTeamAgent.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateResourceTeamAgent.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateResourceTeamAgent.'
        )
      }
      const localVarPath = `/call_center/teams/{team_id}/agents/{id}`
        .replace(`{${'team_id'}}`, encodeURIComponent(String(teamId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update ResourceTeamSkill
     * @param {string} teamId
     * @param {string} id
     * @param {EngineUpdateResourceTeamSkillRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResourceTeamSkill: async (
      teamId: string,
      id: string,
      body: EngineUpdateResourceTeamSkillRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      if (teamId === null || teamId === undefined) {
        throw new RequiredError(
          'teamId',
          'Required parameter teamId was null or undefined when calling updateResourceTeamSkill.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateResourceTeamSkill.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateResourceTeamSkill.'
        )
      }
      const localVarPath = `/call_center/teams/{team_id}/skills/{id}`
        .replace(`{${'team_id'}}`, encodeURIComponent(String(teamId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ResourceTeamServiceApi - functional programming interface
 * @export
 */
export const ResourceTeamServiceApiFp = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create ResourceTeamAgent
     * @param {string} teamId
     * @param {EngineCreateResourceTeamAgentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createResourceTeamAgent(
      teamId: string,
      body: EngineCreateResourceTeamAgentRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineResourceTeamAgent>
    > {
      const localVarAxiosArgs = await ResourceTeamServiceApiAxiosParamCreator(
        configuration
      ).createResourceTeamAgent(teamId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary SKill Create ResourceTeamSkill
     * @param {string} teamId
     * @param {EngineCreateResourceTeamSkillRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createResourceTeamSkill(
      teamId: string,
      body: EngineCreateResourceTeamSkillRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineResourceTeamSkill>
    > {
      const localVarAxiosArgs = await ResourceTeamServiceApiAxiosParamCreator(
        configuration
      ).createResourceTeamSkill(teamId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Remove ResourceTeamAgent
     * @param {string} teamId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteResourceTeamAgent(
      teamId: string,
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineResourceTeamAgent>
    > {
      const localVarAxiosArgs = await ResourceTeamServiceApiAxiosParamCreator(
        configuration
      ).deleteResourceTeamAgent(teamId, id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Remove ResourceTeamSkill
     * @param {string} teamId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteResourceTeamSkill(
      teamId: string,
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineResourceTeamSkill>
    > {
      const localVarAxiosArgs = await ResourceTeamServiceApiAxiosParamCreator(
        configuration
      ).deleteResourceTeamSkill(teamId, id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Patch ResourceTeamAgent
     * @param {string} teamId
     * @param {string} id
     * @param {EnginePatchResourceTeamAgentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchResourceTeamAgent(
      teamId: string,
      id: string,
      body: EnginePatchResourceTeamAgentRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineResourceTeamAgent>
    > {
      const localVarAxiosArgs = await ResourceTeamServiceApiAxiosParamCreator(
        configuration
      ).patchResourceTeamAgent(teamId, id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Patch ResourceTeamAgent
     * @param {string} teamId
     * @param {string} id
     * @param {EnginePatchResourceTeamSkillRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchResourceTeamSkill(
      teamId: string,
      id: string,
      body: EnginePatchResourceTeamSkillRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineResourceTeamSkill>
    > {
      const localVarAxiosArgs = await ResourceTeamServiceApiAxiosParamCreator(
        configuration
      ).patchResourceTeamSkill(teamId, id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary ResourceTeamAgent item
     * @param {string} teamId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readResourceTeamAgent(
      teamId: string,
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineResourceTeamAgent>
    > {
      const localVarAxiosArgs = await ResourceTeamServiceApiAxiosParamCreator(
        configuration
      ).readResourceTeamAgent(teamId, id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary ResourceTeamSkill item
     * @param {string} teamId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readResourceTeamSkill(
      teamId: string,
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineResourceTeamSkill>
    > {
      const localVarAxiosArgs = await ResourceTeamServiceApiAxiosParamCreator(
        configuration
      ).readResourceTeamSkill(teamId, id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List of ResourceTeamAgent
     * @param {string} teamId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchResourceTeamAgent(
      teamId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListResourceTeamAgent>
    > {
      const localVarAxiosArgs = await ResourceTeamServiceApiAxiosParamCreator(
        configuration
      ).searchResourceTeamAgent(teamId, page, size, q, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List of ResourceTeamSkill
     * @param {string} teamId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchResourceTeamSkill(
      teamId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListResourceTeamSkill>
    > {
      const localVarAxiosArgs = await ResourceTeamServiceApiAxiosParamCreator(
        configuration
      ).searchResourceTeamSkill(teamId, page, size, q, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update ResourceTeamAgent
     * @param {string} teamId
     * @param {string} id
     * @param {EngineUpdateResourceTeamAgentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateResourceTeamAgent(
      teamId: string,
      id: string,
      body: EngineUpdateResourceTeamAgentRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineResourceTeamAgent>
    > {
      const localVarAxiosArgs = await ResourceTeamServiceApiAxiosParamCreator(
        configuration
      ).updateResourceTeamAgent(teamId, id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update ResourceTeamSkill
     * @param {string} teamId
     * @param {string} id
     * @param {EngineUpdateResourceTeamSkillRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateResourceTeamSkill(
      teamId: string,
      id: string,
      body: EngineUpdateResourceTeamSkillRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineResourceTeamSkill>
    > {
      const localVarAxiosArgs = await ResourceTeamServiceApiAxiosParamCreator(
        configuration
      ).updateResourceTeamSkill(teamId, id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * ResourceTeamServiceApi - factory interface
 * @export
 */
export const ResourceTeamServiceApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Create ResourceTeamAgent
     * @param {string} teamId
     * @param {EngineCreateResourceTeamAgentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResourceTeamAgent(
      teamId: string,
      body: EngineCreateResourceTeamAgentRequest,
      options?: any
    ): AxiosPromise<EngineResourceTeamAgent> {
      return ResourceTeamServiceApiFp(configuration)
        .createResourceTeamAgent(teamId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary SKill Create ResourceTeamSkill
     * @param {string} teamId
     * @param {EngineCreateResourceTeamSkillRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createResourceTeamSkill(
      teamId: string,
      body: EngineCreateResourceTeamSkillRequest,
      options?: any
    ): AxiosPromise<EngineResourceTeamSkill> {
      return ResourceTeamServiceApiFp(configuration)
        .createResourceTeamSkill(teamId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Remove ResourceTeamAgent
     * @param {string} teamId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResourceTeamAgent(
      teamId: string,
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineResourceTeamAgent> {
      return ResourceTeamServiceApiFp(configuration)
        .deleteResourceTeamAgent(teamId, id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Remove ResourceTeamSkill
     * @param {string} teamId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteResourceTeamSkill(
      teamId: string,
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineResourceTeamSkill> {
      return ResourceTeamServiceApiFp(configuration)
        .deleteResourceTeamSkill(teamId, id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Patch ResourceTeamAgent
     * @param {string} teamId
     * @param {string} id
     * @param {EnginePatchResourceTeamAgentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchResourceTeamAgent(
      teamId: string,
      id: string,
      body: EnginePatchResourceTeamAgentRequest,
      options?: any
    ): AxiosPromise<EngineResourceTeamAgent> {
      return ResourceTeamServiceApiFp(configuration)
        .patchResourceTeamAgent(teamId, id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Patch ResourceTeamAgent
     * @param {string} teamId
     * @param {string} id
     * @param {EnginePatchResourceTeamSkillRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchResourceTeamSkill(
      teamId: string,
      id: string,
      body: EnginePatchResourceTeamSkillRequest,
      options?: any
    ): AxiosPromise<EngineResourceTeamSkill> {
      return ResourceTeamServiceApiFp(configuration)
        .patchResourceTeamSkill(teamId, id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary ResourceTeamAgent item
     * @param {string} teamId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readResourceTeamAgent(
      teamId: string,
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineResourceTeamAgent> {
      return ResourceTeamServiceApiFp(configuration)
        .readResourceTeamAgent(teamId, id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary ResourceTeamSkill item
     * @param {string} teamId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readResourceTeamSkill(
      teamId: string,
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineResourceTeamSkill> {
      return ResourceTeamServiceApiFp(configuration)
        .readResourceTeamSkill(teamId, id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List of ResourceTeamAgent
     * @param {string} teamId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchResourceTeamAgent(
      teamId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListResourceTeamAgent> {
      return ResourceTeamServiceApiFp(configuration)
        .searchResourceTeamAgent(teamId, page, size, q, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List of ResourceTeamSkill
     * @param {string} teamId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchResourceTeamSkill(
      teamId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListResourceTeamSkill> {
      return ResourceTeamServiceApiFp(configuration)
        .searchResourceTeamSkill(teamId, page, size, q, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update ResourceTeamAgent
     * @param {string} teamId
     * @param {string} id
     * @param {EngineUpdateResourceTeamAgentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResourceTeamAgent(
      teamId: string,
      id: string,
      body: EngineUpdateResourceTeamAgentRequest,
      options?: any
    ): AxiosPromise<EngineResourceTeamAgent> {
      return ResourceTeamServiceApiFp(configuration)
        .updateResourceTeamAgent(teamId, id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update ResourceTeamSkill
     * @param {string} teamId
     * @param {string} id
     * @param {EngineUpdateResourceTeamSkillRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateResourceTeamSkill(
      teamId: string,
      id: string,
      body: EngineUpdateResourceTeamSkillRequest,
      options?: any
    ): AxiosPromise<EngineResourceTeamSkill> {
      return ResourceTeamServiceApiFp(configuration)
        .updateResourceTeamSkill(teamId, id, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ResourceTeamServiceApi - object-oriented interface
 * @export
 * @class ResourceTeamServiceApi
 * @extends {BaseAPI}
 */
export class ResourceTeamServiceApi extends BaseAPI {
  /**
   *
   * @summary Create ResourceTeamAgent
   * @param {string} teamId
   * @param {EngineCreateResourceTeamAgentRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceTeamServiceApi
   */
  public createResourceTeamAgent(
    teamId: string,
    body: EngineCreateResourceTeamAgentRequest,
    options?: any
  ) {
    return ResourceTeamServiceApiFp(this.configuration)
      .createResourceTeamAgent(teamId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary SKill Create ResourceTeamSkill
   * @param {string} teamId
   * @param {EngineCreateResourceTeamSkillRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceTeamServiceApi
   */
  public createResourceTeamSkill(
    teamId: string,
    body: EngineCreateResourceTeamSkillRequest,
    options?: any
  ) {
    return ResourceTeamServiceApiFp(this.configuration)
      .createResourceTeamSkill(teamId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Remove ResourceTeamAgent
   * @param {string} teamId
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceTeamServiceApi
   */
  public deleteResourceTeamAgent(
    teamId: string,
    id: string,
    domainId?: string,
    options?: any
  ) {
    return ResourceTeamServiceApiFp(this.configuration)
      .deleteResourceTeamAgent(teamId, id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Remove ResourceTeamSkill
   * @param {string} teamId
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceTeamServiceApi
   */
  public deleteResourceTeamSkill(
    teamId: string,
    id: string,
    domainId?: string,
    options?: any
  ) {
    return ResourceTeamServiceApiFp(this.configuration)
      .deleteResourceTeamSkill(teamId, id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Patch ResourceTeamAgent
   * @param {string} teamId
   * @param {string} id
   * @param {EnginePatchResourceTeamAgentRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceTeamServiceApi
   */
  public patchResourceTeamAgent(
    teamId: string,
    id: string,
    body: EnginePatchResourceTeamAgentRequest,
    options?: any
  ) {
    return ResourceTeamServiceApiFp(this.configuration)
      .patchResourceTeamAgent(teamId, id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Patch ResourceTeamAgent
   * @param {string} teamId
   * @param {string} id
   * @param {EnginePatchResourceTeamSkillRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceTeamServiceApi
   */
  public patchResourceTeamSkill(
    teamId: string,
    id: string,
    body: EnginePatchResourceTeamSkillRequest,
    options?: any
  ) {
    return ResourceTeamServiceApiFp(this.configuration)
      .patchResourceTeamSkill(teamId, id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary ResourceTeamAgent item
   * @param {string} teamId
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceTeamServiceApi
   */
  public readResourceTeamAgent(
    teamId: string,
    id: string,
    domainId?: string,
    options?: any
  ) {
    return ResourceTeamServiceApiFp(this.configuration)
      .readResourceTeamAgent(teamId, id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary ResourceTeamSkill item
   * @param {string} teamId
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceTeamServiceApi
   */
  public readResourceTeamSkill(
    teamId: string,
    id: string,
    domainId?: string,
    options?: any
  ) {
    return ResourceTeamServiceApiFp(this.configuration)
      .readResourceTeamSkill(teamId, id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List of ResourceTeamAgent
   * @param {string} teamId
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceTeamServiceApi
   */
  public searchResourceTeamAgent(
    teamId: string,
    page?: number,
    size?: number,
    q?: string,
    domainId?: string,
    options?: any
  ) {
    return ResourceTeamServiceApiFp(this.configuration)
      .searchResourceTeamAgent(teamId, page, size, q, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List of ResourceTeamSkill
   * @param {string} teamId
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceTeamServiceApi
   */
  public searchResourceTeamSkill(
    teamId: string,
    page?: number,
    size?: number,
    q?: string,
    domainId?: string,
    options?: any
  ) {
    return ResourceTeamServiceApiFp(this.configuration)
      .searchResourceTeamSkill(teamId, page, size, q, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update ResourceTeamAgent
   * @param {string} teamId
   * @param {string} id
   * @param {EngineUpdateResourceTeamAgentRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceTeamServiceApi
   */
  public updateResourceTeamAgent(
    teamId: string,
    id: string,
    body: EngineUpdateResourceTeamAgentRequest,
    options?: any
  ) {
    return ResourceTeamServiceApiFp(this.configuration)
      .updateResourceTeamAgent(teamId, id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update ResourceTeamSkill
   * @param {string} teamId
   * @param {string} id
   * @param {EngineUpdateResourceTeamSkillRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourceTeamServiceApi
   */
  public updateResourceTeamSkill(
    teamId: string,
    id: string,
    body: EngineUpdateResourceTeamSkillRequest,
    options?: any
  ) {
    return ResourceTeamServiceApiFp(this.configuration)
      .updateResourceTeamSkill(teamId, id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * RoutingOutboundCallServiceApi - axios parameter creator
 * @export
 */
export const RoutingOutboundCallServiceApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create RoutingOutboundCall
     * @param {EngineCreateRoutingOutboundCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRoutingOutboundCall: async (
      body: EngineCreateRoutingOutboundCallRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createRoutingOutboundCall.'
        )
      }
      const localVarPath = `/routing/outbound/calls`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Remove RoutingOutboundCall
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRoutingOutboundCall: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteRoutingOutboundCall.'
        )
      }
      const localVarPath = `/routing/outbound/calls/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Move RoutingOutboundCall
     * @param {string} fromId
     * @param {string} toId
     * @param {EngineMovePositionRoutingOutboundCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    movePositionRoutingOutboundCall: async (
      fromId: string,
      toId: string,
      body: EngineMovePositionRoutingOutboundCallRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'fromId' is not null or undefined
      if (fromId === null || fromId === undefined) {
        throw new RequiredError(
          'fromId',
          'Required parameter fromId was null or undefined when calling movePositionRoutingOutboundCall.'
        )
      }
      // verify required parameter 'toId' is not null or undefined
      if (toId === null || toId === undefined) {
        throw new RequiredError(
          'toId',
          'Required parameter toId was null or undefined when calling movePositionRoutingOutboundCall.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling movePositionRoutingOutboundCall.'
        )
      }
      const localVarPath = `/routing/outbound/calls/{from_id}/to/{to_id}`
        .replace(`{${'from_id'}}`, encodeURIComponent(String(fromId)))
        .replace(`{${'to_id'}}`, encodeURIComponent(String(toId)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Patch RoutingOutboundCall
     * @param {string} id
     * @param {EnginePatchRoutingOutboundCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchRoutingOutboundCall: async (
      id: string,
      body: EnginePatchRoutingOutboundCallRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling patchRoutingOutboundCall.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling patchRoutingOutboundCall.'
        )
      }
      const localVarPath = `/routing/outbound/calls/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary RoutingOutboundCall item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readRoutingOutboundCall: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readRoutingOutboundCall.'
        )
      }
      const localVarPath = `/routing/outbound/calls/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List of RoutingOutboundCall
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchRoutingOutboundCall: async (
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/routing/outbound/calls`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update RoutingOutboundCall
     * @param {string} id
     * @param {EngineUpdateRoutingOutboundCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRoutingOutboundCall: async (
      id: string,
      body: EngineUpdateRoutingOutboundCallRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateRoutingOutboundCall.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateRoutingOutboundCall.'
        )
      }
      const localVarPath = `/routing/outbound/calls/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * RoutingOutboundCallServiceApi - functional programming interface
 * @export
 */
export const RoutingOutboundCallServiceApiFp = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create RoutingOutboundCall
     * @param {EngineCreateRoutingOutboundCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRoutingOutboundCall(
      body: EngineCreateRoutingOutboundCallRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineRoutingOutboundCall>
    > {
      const localVarAxiosArgs = await RoutingOutboundCallServiceApiAxiosParamCreator(
        configuration
      ).createRoutingOutboundCall(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Remove RoutingOutboundCall
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRoutingOutboundCall(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineRoutingOutboundCall>
    > {
      const localVarAxiosArgs = await RoutingOutboundCallServiceApiAxiosParamCreator(
        configuration
      ).deleteRoutingOutboundCall(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Move RoutingOutboundCall
     * @param {string} fromId
     * @param {string} toId
     * @param {EngineMovePositionRoutingOutboundCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async movePositionRoutingOutboundCall(
      fromId: string,
      toId: string,
      body: EngineMovePositionRoutingOutboundCallRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineMovePositionRoutingOutboundCallResponse>
    > {
      const localVarAxiosArgs = await RoutingOutboundCallServiceApiAxiosParamCreator(
        configuration
      ).movePositionRoutingOutboundCall(fromId, toId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Patch RoutingOutboundCall
     * @param {string} id
     * @param {EnginePatchRoutingOutboundCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchRoutingOutboundCall(
      id: string,
      body: EnginePatchRoutingOutboundCallRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineRoutingOutboundCall>
    > {
      const localVarAxiosArgs = await RoutingOutboundCallServiceApiAxiosParamCreator(
        configuration
      ).patchRoutingOutboundCall(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary RoutingOutboundCall item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readRoutingOutboundCall(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineRoutingOutboundCall>
    > {
      const localVarAxiosArgs = await RoutingOutboundCallServiceApiAxiosParamCreator(
        configuration
      ).readRoutingOutboundCall(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List of RoutingOutboundCall
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchRoutingOutboundCall(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListRoutingOutboundCall>
    > {
      const localVarAxiosArgs = await RoutingOutboundCallServiceApiAxiosParamCreator(
        configuration
      ).searchRoutingOutboundCall(page, size, q, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update RoutingOutboundCall
     * @param {string} id
     * @param {EngineUpdateRoutingOutboundCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRoutingOutboundCall(
      id: string,
      body: EngineUpdateRoutingOutboundCallRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineRoutingOutboundCall>
    > {
      const localVarAxiosArgs = await RoutingOutboundCallServiceApiAxiosParamCreator(
        configuration
      ).updateRoutingOutboundCall(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * RoutingOutboundCallServiceApi - factory interface
 * @export
 */
export const RoutingOutboundCallServiceApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Create RoutingOutboundCall
     * @param {EngineCreateRoutingOutboundCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRoutingOutboundCall(
      body: EngineCreateRoutingOutboundCallRequest,
      options?: any
    ): AxiosPromise<EngineRoutingOutboundCall> {
      return RoutingOutboundCallServiceApiFp(configuration)
        .createRoutingOutboundCall(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Remove RoutingOutboundCall
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRoutingOutboundCall(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineRoutingOutboundCall> {
      return RoutingOutboundCallServiceApiFp(configuration)
        .deleteRoutingOutboundCall(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Move RoutingOutboundCall
     * @param {string} fromId
     * @param {string} toId
     * @param {EngineMovePositionRoutingOutboundCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    movePositionRoutingOutboundCall(
      fromId: string,
      toId: string,
      body: EngineMovePositionRoutingOutboundCallRequest,
      options?: any
    ): AxiosPromise<EngineMovePositionRoutingOutboundCallResponse> {
      return RoutingOutboundCallServiceApiFp(configuration)
        .movePositionRoutingOutboundCall(fromId, toId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Patch RoutingOutboundCall
     * @param {string} id
     * @param {EnginePatchRoutingOutboundCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchRoutingOutboundCall(
      id: string,
      body: EnginePatchRoutingOutboundCallRequest,
      options?: any
    ): AxiosPromise<EngineRoutingOutboundCall> {
      return RoutingOutboundCallServiceApiFp(configuration)
        .patchRoutingOutboundCall(id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary RoutingOutboundCall item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readRoutingOutboundCall(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineRoutingOutboundCall> {
      return RoutingOutboundCallServiceApiFp(configuration)
        .readRoutingOutboundCall(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List of RoutingOutboundCall
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchRoutingOutboundCall(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListRoutingOutboundCall> {
      return RoutingOutboundCallServiceApiFp(configuration)
        .searchRoutingOutboundCall(page, size, q, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update RoutingOutboundCall
     * @param {string} id
     * @param {EngineUpdateRoutingOutboundCallRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRoutingOutboundCall(
      id: string,
      body: EngineUpdateRoutingOutboundCallRequest,
      options?: any
    ): AxiosPromise<EngineRoutingOutboundCall> {
      return RoutingOutboundCallServiceApiFp(configuration)
        .updateRoutingOutboundCall(id, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * RoutingOutboundCallServiceApi - object-oriented interface
 * @export
 * @class RoutingOutboundCallServiceApi
 * @extends {BaseAPI}
 */
export class RoutingOutboundCallServiceApi extends BaseAPI {
  /**
   *
   * @summary Create RoutingOutboundCall
   * @param {EngineCreateRoutingOutboundCallRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoutingOutboundCallServiceApi
   */
  public createRoutingOutboundCall(
    body: EngineCreateRoutingOutboundCallRequest,
    options?: any
  ) {
    return RoutingOutboundCallServiceApiFp(this.configuration)
      .createRoutingOutboundCall(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Remove RoutingOutboundCall
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoutingOutboundCallServiceApi
   */
  public deleteRoutingOutboundCall(
    id: string,
    domainId?: string,
    options?: any
  ) {
    return RoutingOutboundCallServiceApiFp(this.configuration)
      .deleteRoutingOutboundCall(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Move RoutingOutboundCall
   * @param {string} fromId
   * @param {string} toId
   * @param {EngineMovePositionRoutingOutboundCallRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoutingOutboundCallServiceApi
   */
  public movePositionRoutingOutboundCall(
    fromId: string,
    toId: string,
    body: EngineMovePositionRoutingOutboundCallRequest,
    options?: any
  ) {
    return RoutingOutboundCallServiceApiFp(this.configuration)
      .movePositionRoutingOutboundCall(fromId, toId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Patch RoutingOutboundCall
   * @param {string} id
   * @param {EnginePatchRoutingOutboundCallRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoutingOutboundCallServiceApi
   */
  public patchRoutingOutboundCall(
    id: string,
    body: EnginePatchRoutingOutboundCallRequest,
    options?: any
  ) {
    return RoutingOutboundCallServiceApiFp(this.configuration)
      .patchRoutingOutboundCall(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary RoutingOutboundCall item
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoutingOutboundCallServiceApi
   */
  public readRoutingOutboundCall(id: string, domainId?: string, options?: any) {
    return RoutingOutboundCallServiceApiFp(this.configuration)
      .readRoutingOutboundCall(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List of RoutingOutboundCall
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoutingOutboundCallServiceApi
   */
  public searchRoutingOutboundCall(
    page?: number,
    size?: number,
    q?: string,
    domainId?: string,
    options?: any
  ) {
    return RoutingOutboundCallServiceApiFp(this.configuration)
      .searchRoutingOutboundCall(page, size, q, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update RoutingOutboundCall
   * @param {string} id
   * @param {EngineUpdateRoutingOutboundCallRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoutingOutboundCallServiceApi
   */
  public updateRoutingOutboundCall(
    id: string,
    body: EngineUpdateRoutingOutboundCallRequest,
    options?: any
  ) {
    return RoutingOutboundCallServiceApiFp(this.configuration)
      .updateRoutingOutboundCall(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * RoutingSchemaServiceApi - axios parameter creator
 * @export
 */
export const RoutingSchemaServiceApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create RoutingSchema
     * @param {EngineCreateRoutingSchemaRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRoutingSchema: async (
      body: EngineCreateRoutingSchemaRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createRoutingSchema.'
        )
      }
      const localVarPath = `/routing/schema`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Remove RoutingSchema
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRoutingSchema: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteRoutingSchema.'
        )
      }
      const localVarPath = `/routing/schema/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Patch RoutingSchema
     * @param {string} id
     * @param {EnginePatchRoutingSchemaRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchRoutingSchema: async (
      id: string,
      body: EnginePatchRoutingSchemaRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling patchRoutingSchema.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling patchRoutingSchema.'
        )
      }
      const localVarPath = `/routing/schema/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary RoutingSchema item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readRoutingSchema: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readRoutingSchema.'
        )
      }
      const localVarPath = `/routing/schema/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List RoutingSchema
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchRoutingSchema: async (
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/routing/schema`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update RoutingSchema
     * @param {string} id
     * @param {EngineUpdateRoutingSchemaRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRoutingSchema: async (
      id: string,
      body: EngineUpdateRoutingSchemaRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateRoutingSchema.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateRoutingSchema.'
        )
      }
      const localVarPath = `/routing/schema/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * RoutingSchemaServiceApi - functional programming interface
 * @export
 */
export const RoutingSchemaServiceApiFp = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create RoutingSchema
     * @param {EngineCreateRoutingSchemaRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRoutingSchema(
      body: EngineCreateRoutingSchemaRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineRoutingSchema>
    > {
      const localVarAxiosArgs = await RoutingSchemaServiceApiAxiosParamCreator(
        configuration
      ).createRoutingSchema(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Remove RoutingSchema
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRoutingSchema(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineRoutingSchema>
    > {
      const localVarAxiosArgs = await RoutingSchemaServiceApiAxiosParamCreator(
        configuration
      ).deleteRoutingSchema(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Patch RoutingSchema
     * @param {string} id
     * @param {EnginePatchRoutingSchemaRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async patchRoutingSchema(
      id: string,
      body: EnginePatchRoutingSchemaRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineRoutingSchema>
    > {
      const localVarAxiosArgs = await RoutingSchemaServiceApiAxiosParamCreator(
        configuration
      ).patchRoutingSchema(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary RoutingSchema item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readRoutingSchema(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineRoutingSchema>
    > {
      const localVarAxiosArgs = await RoutingSchemaServiceApiAxiosParamCreator(
        configuration
      ).readRoutingSchema(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List RoutingSchema
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchRoutingSchema(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListRoutingSchema>
    > {
      const localVarAxiosArgs = await RoutingSchemaServiceApiAxiosParamCreator(
        configuration
      ).searchRoutingSchema(page, size, q, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update RoutingSchema
     * @param {string} id
     * @param {EngineUpdateRoutingSchemaRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRoutingSchema(
      id: string,
      body: EngineUpdateRoutingSchemaRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineRoutingSchema>
    > {
      const localVarAxiosArgs = await RoutingSchemaServiceApiAxiosParamCreator(
        configuration
      ).updateRoutingSchema(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * RoutingSchemaServiceApi - factory interface
 * @export
 */
export const RoutingSchemaServiceApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Create RoutingSchema
     * @param {EngineCreateRoutingSchemaRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRoutingSchema(
      body: EngineCreateRoutingSchemaRequest,
      options?: any
    ): AxiosPromise<EngineRoutingSchema> {
      return RoutingSchemaServiceApiFp(configuration)
        .createRoutingSchema(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Remove RoutingSchema
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRoutingSchema(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineRoutingSchema> {
      return RoutingSchemaServiceApiFp(configuration)
        .deleteRoutingSchema(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Patch RoutingSchema
     * @param {string} id
     * @param {EnginePatchRoutingSchemaRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    patchRoutingSchema(
      id: string,
      body: EnginePatchRoutingSchemaRequest,
      options?: any
    ): AxiosPromise<EngineRoutingSchema> {
      return RoutingSchemaServiceApiFp(configuration)
        .patchRoutingSchema(id, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary RoutingSchema item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readRoutingSchema(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineRoutingSchema> {
      return RoutingSchemaServiceApiFp(configuration)
        .readRoutingSchema(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List RoutingSchema
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchRoutingSchema(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListRoutingSchema> {
      return RoutingSchemaServiceApiFp(configuration)
        .searchRoutingSchema(page, size, q, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update RoutingSchema
     * @param {string} id
     * @param {EngineUpdateRoutingSchemaRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRoutingSchema(
      id: string,
      body: EngineUpdateRoutingSchemaRequest,
      options?: any
    ): AxiosPromise<EngineRoutingSchema> {
      return RoutingSchemaServiceApiFp(configuration)
        .updateRoutingSchema(id, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * RoutingSchemaServiceApi - object-oriented interface
 * @export
 * @class RoutingSchemaServiceApi
 * @extends {BaseAPI}
 */
export class RoutingSchemaServiceApi extends BaseAPI {
  /**
   *
   * @summary Create RoutingSchema
   * @param {EngineCreateRoutingSchemaRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoutingSchemaServiceApi
   */
  public createRoutingSchema(
    body: EngineCreateRoutingSchemaRequest,
    options?: any
  ) {
    return RoutingSchemaServiceApiFp(this.configuration)
      .createRoutingSchema(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Remove RoutingSchema
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoutingSchemaServiceApi
   */
  public deleteRoutingSchema(id: string, domainId?: string, options?: any) {
    return RoutingSchemaServiceApiFp(this.configuration)
      .deleteRoutingSchema(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Patch RoutingSchema
   * @param {string} id
   * @param {EnginePatchRoutingSchemaRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoutingSchemaServiceApi
   */
  public patchRoutingSchema(
    id: string,
    body: EnginePatchRoutingSchemaRequest,
    options?: any
  ) {
    return RoutingSchemaServiceApiFp(this.configuration)
      .patchRoutingSchema(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary RoutingSchema item
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoutingSchemaServiceApi
   */
  public readRoutingSchema(id: string, domainId?: string, options?: any) {
    return RoutingSchemaServiceApiFp(this.configuration)
      .readRoutingSchema(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List RoutingSchema
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoutingSchemaServiceApi
   */
  public searchRoutingSchema(
    page?: number,
    size?: number,
    q?: string,
    domainId?: string,
    options?: any
  ) {
    return RoutingSchemaServiceApiFp(this.configuration)
      .searchRoutingSchema(page, size, q, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update RoutingSchema
   * @param {string} id
   * @param {EngineUpdateRoutingSchemaRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoutingSchemaServiceApi
   */
  public updateRoutingSchema(
    id: string,
    body: EngineUpdateRoutingSchemaRequest,
    options?: any
  ) {
    return RoutingSchemaServiceApiFp(this.configuration)
      .updateRoutingSchema(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * RoutingVariableServiceApi - axios parameter creator
 * @export
 */
export const RoutingVariableServiceApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create RoutingVariable
     * @param {EngineCreateRoutingVariableRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRoutingVariable: async (
      body: EngineCreateRoutingVariableRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createRoutingVariable.'
        )
      }
      const localVarPath = `/routing/variables`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Remove RoutingVariable
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRoutingVariable: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteRoutingVariable.'
        )
      }
      const localVarPath = `/routing/variables/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary RoutingVariable item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readRoutingVariable: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readRoutingVariable.'
        )
      }
      const localVarPath = `/routing/variables/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List of RoutingVariable
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchRoutingVariable: async (
      page?: number,
      size?: number,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/routing/variables`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update RoutingVariable
     * @param {string} id
     * @param {EngineUpdateRoutingVariableRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRoutingVariable: async (
      id: string,
      body: EngineUpdateRoutingVariableRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateRoutingVariable.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateRoutingVariable.'
        )
      }
      const localVarPath = `/routing/variables/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * RoutingVariableServiceApi - functional programming interface
 * @export
 */
export const RoutingVariableServiceApiFp = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create RoutingVariable
     * @param {EngineCreateRoutingVariableRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRoutingVariable(
      body: EngineCreateRoutingVariableRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineRoutingVariable>
    > {
      const localVarAxiosArgs = await RoutingVariableServiceApiAxiosParamCreator(
        configuration
      ).createRoutingVariable(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Remove RoutingVariable
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRoutingVariable(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineRoutingVariable>
    > {
      const localVarAxiosArgs = await RoutingVariableServiceApiAxiosParamCreator(
        configuration
      ).deleteRoutingVariable(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary RoutingVariable item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readRoutingVariable(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineRoutingVariable>
    > {
      const localVarAxiosArgs = await RoutingVariableServiceApiAxiosParamCreator(
        configuration
      ).readRoutingVariable(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List of RoutingVariable
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchRoutingVariable(
      page?: number,
      size?: number,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListRoutingVariable>
    > {
      const localVarAxiosArgs = await RoutingVariableServiceApiAxiosParamCreator(
        configuration
      ).searchRoutingVariable(page, size, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update RoutingVariable
     * @param {string} id
     * @param {EngineUpdateRoutingVariableRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRoutingVariable(
      id: string,
      body: EngineUpdateRoutingVariableRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineRoutingVariable>
    > {
      const localVarAxiosArgs = await RoutingVariableServiceApiAxiosParamCreator(
        configuration
      ).updateRoutingVariable(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * RoutingVariableServiceApi - factory interface
 * @export
 */
export const RoutingVariableServiceApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Create RoutingVariable
     * @param {EngineCreateRoutingVariableRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRoutingVariable(
      body: EngineCreateRoutingVariableRequest,
      options?: any
    ): AxiosPromise<EngineRoutingVariable> {
      return RoutingVariableServiceApiFp(configuration)
        .createRoutingVariable(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Remove RoutingVariable
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRoutingVariable(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineRoutingVariable> {
      return RoutingVariableServiceApiFp(configuration)
        .deleteRoutingVariable(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary RoutingVariable item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readRoutingVariable(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineRoutingVariable> {
      return RoutingVariableServiceApiFp(configuration)
        .readRoutingVariable(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List of RoutingVariable
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchRoutingVariable(
      page?: number,
      size?: number,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListRoutingVariable> {
      return RoutingVariableServiceApiFp(configuration)
        .searchRoutingVariable(page, size, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update RoutingVariable
     * @param {string} id
     * @param {EngineUpdateRoutingVariableRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRoutingVariable(
      id: string,
      body: EngineUpdateRoutingVariableRequest,
      options?: any
    ): AxiosPromise<EngineRoutingVariable> {
      return RoutingVariableServiceApiFp(configuration)
        .updateRoutingVariable(id, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * RoutingVariableServiceApi - object-oriented interface
 * @export
 * @class RoutingVariableServiceApi
 * @extends {BaseAPI}
 */
export class RoutingVariableServiceApi extends BaseAPI {
  /**
   *
   * @summary Create RoutingVariable
   * @param {EngineCreateRoutingVariableRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoutingVariableServiceApi
   */
  public createRoutingVariable(
    body: EngineCreateRoutingVariableRequest,
    options?: any
  ) {
    return RoutingVariableServiceApiFp(this.configuration)
      .createRoutingVariable(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Remove RoutingVariable
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoutingVariableServiceApi
   */
  public deleteRoutingVariable(id: string, domainId?: string, options?: any) {
    return RoutingVariableServiceApiFp(this.configuration)
      .deleteRoutingVariable(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary RoutingVariable item
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoutingVariableServiceApi
   */
  public readRoutingVariable(id: string, domainId?: string, options?: any) {
    return RoutingVariableServiceApiFp(this.configuration)
      .readRoutingVariable(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List of RoutingVariable
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoutingVariableServiceApi
   */
  public searchRoutingVariable(
    page?: number,
    size?: number,
    domainId?: string,
    options?: any
  ) {
    return RoutingVariableServiceApiFp(this.configuration)
      .searchRoutingVariable(page, size, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update RoutingVariable
   * @param {string} id
   * @param {EngineUpdateRoutingVariableRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoutingVariableServiceApi
   */
  public updateRoutingVariable(
    id: string,
    body: EngineUpdateRoutingVariableRequest,
    options?: any
  ) {
    return RoutingVariableServiceApiFp(this.configuration)
      .updateRoutingVariable(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * SkillServiceApi - axios parameter creator
 * @export
 */
export const SkillServiceApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create Skill
     * @param {EngineCreateSkillRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSkill: async (
      body: EngineCreateSkillRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createSkill.'
        )
      }
      const localVarPath = `/call_center/skills`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Remove Skill
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSkill: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteSkill.'
        )
      }
      const localVarPath = `/call_center/skills/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Skill item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readSkill: async (
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readSkill.'
        )
      }
      const localVarPath = `/call_center/skills/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List of Skill
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchSkill: async (
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/call_center/skills`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update Skill
     * @param {string} id
     * @param {EngineUpdateSkillRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSkill: async (
      id: string,
      body: EngineUpdateSkillRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateSkill.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateSkill.'
        )
      }
      const localVarPath = `/call_center/skills/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * SkillServiceApi - functional programming interface
 * @export
 */
export const SkillServiceApiFp = function(configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create Skill
     * @param {EngineCreateSkillRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSkill(
      body: EngineCreateSkillRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineSkill>
    > {
      const localVarAxiosArgs = await SkillServiceApiAxiosParamCreator(
        configuration
      ).createSkill(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Remove Skill
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSkill(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineSkill>
    > {
      const localVarAxiosArgs = await SkillServiceApiAxiosParamCreator(
        configuration
      ).deleteSkill(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Skill item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readSkill(
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineSkill>
    > {
      const localVarAxiosArgs = await SkillServiceApiAxiosParamCreator(
        configuration
      ).readSkill(id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List of Skill
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchSkill(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListSkill>
    > {
      const localVarAxiosArgs = await SkillServiceApiAxiosParamCreator(
        configuration
      ).searchSkill(page, size, q, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update Skill
     * @param {string} id
     * @param {EngineUpdateSkillRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSkill(
      id: string,
      body: EngineUpdateSkillRequest,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<EngineSkill>
    > {
      const localVarAxiosArgs = await SkillServiceApiAxiosParamCreator(
        configuration
      ).updateSkill(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * SkillServiceApi - factory interface
 * @export
 */
export const SkillServiceApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Create Skill
     * @param {EngineCreateSkillRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSkill(
      body: EngineCreateSkillRequest,
      options?: any
    ): AxiosPromise<EngineSkill> {
      return SkillServiceApiFp(configuration)
        .createSkill(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Remove Skill
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSkill(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineSkill> {
      return SkillServiceApiFp(configuration)
        .deleteSkill(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Skill item
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readSkill(
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineSkill> {
      return SkillServiceApiFp(configuration)
        .readSkill(id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List of Skill
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchSkill(
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListSkill> {
      return SkillServiceApiFp(configuration)
        .searchSkill(page, size, q, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update Skill
     * @param {string} id
     * @param {EngineUpdateSkillRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSkill(
      id: string,
      body: EngineUpdateSkillRequest,
      options?: any
    ): AxiosPromise<EngineSkill> {
      return SkillServiceApiFp(configuration)
        .updateSkill(id, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * SkillServiceApi - object-oriented interface
 * @export
 * @class SkillServiceApi
 * @extends {BaseAPI}
 */
export class SkillServiceApi extends BaseAPI {
  /**
   *
   * @summary Create Skill
   * @param {EngineCreateSkillRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SkillServiceApi
   */
  public createSkill(body: EngineCreateSkillRequest, options?: any) {
    return SkillServiceApiFp(this.configuration)
      .createSkill(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Remove Skill
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SkillServiceApi
   */
  public deleteSkill(id: string, domainId?: string, options?: any) {
    return SkillServiceApiFp(this.configuration)
      .deleteSkill(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Skill item
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SkillServiceApi
   */
  public readSkill(id: string, domainId?: string, options?: any) {
    return SkillServiceApiFp(this.configuration)
      .readSkill(id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List of Skill
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SkillServiceApi
   */
  public searchSkill(
    page?: number,
    size?: number,
    q?: string,
    domainId?: string,
    options?: any
  ) {
    return SkillServiceApiFp(this.configuration)
      .searchSkill(page, size, q, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update Skill
   * @param {string} id
   * @param {EngineUpdateSkillRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SkillServiceApi
   */
  public updateSkill(
    id: string,
    body: EngineUpdateSkillRequest,
    options?: any
  ) {
    return SkillServiceApiFp(this.configuration)
      .updateSkill(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * SupervisorInTeamServiceApi - axios parameter creator
 * @export
 */
export const SupervisorInTeamServiceApiAxiosParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create SupervisorInTeam
     * @param {string} teamId
     * @param {EngineCreateSupervisorInTeamRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSupervisorInTeam: async (
      teamId: string,
      body: EngineCreateSupervisorInTeamRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      if (teamId === null || teamId === undefined) {
        throw new RequiredError(
          'teamId',
          'Required parameter teamId was null or undefined when calling createSupervisorInTeam.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createSupervisorInTeam.'
        )
      }
      const localVarPath = `/call_center/teams/{team_id}/supervisors`.replace(
        `{${'team_id'}}`,
        encodeURIComponent(String(teamId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Remove SupervisorInTeam
     * @param {string} teamId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSupervisorInTeam: async (
      teamId: string,
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      if (teamId === null || teamId === undefined) {
        throw new RequiredError(
          'teamId',
          'Required parameter teamId was null or undefined when calling deleteSupervisorInTeam.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteSupervisorInTeam.'
        )
      }
      const localVarPath = `/call_center/teams/{team_id}/supervisors/{id}`
        .replace(`{${'team_id'}}`, encodeURIComponent(String(teamId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary SupervisorInTeam item
     * @param {string} teamId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readSupervisorInTeam: async (
      teamId: string,
      id: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      if (teamId === null || teamId === undefined) {
        throw new RequiredError(
          'teamId',
          'Required parameter teamId was null or undefined when calling readSupervisorInTeam.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling readSupervisorInTeam.'
        )
      }
      const localVarPath = `/call_center/teams/{team_id}/supervisors/{id}`
        .replace(`{${'team_id'}}`, encodeURIComponent(String(teamId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List of SupervisorInTeam
     * @param {string} teamId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchSupervisorInTeam: async (
      teamId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      if (teamId === null || teamId === undefined) {
        throw new RequiredError(
          'teamId',
          'Required parameter teamId was null or undefined when calling searchSupervisorInTeam.'
        )
      }
      const localVarPath = `/call_center/teams/{team_id}/supervisors`.replace(
        `{${'team_id'}}`,
        encodeURIComponent(String(teamId))
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      if (size !== undefined) {
        localVarQueryParameter['size'] = size
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (domainId !== undefined) {
        localVarQueryParameter['domain_id'] = domainId
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update SupervisorInTeam
     * @param {string} teamId
     * @param {string} id
     * @param {EngineUpdateSupervisorInTeamRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSupervisorInTeam: async (
      teamId: string,
      id: string,
      body: EngineUpdateSupervisorInTeamRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamId' is not null or undefined
      if (teamId === null || teamId === undefined) {
        throw new RequiredError(
          'teamId',
          'Required parameter teamId was null or undefined when calling updateSupervisorInTeam.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling updateSupervisorInTeam.'
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateSupervisorInTeam.'
        )
      }
      const localVarPath = `/call_center/teams/{team_id}/supervisors/{id}`
        .replace(`{${'team_id'}}`, encodeURIComponent(String(teamId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication AccessToken required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Webitel-Access')
            : await configuration.apiKey
        localVarHeaderParameter['X-Webitel-Access'] = localVarApiKeyValue
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * SupervisorInTeamServiceApi - functional programming interface
 * @export
 */
export const SupervisorInTeamServiceApiFp = function(
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create SupervisorInTeam
     * @param {string} teamId
     * @param {EngineCreateSupervisorInTeamRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSupervisorInTeam(
      teamId: string,
      body: EngineCreateSupervisorInTeamRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineSupervisorInTeam>
    > {
      const localVarAxiosArgs = await SupervisorInTeamServiceApiAxiosParamCreator(
        configuration
      ).createSupervisorInTeam(teamId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Remove SupervisorInTeam
     * @param {string} teamId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSupervisorInTeam(
      teamId: string,
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineSupervisorInTeam>
    > {
      const localVarAxiosArgs = await SupervisorInTeamServiceApiAxiosParamCreator(
        configuration
      ).deleteSupervisorInTeam(teamId, id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary SupervisorInTeam item
     * @param {string} teamId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readSupervisorInTeam(
      teamId: string,
      id: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineSupervisorInTeam>
    > {
      const localVarAxiosArgs = await SupervisorInTeamServiceApiAxiosParamCreator(
        configuration
      ).readSupervisorInTeam(teamId, id, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List of SupervisorInTeam
     * @param {string} teamId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchSupervisorInTeam(
      teamId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineListSupervisorInTeam>
    > {
      const localVarAxiosArgs = await SupervisorInTeamServiceApiAxiosParamCreator(
        configuration
      ).searchSupervisorInTeam(teamId, page, size, q, domainId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update SupervisorInTeam
     * @param {string} teamId
     * @param {string} id
     * @param {EngineUpdateSupervisorInTeamRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSupervisorInTeam(
      teamId: string,
      id: string,
      body: EngineUpdateSupervisorInTeamRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<EngineSupervisorInTeam>
    > {
      const localVarAxiosArgs = await SupervisorInTeamServiceApiAxiosParamCreator(
        configuration
      ).updateSupervisorInTeam(teamId, id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * SupervisorInTeamServiceApi - factory interface
 * @export
 */
export const SupervisorInTeamServiceApiFactory = function(
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  return {
    /**
     *
     * @summary Create SupervisorInTeam
     * @param {string} teamId
     * @param {EngineCreateSupervisorInTeamRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSupervisorInTeam(
      teamId: string,
      body: EngineCreateSupervisorInTeamRequest,
      options?: any
    ): AxiosPromise<EngineSupervisorInTeam> {
      return SupervisorInTeamServiceApiFp(configuration)
        .createSupervisorInTeam(teamId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Remove SupervisorInTeam
     * @param {string} teamId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSupervisorInTeam(
      teamId: string,
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineSupervisorInTeam> {
      return SupervisorInTeamServiceApiFp(configuration)
        .deleteSupervisorInTeam(teamId, id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary SupervisorInTeam item
     * @param {string} teamId
     * @param {string} id
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readSupervisorInTeam(
      teamId: string,
      id: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineSupervisorInTeam> {
      return SupervisorInTeamServiceApiFp(configuration)
        .readSupervisorInTeam(teamId, id, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List of SupervisorInTeam
     * @param {string} teamId
     * @param {number} [page]
     * @param {number} [size]
     * @param {string} [q]
     * @param {string} [domainId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchSupervisorInTeam(
      teamId: string,
      page?: number,
      size?: number,
      q?: string,
      domainId?: string,
      options?: any
    ): AxiosPromise<EngineListSupervisorInTeam> {
      return SupervisorInTeamServiceApiFp(configuration)
        .searchSupervisorInTeam(teamId, page, size, q, domainId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update SupervisorInTeam
     * @param {string} teamId
     * @param {string} id
     * @param {EngineUpdateSupervisorInTeamRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSupervisorInTeam(
      teamId: string,
      id: string,
      body: EngineUpdateSupervisorInTeamRequest,
      options?: any
    ): AxiosPromise<EngineSupervisorInTeam> {
      return SupervisorInTeamServiceApiFp(configuration)
        .updateSupervisorInTeam(teamId, id, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * SupervisorInTeamServiceApi - object-oriented interface
 * @export
 * @class SupervisorInTeamServiceApi
 * @extends {BaseAPI}
 */
export class SupervisorInTeamServiceApi extends BaseAPI {
  /**
   *
   * @summary Create SupervisorInTeam
   * @param {string} teamId
   * @param {EngineCreateSupervisorInTeamRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupervisorInTeamServiceApi
   */
  public createSupervisorInTeam(
    teamId: string,
    body: EngineCreateSupervisorInTeamRequest,
    options?: any
  ) {
    return SupervisorInTeamServiceApiFp(this.configuration)
      .createSupervisorInTeam(teamId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Remove SupervisorInTeam
   * @param {string} teamId
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupervisorInTeamServiceApi
   */
  public deleteSupervisorInTeam(
    teamId: string,
    id: string,
    domainId?: string,
    options?: any
  ) {
    return SupervisorInTeamServiceApiFp(this.configuration)
      .deleteSupervisorInTeam(teamId, id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary SupervisorInTeam item
   * @param {string} teamId
   * @param {string} id
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupervisorInTeamServiceApi
   */
  public readSupervisorInTeam(
    teamId: string,
    id: string,
    domainId?: string,
    options?: any
  ) {
    return SupervisorInTeamServiceApiFp(this.configuration)
      .readSupervisorInTeam(teamId, id, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List of SupervisorInTeam
   * @param {string} teamId
   * @param {number} [page]
   * @param {number} [size]
   * @param {string} [q]
   * @param {string} [domainId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupervisorInTeamServiceApi
   */
  public searchSupervisorInTeam(
    teamId: string,
    page?: number,
    size?: number,
    q?: string,
    domainId?: string,
    options?: any
  ) {
    return SupervisorInTeamServiceApiFp(this.configuration)
      .searchSupervisorInTeam(teamId, page, size, q, domainId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update SupervisorInTeam
   * @param {string} teamId
   * @param {string} id
   * @param {EngineUpdateSupervisorInTeamRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupervisorInTeamServiceApi
   */
  public updateSupervisorInTeam(
    teamId: string,
    id: string,
    body: EngineUpdateSupervisorInTeamRequest,
    options?: any
  ) {
    return SupervisorInTeamServiceApiFp(this.configuration)
      .updateSupervisorInTeam(teamId, id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
